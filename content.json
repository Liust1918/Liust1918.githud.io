{"posts":[{"title":"Hexo常用操作","text":".","link":"/Liust1918.githud.io/2022/12/03/My-New-Post/"},{"title":"C语言入门","text":"C语言入门 第一章软件安装 进入微软官网 下载Visual Studio 1https://visualstudio.microsoft.com/zh-hans/ 下载社区版Community 选择 使用C++的桌面开发 新建项目和项目结构,编译新建项目 选择一个模板(例如:空项目,控制台应用等等) 确定项目 解决方案名称：相当于java的项目名 项目名称:相当于java的包名 对源文件右键新建项 将.cpp 改为 .c 项目结构 .c 为源文件 项目编译过程 源代码: .c 目标代码: .obj 可执行代码: .exe 项目运行和调试运行 main类(入口类，只能有一个) main主方法 点击 调试 设置断点 点击本地Windows调试器 看内存和监视 调试快捷键 功能 快捷键 给改行添加断点(再点一次就取消断点) fn+F9 从main()函数的第一条语句开始执行 fn+F10 执行下一条语句 fn+F10 不进入子函数，但是会将子函数的代码执行完 fn+F10 程序一直执行到断点 fn+F5 退出调试 fn+shift+F5 重新调试代码 fn+ctrl+shift+F5 进入子函数内 fn+F11 退出子函数 fn+shift+F11 第二章命名规范 关键字限制 大小写敏感 字母，数字(不能开头)，下划线为变量名 变量和常量变量a为变量 12int a;a=3; 符号常量 添加 #define 预处理关键字 不可再赋值 常量名全大写 不用加分号 1#define 常量名(全大写) 常量值 1#define PI 3 查看变量的内存(使用VS的监视和内存) 添加断点 在监视的名称中填入 &amp;变量名 获得 监视 中的 值 将 值 拖入到 内存中，显示内存 例： 输入和输出从屏幕输出prinf（标准输出）例: 12345#include &lt;stdio.h&gt;int main(){ int a=3; printf(&quot;%d&quot;,a);} 输出格式化 字符类型 作用 格式控制 %d 带符号整数 负号向右对其 %Ad（A为位数） %f 浮点数 %A.Bf (A整数位数,B为小数位数) %c 字符 %s 一串字符 %u 无符号整数 %x 无符号十六进制，小写字母 从屏幕输入scanf（标准输入） 注意赋值到变量 必须添加**&amp;符号** &amp;变量名 例: 12345#include &lt;stdio.h&gt;int main(){ int b; scanf(&quot;%d&quot;,&amp;b);} 读取标准输入缓冲区问题问题1234567int a;char c;scanf(&quot;%a&quot;,&amp;a);printf(&quot;%a&quot;,a);scanf(&quot;%c&quot;,&amp;c);printf(&quot;%c&quot;,c);//程序会在第一个输入完后，直接跳到最后 原理 每次输入后回车, 缓冲区会有 内容+”\\n” 再次输出后 ，缓冲区有 “\\n” 但是字符类型发现还有内容，所以直接输出,不再暂停 匹配规则 整型，浮点数，字符串 会忽略’\\n’(回车符)，空格符等 字符类型会识别 消除\\n换行符号问题描述123456//前面有输入(输出后会在标准输入缓冲区 有'\\n')scanf(&quot;%d&quot;,&amp;d);...//这里会卡住gets(p); 解决添加,来消除“\\n” 12char c;scanf(&quot;%c&quot;,c); 1234567//前面有输入(输出后会在标准输入缓冲区 有'\\n')scanf(&quot;%d&quot;,&amp;d);char c;scanf(&quot;%c&quot;,c);//这里会卡住gets(p); 错误问题: 由于微软的C语言标准问题，会报错,或者使用其他包 解决方法: 1#define _CRT_SECURE_NO_WARNINGS //解决scanf编译问题 数据类型 数据类型 字节 int 4 float/double 4 char 1 注: 1位 (bit) 存储 0(高电)或1(低电) 1字节（byte）=8位（bit） 1Kb=2^10 byte 1Mb=2^10 Kb 整型进制变换 常用进制 范围 输出字符 十进制 0-9 %d 二进制 1 0 八进制 0-7 %o 十六进制 0-9 a-f %x 高转低进制高除低取余,倒取值,从左到右,高位开始 (在vs中的内存，由于cpu的小端存储，所以是从左到右是低位开始) 赋值 直接十进制 0xXX 十六进制 （例如: 0x7b 输出123） 输出12int a=12;printf(&quot;%d&quot;,a); 浮点型f赋值 类型 案例 小数类型 0.xxxxx 指数类型(不推荐) AeB(B不能位小数) = Ax10^B 12float f=0.123;float f=1.23e3; 输出12float f=0.123;printf(&quot;%f&quot;,f); 字符型常量c赋值 单引号 转译字符 \\n 换行 \\b 退格 \\\\ 反斜杠 1char c='A' 大小写转换 字符 ASCII码 A 65 a 97 注意:相差32 1234char c='a';c=c-32;printf(&quot;%c&quot;,c);//输出 A 输出12char a='a';printf(&quot;%c&quot;,a); 字符串常量（C语言不提供，通过字符数组提供）规定 结尾添加一个字符串结束标记（占x+1字节） 结束符 “\\0” ‘\\0’==0 ==&gt;ture 运算符 运算符 符号 算数 + - * / % 关系 &gt; &lt; == &lt;= &gt;= != 逻辑 ! &amp;&amp; || 赋值 = 位 &lt;&lt; &gt;&gt; ~ | ^ &amp; 条件 ?： 求字节数 sizeof 强制类型转换 (类型) 逗号 ，。 指针 * &amp; 分量 . -&gt; 下标 [] 自增减 – ++ 算数运算符注意 % ： 两边只能整数 优先级:乘除取余 &gt; 加减 关系运算符注意 0 高 false 1 低 ture 一切非0值 ture 浮点数比较是否为某值 IEEE 754会把浮点数近似 别用==比较浮点数 要用距离数轴0.0001的 1234float f=123.45if(f-123.45&gt;-0.0001 &amp;&amp; f-123.45&lt;0.0001){} 逻辑运算符 || 一真则真，全假为假 0 false &amp;&amp; 一假则假，全真为真 1 true ! !0=1 !1=0 !X(非0数)=0 赋值运算符= 位运算符条件运算符求字节数运算符注意 sizeof(变量) 自增减运算符注意 不能用于常量 ```ca=i++;//等于a=i;i++; 1234567891011121314151617#### 逗号运算符##### 注意- 从左向右执行- 用逗号隔开每个表达式- **最后一个表达式为ture，整个判断才为ture**```cif((表达式1),(表达式2),(表达式3)....){} 指针运算符混合运算输出和强制转型12345int i=5;float j= i/2; //输出2float k= (float)i / 2 //输出2.5//两个整数就进行整数运算//其余进行浮点运算 多个输出和输入1234scanf(&quot;%d%f%c&quot;,&amp;a,&amp;b,&amp;c);printf(&quot;%d%f%c&quot;,a,b,c);//一一对应//在cmd输入操作 先输入第一个数，再空格，再输入第二个数.... 混合数据类型读取一个scanf读多种类型的数据 混合输入时每次在%c之前需要加入空格 12345678int main(){ int i; char c; float f; scanf(&quot;%d %c%f&quot;,&amp;i,&amp;c,&amp;f); printf(&quot;i=%i,c=%c,f=%f&quot;,i,c,f); return 0;} 循环读取 while(…){} rewind(stdin) 每次都将标准输入缓冲区清空 i=scanf(“%d”,&amp;a)!=EOF EOF为常量-1，作为错误标识 输入正确时候，i有值，否则为-1 行首按三次ctrl+Z 12345678int main(){ int i,ret; while(rewind(stdin),(ret=scanf(&quot;%d&quot;,&amp;i))!=EOF){ printf(&quot;i=%d\\n&quot;,i); } return 0;} 12345678910111213int main(){ char c; while(scanf(&quot;%c&quot;,&amp;c)!=EOF){ if(c!='\\n'){ printf(&quot;%c&quot;,c-32); } else{ printf(&quot;\\n&quot;); } } return 0;} 第三章简单运算符优先级算术&gt;关系&gt;逻辑或与 选择 if(){} if(){} else{} if(){} else if(){ } else{} 循环 while(){ } for(表达式1；表达式2；表达式3){} 和1java一样 continue; 结束本次循环 break; 结束整个循环 第四章数组一维数组(初试不考)定义123456//类型说明符 数组名[常量表达式];int a[10];//例1int b[10]={1,2,3,4,5,6,7,8,9,10}; 注意 数组大小不能动态定义 一定是常量表达式,不能为变量,不能为0 数组一开始就定义了大小，不能更改 默认值都为0 下标从0开始，小心数组越界 数组在传递时，元素个数传递不过去 12345void print(int a[],int len){//数组不主动定义范围//并且传递一个数组的元素个数值过去} 字符数组定义12345678char a[4];a[0]='a';a[1]='';... char a[4]={'a','b','c','d'};char a[5]=&quot;1234&quot;; 注意 字符数组最后一位会有 ‘\\0’ 作为结束符号 所以最后一位别赋值 或者 定义数组时候（直接范围+1） 否则会出现 ”烫烫“ 0x cc cc cc cc 123char a[10];//可以存9为字符//最后一位(下标9)是'\\0' 输入输出字符串%s使用1234567//1定义字符数组char a[10];//标准输入 scanf(&quot;%s&quot;,字符数组变量);scanf(&quot;%s&quot;,a);//标准输出 printf(&quot;%s&quot;,字符数组变量);printf(&quot;%s&quot;,a); 注意 在使用**%s**的时候 当输入的字符数组存空格符号\\n ，会停止输出 所以引出下面的gets函数 gets函数使用类似scanf 1char *gets(char *str); 函数从STDIN（标准输入）读取字符串 将字符串加载到str 遇到 \\n 或者 EOF 才停止 会存储空格 注意 gets函数会把 字符串中的 ‘\\n’ 转化为 ‘’\\0’ 只能去输入字符串 当一次读取一行时候使用 puts函数使用类型printf 1int puts(char *str); 函数把str 写入 STDOU(标准输出) 成功执行返回 非负值 失败则返回 EOF 会输出空格 注意 会打印出换行符\\n 例子123456void main(){ char c[10]; gets(c); puts(c); //等价于printf(&quot;%s\\n&quot;,c) return 0;} str系列字符串操作函数先引用头文件 1#include &lt;string.h&gt; 注意1const说明必须是常量 strlen统计字符串长度 1size_t strlen(char *str); 区分sizeof() sizeof统计数组声明时候的大小 strlen是数组的实际大小 123char a[10]=&quot;123&quot;sizeof(a);//返回10strlen(a);//返回3 strcpy将某个字符串复制到字符数组中 1char *strcpy(char *to,const char *from); strcmp比较两个字符串的大小 1int strcmp(const char *str1,const char *str2) 注意 比较对应字符位置的ascii码值, 本质上 str1-str2 str1=str2 输出0 str1&lt;str2 输出-1 str1&gt;str2 输出1 strcat将后一个字符串拼接到前一个字符串的后面 1char *strcat(char *str1,const char *str2); 注意 前一个字符数组大小=原本存储字符串大小+后加字符串大小+一位结束符 第五章指针本质——保存地址指针的定义使用1基类型 *指针变量名 123456int a=1;// 变量a地址=变量a的值int *p=&amp;a;// 指针地址=指针变量(保存变量a的地址)int *a,*b,*c; 直接访问和间接访问12345678int main(){ int a=1; int *p=&amp;a; //直接访问 printf(&quot;%d\\n&quot;, a); //间接方法 printf(&quot;%d\\n&quot;, *p);} 注意 什么类型的指针一定要指向对应类型的变量 (IEEE754标准) 变量不包含* 取地址操作符&amp;和取值操作符*使用 &amp; 取地址/引用 * 取值/解引用—-获取地址的值 12345678int main(){ int a=1; int *p=&amp;a; //直接访问 printf(&quot;%d\\n&quot;, a); //间接方法 printf(&quot;%d\\n&quot;, *p);} 注意 **&amp;a=*&amp;a=a* 例如*&amp;a 首先 &amp;a 得到a的地址 再*运算 取地址中的值 得到 a的值 没有意义 指针即可读又可写 12*p=5;int a=*p 指针的使用场景—传递与偏移传递–传递指针使用地址的传递,例如在函数之间传递 1234567891011121314151617181920212223#include &lt;stdio.h&gt;//指针的传递void change1(int* e) { //接收到相同基类型的指针 //对i地址(指针j地址) 进行取值 获得 变量i地址（指针变量） //对变量i地址赋值 =5 *e = 5;}void main() { // 变量i地址=变量值 int i = 10; printf(&quot;使用指针:主函数直接传指针给副函数\\n&quot;); // 指针j地址=变量i地址（指针变量） int* j = &amp;i; printf(&quot; before %d\\n&quot;, i); //将指针j地址传输到副函数 change1(j); printf(&quot;after %d\\n&quot;, i); return 0;} 或者 12345678910111213141516171819#include &lt;stdio.h&gt;void main() { int a = 15; int* b = &amp;a; int* c = b; int d = *c; printf(&quot;%d\\n&quot;, d);//输出 15 int a1 = 15; int* b1 = &amp;a1; int* c1 = b1; *c1 = 20; printf(&quot;%d\\n&quot;, a1);//输出20 return 0;} 注意 传输指针地址 1change1(j); 获取指针的指针变量(获得i的地址 ,并对他赋值) 1*e = 5; 可以达到通过副函数 修改 主函数局部变量的值 偏移——指针加减使用指针通过加减来实现数组的偏移 123456789101112131415#include &lt;stdio.h&gt;void main() { //指针的偏移 int arr[10] = { 1,2,3,4 }; int* p = arr; printf(&quot;指针指向数组的起始地址(数组第一个元素) %d\\n&quot;, *p); p++; printf(&quot;指针+1 %d\\n&quot;, *p);//输出1 p++; printf(&quot;指针+1 %d\\n&quot;, *p);//输出2 return 0;} 注意 指针 数组 例子 *p=arr 指向数组的起始地址(数组的第一个元素,下标为0) 0x000000 p+1 (指针+1) 指针指向地址=数组起始地址+基类型字节数 (数组的 下一个元素) 0x000004 p+1 (指针+1) 0x000008 指针的类型与数组的基类要一致 自增,自减运算符使用指针和自增减运算符 123456789101112131415161718192021#include &lt;stdio.h&gt;void main() { int a[4] = { 3,2,4 }; int* p; int j; p = a; j = *p++; printf(&quot;a[0]=%d,j=%d,*p=%d\\n&quot;, a[0], j, *p);//输出 3 3 2 int a1[4] = { 1,2,3 }; int* p1; int j1; p1 = a1; j1 = (*p1)++;//等价于 j1=a[0]++; 或者 j1=p[0]++; *p1获取 地址中的值 并且改变 printf(&quot;a1[0]=%d,j1=%d,*p1=%d\\n&quot;, a1[0], j1, *p1);//输出 2 1 2 return 0;} 注意1234a=*p++//等于a=p*;p++; 1234567j1=(*p)++;//等于//*p 获取地址的值 //1. j1=*p=1//2. 修改数组的值 a[0]++; 让a[0]=1+1=2//3. 指针没有偏移 一堆数组 函数调用的本质是值传递 在传递值为数组时候，只会传递数组的首地址，不会传数组大小 数组传递的时候 ，弱化为指针 123void change(char *d){}//等价于void change(char d[]){} 数组名作为实参 传递给 子函数时候，弱化为指针 1234567891011121314#include &lt;stdio.h&gt;void change(char* a) { *a = 'j';}void main() { char arr[10] = &quot;hack&quot;; printf(&quot;原来:%s\\n&quot;, arr);//hack change(arr); printf(&quot;变成:%s\\n&quot;, arr);//jack return 0;} 动态内存申请malloc 数组长度固定(一开始就确定了)很不方便,长度是因为变量都在栈空间 如果使用的空间大小不确定，那么就要使用堆空间 使用 确定申请空间大小 int类型 以字节为单位 使用malloc申请内存空间 1void* malloc(i); 返回无类型指针void* 指针指向申请空间的起始地址 申请空间的大小=i个字节 必须进行类型转换 例如void*转char*,那么char*可以存放i个字符(1个字符一个字节), 如果是int就可以存放i/4个数(1个int要4字节) 依次类推 指针主动释放空间free 指针不能产生偏移，否则会报错 或者说指针一定要是原来的malloc返回值要一致 如果一定要用这个指针进行偏移，那么可以新增一个指针 1free(指针); 指针置空—-防止野指针 野指针—当指针指向的空间，不是属于它的空间的时候. 如果不把上诉指针=null,则成为野指针 1指针=NULL; 例子123456789101112131415#include &lt;stdio.h&gt;//动态内存分配void main() { int i = 20; char* p; p = (char*)malloc(i); strcpy(p, &quot;success&quot;); printf(&quot;%s\\n&quot;, p); free(p); p = NULL; return 0;} 栈空间和堆空间 栈空间——随着函数的执行结束而释放 堆空间——不会随着子函数的结束而释放，除非用free释放空间 字符指针与字符数组的初始化使用 都可以初始化一个字符串 1234char *p=&quot;114514&quot;;//把字符串型常量&quot;hello&quot;的首地址赋给pchar c[10]=&quot;114514&quot; //等于strcpy(&quot;hello&quot;) 区别内存有权限–可读/可写 12345//无法运行//在字符串常量区不可以修改p[0]='5';//可以运行c[0]='5'; 12345//字符串123的地址给pp=&quot;123&quot;;//无法运行//地址已经确定，无法改变c=&quot;123&quot;; 二级指针的传递（了解）作用 传递 偏移 服务一级指针的传递与偏移 使用 &amp;指针—-对指针取地址 **基类型——函数接收二级指针 12345678910111213#include &lt;stdio.h&gt;//副函数void change(**int a){ }//主函数void mian(){ ... change(&amp;指针);} 一级指针详细 例子123456789101112131415161718#include &lt;stdio.h&gt;void change(int** ap, int* pb) { *ap = pb;}void main() { int a = 10; int b = 5; int* ap = &amp;a; int* bp = &amp;b; printf(&quot;a=%d,ap=%d,bp=%d\\n&quot;, a, *ap, *bp);// 10 10 5 change(&amp;ap, bp); printf(&quot;a=%d,ap=%d,bp=%d&quot;, a, *ap, *bp);// 10 5 5 return 0;} 第六章函数头文件创建 使用—声明函数(类似java的接口,.c文件是实现类) 声明方法(后续**.c文件实现**) 引用包 123456#include &lt;stdio.h&gt;void getOne();int getInt(int i); .c文件引用头文件 #include “头文件.h” 12//例如头文件为 func.h#include &quot;func.h&quot; 函数声明(定义)和调用 在头文件声明方法 在.c文件引用头文件, 并实现函数 其他.c文件只要引用同样的头文件,就可以使用其他.c文件的实现函数 递归调用递归函数自己调用自己 一般递归套路 确定递归函数 确定结束条件 例子求n的阶乘 123456789101112131415161718192021#include &lt;stdio.h&gt;//求i的阶乘int change(int i) { //i==1 setback if (i == 1) { return 1; } //f(n)=n*f(n-1) return i * change(i - 1);}void main() { int count; count = change(5); printf(&quot;%d\\n&quot;, count); return 0;} 爬楼梯问题(斐波那契数列) 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;//爬楼梯问题//i个阶梯 只能走1或者2步 求多少钟走法//阶梯 1 2 3 4 5//方法数 1 2 3 5 8int ladderFunction(int i) { if (i == 1) { return 1; } if (i == 2) { return 2; } return ladderFunction(i - 1) + ladderFunction(i - 2);}void main() { int count; count = ladderFunction(5); printf(&quot;%d&quot;, count); return 0;} 变量和函数的作用域局部变量 函数内 作用范围:最近的大括号 存储在栈空间 全局变量 函数外 存储在内存空间中的数据区 不推荐使用 优先局部&gt;全局 例子1234567891011#include &lt;stdio.h&gt;int i = 10;void main() { int i = 5; i++; printf(&quot;局部变量%d\\n&quot;, i); return 0;} 中级结构体和结构体指针结构体的定义，引用，初始化定义1234struct 结构体名{ 数据类型 名; 数据类型 名[数组];} 例子123456//结构体定义struct box { int id; int num; char name[20];}; 初始化一般123//结构体的初始化 struct box apple = { 5,100,&quot;苹果&quot; }; 结构体数组12struct box fruit[3] = { 5,100,&quot;苹果&quot;,7,200,&quot;香蕉&quot;,8,300,&quot;橘子&quot; }; 引用123456//方式一printf(&quot;box.id=%d,box.num=%d,box.name=%s\\n&quot;, apple.id, apple.num, apple.name);//方式二printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, fruit[i].id, fruit[i].num, fruit[i].name); 结构体指针初始化一般12//结构体指针struct box* p = &amp;apple; 数组1struct box* p1 = fruit; 使用 指针-&gt;结构体的属性 (*指针).结构体的属性 .的优先级比*要高，会报错 所以一定要加括号 1234567//printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, *p.id, *p.num, *p.name); //.的优先级比*要高，所以不建议 // .选择(对象) // -&gt;选择(指针) printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, (*p).id, (*p).num, (*p).name); printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, p-&gt;id, p-&gt;num, p-&gt;name); 其他 .和-&gt; 以及 [] （）的优先级是第一 特殊1123num = p1-&gt;id++; //num=p1-&gt;id //p1-&gt;id=p1-&gt;id+1 特殊2123num = p1++-&gt;id; //num=p1-&gt;id //p1=p1+1 12345678910struct box* p1 = fruit; int num; num = p1-&gt;id++; //num=p1-&gt;id //p1-&gt;id=p1-&gt;id+1 printf(&quot;after:num=%d,id=%d \\n&quot;, num, p1-&gt;id); num = p1++-&gt;id; //num=p1-&gt;id //p1=p1+1 printf(&quot;after:num=%d,id=%d \\n&quot;, num, p1-&gt;id); typedef使用作为别名 作结构体/数据类型的别名格式123typedef struct 结构体名{ .....}别名1,*指针别名1; 可以作为结构体的别名 或者做结构体指针的别名 使用1234//方式1别名1 对象名={...}//方式2(指针)指针别名1 指针名=对应指针 例子创建 1234567typedef struct box { int id; char name[20]; int num;}bo, * pbo;typedef int Integer; 使用 1234567891011void main() { bo mybox = { 200,&quot;你是才是&quot;,20 }; printf(&quot;box.id=%d,box.name=%s,box.num=%d\\n&quot;, mybox.id, mybox.name, mybox.num); pbo p = &amp;mybox; printf(&quot;box.id=%d,box.name=%s,box.num=%d\\n&quot;, p-&gt;id, p-&gt;name, p-&gt;num); Integer i = 5; return 0;} C++的引用操作 在函数的形参前添加&amp; 1234567891011//参数void modify_variable(int&amp; a) { a++;}//指针void modify_digital(int*&amp; p) { p = (int*)malloc(20); p[0] = 20;} 作用 可以用来传递变量/指针到其他函数，并且在其他函数操作它们可以和在主函数一样方便 例子12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void modify_variable(int&amp; a) { a++;}void modify_digital(int*&amp; p) { p = (int*)malloc(20); p[0] = 20;}void main() { int a = 10; printf(&quot;before:a=%d\\n&quot;, a);//10 modify_variable(a); printf(&quot;after:a=%d\\n&quot;, a);//11 int* p = NULL; modify_digital(p); printf(&quot;after:p=%d\\n&quot;, *p);//20} 等同C传递变量C++:12345int a;void modify(int&amp; a) { a++;}调用:modify(a); C:12345int a;void modify(int* a) { (*a)++;}调用:modify(&amp;a); 传递指针C++:12345int* p = NULL;void modify(int*&amp; p) { p = q;}调用:modify(p); C:12345int* p = NULL;void modify(int** p) { *p = q;}调用:modify(&amp;p); 逻辑结构和存储结构 时间复杂度和空间复杂度 线性表特性(逻辑结构)定义由n(n&gt;=0)个相同类型的元素组成的有序结合 n为表长**,n=0为空表** ai-1是ai的前驱 ai+1是ai的后继 特定 元素个数有限 元素数据类型相同(所占大小一样) 元素逻辑上顺序性 顺序表(线性表的顺序表示)特点优点 随机存取:根据表头元素地址和元素序号 存取 表中任意一个元素. 存储密度高 缺点 插入和删除要移动大量元素 变化大时,难确定存储空间的容量 存储分配是一整段连续的存储空间,碎片多 构造顺序表静态分配123456#define MaxSize 20 //表长typedef int ElemType;//将数据类型进行别名 方便改typedef struct { ElemType data[MaxSize];//数组存储数据 int length;//数组内存储的实际量}sqList; 动态分配(了解)创建12345678//动态分配#define InitSize 100typedef int ElemType;typedef struct { ElemType* data; int Maxsize, length;}DynamicSqList; 初始化1234//C的初始动态分配 DL.data = (ElemType*)malloc(sizeof(ElemType) * InitSize); //C++的初始动态分配(了解) DL.data = new ElemType[InitSize]; insert思路 元素后移 插入元素 实际容量++ 时间复杂度(移动元素,尾插法) 情况 O(f(n)) 说明 最好 O(1) 最后插入一个 最差 O(n) 第一个插入一个,要全部后移 平均 O(n/2) 取最好和最差的平均值 代码1234567891011121314151617181920//插入bool insertElem(sqList&amp; L, int index, ElemType number) { //查看插入位置是否合法 if (index&lt;1 || index&gt;MaxSize) { return false; } //查看数组是否满了 if (L.length &gt; MaxSize) { return false; } //处理 for (int i = L.length; i &gt;= index; i--) { L.data[i] = L.data[i - 1]; } L.data[index - 1] = number; //增长实际长度 L.length++; return true;} delete思路 元素前移覆盖实现删除 实际容量– 时间复杂度 情况 O(f(n)) 说明 最好 O(1) 删除最后一个 最差 O(n) 删除第一个,要全部前移动 平均 O(n/2) 取最好和最差的平均值((n-1)/2) 代码1234567891011121314151617181920//删除bool deleteElem(sqList&amp; L, int index, ElemType&amp; number) { //检查删除是否合理 if (index &lt; 1 || index&gt;L.length) { return false; } //检查是否为空表 if (L.length == 0) { return false; } //处理 number = L.data[index - 1]; for (int i = index; i &lt; L.length; i++) { L.data[i - 1] = L.data[i]; } //减少实际长度 L.length--; return true;} locate思路暴力寻找 代码123456789//查(返回位置(下标位置+1)，找不到为0)int locateElem(sqList L, ElemType i) { for (int i = 0; i &lt; L.length; i++) { if (L.data[i] == i) { return i + 1; } } return 0;} 链表(线性表的链式表示)单链表特点 数据域 指针 data next 逻辑上相邻的两个元素在物理位置上不相邻 头结点和头指针 头指针：指向第一个结点（保存地址 头结点：链上第一个结点，为了操作方便而设立的 数据域为空/表长 对插入和删除结点的操作实现统一（不用经常重置头指针） 头结点不是必须 优点 插入和删除不用移动元素 无需大量连续存储空间 缺点 附加的指针域，存在浪费存储空间的缺点 查找操作要从头开始，不能随机存取 构造单链表123456//构造链表typedef int ElemType;typedef struct LNode { ElemType data; struct LNode* next;//注意这struct是必须要的，因为编译是从上到下,还不知道别名LNode}LNode, * LinkList; 头插法创建链表思路 记忆:像一个圆 代码1234567891011121314151617181920//头插法创建链表LinkList createLinkListByHead(LinkList&amp; L) { //创建头结点 LNode* p; int x; scanf(&quot;%d&quot;, &amp;x); L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; //循环创建结点 while (x != 9999) { LNode* s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; scanf(&quot;%d&quot;, &amp;x); } return L;} 尾插法创建链表原理 代码 注意需要一个尾指针来方便操作 123456789101112131415161718192021//尾插法创建链表LinkList createLinkListByRail(LinkList&amp; L) { //创建头结点 L = (LNode*)malloc(sizeof(LNode)); LNode* p, * r = L;//r为临时指针 int x; scanf(&quot;%d&quot;, &amp;x); while (x != 9999) { //创建新结点 p = (LNode*)malloc(sizeof(LNode)); p-&gt;data = x; r-&gt;next = p;//尾插 r = p;//用临时结点保存为尾结点 scanf(&quot;%d&quot;, &amp;x); } //尾结点设置为空 r-&gt;next = NULL; return L;} 查找结点i位置思路 L=L-&gt;next 参数不用引用，只是查，并不用修改. 代码12345678910111213141516//按序号寻找结点LNode* getElem(LinkList L, int i) { if (i == 0) { return L; } if (i &lt; 1) { return NULL; } int j = 1; LNode* p = L-&gt;next; while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } return p;} 查找结点按值思路 L=L-&gt;next p-&gt;data!=值 参数不用引用，只是查，并不用修改. 代码123456789//按结点寻找结点LNode* locateLNode(LinkList L, ElemType i) { LNode* p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != i) { p = p-&gt;next; } return p;} 删除i位置节点思路 先通过getElem()找到删除i位置的前驱结点 临时结点q=前驱-&gt;next p-&gt;next=q-&gt;next 最后 q=NULL free(q) 代码123456789101112131415161718//删除第i个结点bool deleteLNode(LinkList&amp; L, int i) { //找到i位置的前驱 LNode* p = getElem(L, i - 1); if (p == NULL) { return false; } //删除操作 LNode* q = p-&gt;next; if (q==NULL) { return false; } p-&gt;next = q-&gt;next; free(q);//释放i位置结点的空间 q = NULL;//防止野指针} 第i位置插入节点思路 记忆:像一个圆 要先找到i位置的前驱 代码1234567891011121314//向第i个结点插入新结点bool insertLNode(LinkList&amp; L, int i, ElemType num) { //找到插入位置的前驱 LNode* p = getElem(L, i - 1); if (p == NULL) { return false; } //插入操作 LNode* q = (LNode*)malloc(sizeof(LNode)); q-&gt;data = num; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;} 打印单链表注意 注意跳过头结点 L=L-&gt;next 代码1234567891011121314//打印链表数据void printLinkList(LinkList L) { //跳过头节点 L = L-&gt;next; //循环打印 while (L != NULL) { ElemType num = L-&gt;data; printf(&quot;%d &quot;, num); L = L-&gt;next; } printf(&quot;\\n&quot;);} 双链表特点 前指针 数据域 后指针 prior data next 逻辑上相邻的两个元素在物理位置上不相邻 构造双链表1234567typedef int Elemtype;typedef struct DNode { Elemtype data; struct DNode* prior; struct DNode* next;}DNode, * DLinkList; 头插法创建链表思路 记忆:想画一个八 注意: 123if (L-&gt;next != NULL) {//第一步需要这样做，不然会访问空 L-&gt;next-&gt;prior = p; } 代码12345678910111213141516171819202122//头插法void createDLinklist(DLinkList&amp; L, Elemtype elemArray[], int len) { //创建头结点 L = (DLinkList)malloc(sizeof(DNode)); //置空 L-&gt;next = NULL; L-&gt;prior = NULL; for (int i = 0; i &lt; len; i++) { DNode* p = (DNode*)malloc(sizeof(DNode)); //想插入那样 p-&gt;data = elemArray[i]; p-&gt;next = L-&gt;next; if (L-&gt;next != NULL) {//第一步需要这样做，不然会访问空 L-&gt;next-&gt;prior = p; } p-&gt;prior = L; L-&gt;next = p; }} 尾插法创建链表思路 代码 注意需要一个尾指针来方便操作r 尾指针最后==NULL 1r-&gt;next = NULL; 123456789101112131415161718192021222324//尾插法void createDLinkListByTail(DLinkList&amp; L, Elemtype ar[], int len) { L = (DNode*)malloc(sizeof(DNode)); L-&gt;next = NULL; L-&gt;prior = NULL; DNode* r = L;//尾指针 for (int i = 0; i &lt; len; i++) { DNode* p = (DNode*)malloc(sizeof(DNode)); p-&gt;data = ar[i]; //直接在后面插入 //r,p //p-&gt;prior = r; //r-&gt;next = p; r-&gt;next = p; p-&gt;prior = r; r = p; } r-&gt;next = NULL;} 删除i位置节点思路 先通过getElem()找到i位置结点的前驱结点 注意（删除最后结点的情况要考虑） 1234//检查删除结点的后驱是否为空 if (q-&gt;next != NULL) { q-&gt;next-&gt;prior = p; } 代码12345678910111213141516171819202122232425262728//删除i位置的结点bool deleteDNode(DLinkList&amp; L, int i) { //防止越位 if (i &lt; 0) { return false; } //查找i点的前驱 DNode* p = getDNode(L, i - 1); //检查i点是否存在 if ((p-&gt;next) == NULL) { return false; } //保存删除结点指针 DNode* q = p-&gt;next; //p,q p-&gt;next = q-&gt;next; //检查删除结点的后驱是否为空 if (q-&gt;next != NULL) { q-&gt;next-&gt;prior = p; } //释放q空间 free(q); //防止野指针 q = NULL; return true;} 其余的和单链表差不多循环单链表特点 最后的结点的next不是NULL，而是指向头结点L 其他和单链表一样 注意在一些循环操作中，注意结束符号是 r-&gt;next=L while(p-&gt;next!=L) 循环双链表特点 最后的结点next指向头结点L 头节点的prior指向最后结点 其他和单链表一样 注意在一些循环操作中，注意结束符号 静态链表特点用数组来描述链式存储结构 数组地址 数据域 存储地址 代码12345#define Maxsize 20typedef struct SLinkList{ ElemType data; int next;}SLinkList[Maxsize]; 栈Stack特性定义只允许在一段进行插入/删除操作的线性表 特性先进后出(FILO,First In Last Out) 栈顺序用顺序表构建栈 结构123456789//栈数据类型#define MaxSize 5typedef int ElemType;typedef struct { ElemType data[MaxSize]; int top;//数据内容长度(并且是top栈顶元素的数组下标) //从-1到Maxsize-1 //不仅是数组下标而且还是是数组容量}SqStack; 初始化initStack思路 top=-1 代码12345//初始化栈initStackvoid initStack(SqStack&amp; s) { //栈下标为-1 s.top = -1;} 检查栈空isEmpty思路 检查top==-1 代码12345678//检查栈空stackEmptybool stackEmpty(SqStack&amp; s) { if (s.top == -1) { return false; } return true;} 入栈push思路 判定栈是否满 先对top++ 再对对应位置赋值 代码123456789101112//入栈pushbool push(SqStack&amp; s, ElemType num) { //判读栈是否满 if (s.top == MaxSize - 1) { return false; } //++s.top 先将-1加加到0 下标 //然后赋值 s.data[++s.top] = num; return true;} 出栈pop思路 先判断栈是否为空 先获得值 再top– 代码1234567891011//出栈popbool pop(SqStack&amp; s, ElemType&amp; num) { //判断栈是否空 if (stackEmpty(s)) { return false; } //s.top-- 先给他赋值 //在容量-- num = s.data[s.top--]; return true;} 获得栈顶元素getTop思路 检查是否为空 直接用top获得栈顶元素 代码12345678910//获取顶点getTopbool getTop(SqStack s, ElemType&amp; num) { //判断是否为空 if (stackEmpty(s)) { return false; } //获得顶点(top) num = s.data[s.top]; return true;} 栈链式(带头结点)结构 一个是指针 一个节点 1234567//结构#define Maxsize 5typedef int Elemtype;typedef struct LStackNode { Elemtype data; struct LStackNode* next;} *LStack, LStackNode; 初始化initStack思路 生成头结点 头结点设置为栈长==-1 代码12345678//初始化栈initStackvoid initStack(LStack&amp; L) { LStack head = (LStack)malloc(sizeof(LStackNode)); head-&gt;next = NULL; head-&gt;data = -1; L = head;} 检查栈空isEmpty思路 检查头节点的数据是否=-1 代码1234567//检查栈空stackEmptybool stackEmpty(LStack L) { if (L-&gt;data == -1) { return true; } return false;} 入栈push思路 头插法 头结点的长度++ 代码12345678910111213141516//入栈pushbool push(LStack&amp; L, Elemtype num) { if ((L-&gt;data) == (Maxsize - 1)) { //判断栈满 return false; } LStack top; top = (LStack)malloc(sizeof(LStackNode)); top-&gt;next = NULL; top-&gt;data = num; //头插法 top-&gt;next = L-&gt;next; L-&gt;next = top; L-&gt;data++; return true;} 出栈pop思路 删除第一个元素 头结点的长度– 代码1234567891011121314//出栈popbool pop(LStack&amp; L, Elemtype&amp; num) { if (stackEmpty(L)) { return false; } //头删除 LStack top = L-&gt;next; num = top-&gt;data; L-&gt;next = top-&gt;next; free(top); top = NULL; L-&gt;data--; return true;} 获得栈顶元素getTop思路 直接获取第一个元素 代码12345678910//获得栈顶元素getTopbool getTop(LStack L, Elemtype&amp; num) { if (stackEmpty(L)) { return false; } LStack top = L-&gt;next; num = top-&gt;data; return true;} 循环队列队列Queue定义 操作受限的线性表 只允许一端插入（入列） 另一端删除(出列) 特征 先进先出(FLFO,First ln First Out) 要牺牲一个格，来判断队空还是队满 队空 Q.rear==Q.front 队满 Q.rear==(Q.front+1)%Maxsize 顺序表实现队列结构思路 数组放数据 front：队首 rear：队尾 入列——队尾++ 出列——队首++ 像个轮盘 代码123456#define Maxsize 6typedef int Elemtype;typedef struct SqQueue { Elemtype data[Maxsize]; int front, rear;}SqQueue; 初始化队列思路 队首和队尾在一开始 代码12345//初始化队列void initQueue(SqQueue&amp; q) { q.front = 0; q.rear = 0;} 队列是否为空思路 队尾和队首是否相差隔一格(队首在前，队尾向后) 代码1234567//队列是否为空bool isEmpty(SqQueue q) { if (q.front == (q.rear + 1) % Maxsize) { return true; } return false;} 入列思路 检查队列是否满 在rear下标位置插入数据 rear向前一格 代码12345678910//入列bool enQueue(SqQueue&amp; q, Elemtype num) { if (q.front == (q.rear + 1) % Maxsize) { return false; } q.data[q.rear] = num; q.rear = (q.rear + 1) % Maxsize; return true;} 出列思路 判定队列是否为空 拿出数据 队首向前一格 代码12345678910//出列bool deQueue(SqQueue&amp; q, Elemtype&amp; num) { if (q.front == q.rear) { return false; } num = q.data[q.front]; q.front = (q.front + 1) % Maxsize; return true;} 链表实现队列结构思路 一个是链结点 队首指针 队尾指针 代码123456#define Maxsize 5;typedef int Elemtype;typedef struct LinkNode { Elemtype data; struct LinkNode* next;} LinkNode; 12345typedef struct { //固定头结点为fornt作为出列 //尾插元素 实现入列 LinkNode* front, * rear;}LinkQueue; 初始化队列思路 队首生成头结点 代码12345//初始化队列void initQueue(LinkQueue&amp; q) { q.front = q.rear = (LinkNode*)malloc(sizeof(LinkNode)); q.front-&gt;next = NULL;} 队列是否为空思路 队首指针和队尾指针是否指向同一个结点 代码1234567//查看队列空bool isEmpty(LinkQueue q) { if (q.front == q.rear) { return true; } return false;} 入列思路 生成结点 尾插法 队尾指针rear 指向新结点 代码12345678910//入列(尾插)bool enQueue(LinkQueue&amp; q, Elemtype num) { //不用判满 LinkNode* rear = (LinkNode*)malloc(sizeof(LinkNode)); rear-&gt;next = NULL; rear-&gt;data = num; q.rear-&gt;next = rear; q.rear = rear; return true;} 出列思路 检查是否队列为空 拿出数据 头删法 注意：检查队首和队尾指针是否一样 队首赋值给队尾 free和指针设NULL 代码1234567891011121314151617//出列(头删)bool deQueue(LinkQueue&amp; q, Elemtype&amp; num) { if (q.front == q.rear) { return false; } LinkNode* fornt = q.front-&gt;next; num = fornt-&gt;data; //头删除 q.front-&gt;next = fornt-&gt;next; if (q.rear == q.front) {//当只有一个结点要删除 q.rear = q.front; } free(fornt); fornt = NULL;}","link":"/Liust1918.githud.io/2022/12/03/sb/"},{"title":"git和githud","text":"使用Git+Githud git干什么干什么 分布式 版本控制 为什么版本控制保留之前的版本，方便项目的回滚以及修改 版本控制历史 文件夹拷贝 本地版本控制 集中式版本控制 分布式版本控制 配置基本gitcmd基本操作 命令 作用 cd 文件名/文件夹名 进入 cd(空格) .. 回退 mkdir 文件名 创建文件夹 ~ /文件名 查找文件 shift+insert+fn 粘贴内容 长按Q 退出编辑模式 ls 查看当前文件夹下有什么文件 pwd 查看当前分支路径 cat 文件名 查看文件内容 安装git地址：https://git-scm.com/downloads 添加个人信息配置 打开Git Bash 添加用户名 1git config --global user.name &quot;用户名&quot; 添加邮箱 1git config --global user.email &quot;邮箱&quot; 查看用户名和邮箱 1234git config user.namegit config user.email或者git config list 添加密钥 生成密钥 1ssh-keygen -t rsa -C &quot;邮箱地址&quot; 然后连续enter通过，获得.ssh文件 在本地添加私钥 路径到达.ssh文件 开启 1ssh-agent 添加私钥,执行id_rsa文件 1ssh-add id_rsa文件 在githud添加公钥 找到.ssh文件中的id_rsa.pub 复制id_rsa.pub中的内容 前往个人页面,并且点击Setting 找到左侧的SSH and GPG keys 点击绿色按钮New SSH key 将内容复制到框内 简单操作gitgit基本命令 文件名可以是具体文件名，也可以通过输入 . 来选择所有文件 回滚操作时候获得版本号，可以通过git log 当我们执行回滚后，我们后悔执行这个回滚，可以执行返回操作： 首先执行git reflog 查找要返回操作版本号 执行返回(也可以说是回滚) git reset –hard 返回版本号 查看文件在工作区情况，通过git status 红色：未被git管理（一般为修改/新增文件） 绿色：已经被git管理 例子上传修改的文件并且设置版本 修改index.html文件 通过git status查看 git add index.html添加到暂存区 通过git status查看 是否提交暂存区 git commit -m “提交版本” 提交版本 通过git log 得知是否提交版本成功 从本地版本库回滚到暂存区 通过git log查看版本号 git reset –soft 版本号 回滚到上个版本 通过git log 检测是否回滚成功 将文件从暂存区回滚到工作区 通过git reset HEAD 回滚 通过git status检测是否回滚成功 将修改/新镇的文件继续回退到之前的状态 已修改的文件回退到未修改的时候 新增文件则会删除 通过 git chechkout – 文件名 通过git status或者直接看文件是否存在/返回修改 将上面的操作进行回退当我们对于上面的回滚感觉后悔，想返回，可以这样操作： 通过git reflog 查找操作版本号 git reset –hard 版本号 全部回滚 检查当前版本git log 操作分支为什么要有分支不用分支按照正常来说，我们一个功能一个功能开发，但是如果前面的功能出现bug，我们需要回滚到之前版本，那么中间写的各种功能都会报废.当然我可以一份保存，一份回滚，但是这样太蠢了. 引入分支分支原理 我们每个版本提交，都只会保存修改/新增部分. 然后用指针指向前一个版本，也就是在之前版本的基础上进行修改/新增功能 例子： master分支：功能正式上线 bug分支：紧急修复bug dev分支：开发其他功能 当我们主分支开发到功能3的时候，我们分出dev分支，负责开发新功能，当我们开发到功能5的时候，发布的功能3出现bug，需要我们修改bug，如果没有分支，那么我们只能从功能5直接回滚到功能3来修改bug，这样虽然可以修复bug，但是功能5和功能4都没了，而且后面的开发也停下来了.当我们拥有分支后，我们分成dev分支，直接在功能3的基础上一直开发，再新出bug分支，对功能3进行修复，这个也是修复功能3 C7，后面我们只要把C7和C3分支进行合并，这样可以既修复bug，又不影响开发其他功能. 分支实际操作 查看所有分支 1git branch 创建新分支（在本版本分出） 1git branch 新分支名 切换分支 1git checkout 分支名 将其他分支合并到本分支 1git merge 其他分支 删除分支 1git branch -d 分支名 继续合并 1git merge --continue 合并分支冲突当我们将两个分支合并的时候，会显示如下错误： 这种就是合并分支冲突. 为什么产生合并分支冲突 在两个分支中，修改的代码为同一行的时候 git无法分辨选择那个修改，在源文件中就会出现如下： 修完bug的master分支: 123456&lt;ul&gt;&lt;li&gt;功能1&lt;/li&gt;&lt;li&gt;功能2&lt;/li&gt;&lt;li&gt;功能3（改了bug）&lt;/li&gt;&lt;li&gt;功能4（75%）改了bug&lt;/li&gt;&lt;/ul&gt; dev分支： 123456&lt;ul&gt;&lt;li&gt;功能1&lt;/li&gt;&lt;li&gt;功能2&lt;/li&gt;&lt;li&gt;功能3&lt;/li&gt;&lt;li&gt;功能4（100%）&lt;/li&gt;&lt;/ul&gt; 产生冲突后：(功能4和功能3修改了同一行代码) 1234567891011&lt;ul&gt;&lt;li&gt;功能1&lt;/li&gt;&lt;li&gt;功能2&lt;/li&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&lt;li&gt;功能3（改了bug）&lt;/li&gt;&lt;li&gt;功能4（75%）改了bug&lt;/li&gt;=======&lt;li&gt;功能3&lt;/li&gt;&lt;li&gt;功能4（100%）&lt;/li&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev&lt;/ul&gt; 修复冲突在上面的产生的冲突源文件中，选择其中一行，其他删除就行了： 1234567891011&lt;ul&gt;&lt;li&gt;功能1&lt;/li&gt;&lt;li&gt;功能2&lt;/li&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&lt;li&gt;功能3（改了bug）&lt;/li&gt;&lt;li&gt;功能4（75%）改了bug&lt;/li&gt;=======&lt;li&gt;功能3&lt;/li&gt;&lt;li&gt;功能4（100%）&lt;/li&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev&lt;/ul&gt; 上面为master分支修改的内容 下面为dev分支修改的内容 假设我们选择dev分支，那么进行如下修改： 1234567&lt;ul&gt;&lt;li&gt;功能1&lt;/li&gt;&lt;li&gt;功能2&lt;/li&gt;&lt;li&gt;功能3&lt;/li&gt;&lt;li&gt;功能4（100%）&lt;/li&gt;&lt;/ul&gt; 执行 1git merge --continue 一般分支规定 master分支：一般为正式上线的，不要乱动 dev分支：开发功能 githud创建仓库githud为一个大型项目托管网站，你可以将项目上传到这里，然后在各个地方下载你的项目(前提你要上传)。 也是一个众多开源项目的网站. 创建githud仓库 注册githud账号 点击头像，点击Your repositories 点击绿色New 创建仓库 填写资料 填写项目名 填写项目描述 项目是否开发 添加其他文件 添加README.md 添加.gitignore 添加通行证（类似各种开源声明） 点击Create repository 上传/下载项目如何找到仓库地址 上传项目 添加仓库连接的别名(默认已经存在) 12git remote add origin 仓库地址//origin代表仓库地址 上传本地仓库的某一分支 123456789git push -u origin 分支//将本分支上传到origin的远程仓库//设置origin为默认地址git push origin 分支//将本分支上传到origin的远程仓库git push //将当前分支上传到默认地址 下拉项目 将本地分支切换成对应远程仓库分支 1git checkout 本地对应下拉分支 将远程仓库更新到本地仓库 12345678910git pull -u origin 分支//将远程仓库上的指定分支下拉//并且将origin设置为默认地址git pull origin 分支//将地址为origin的远程仓库中的分支下拉git pull//向默认地址拉项目//并且把当前分支作为下拉分支 克隆项目下来 克隆远程仓库 1git clone 仓库地址 克隆下来后的分支问题 当我们拉下项目后，会发现只有一个master分支. 可以克隆其他分支 1git checkout -b 远程分支 origin/远程分支 实际操作项目第一次到公司下拉项目 克隆远程仓库代码 1git clone 远程仓库地址 切换分支 1git checkout 分支 切换到dev分支进行开发 1git checkout dev 把master分支合并到dev(仅一次就行) 1git merge master 开发(修改代码) 提交代码 123git add .git commit -m &quot;版本内容&quot;git push origin dev 在家开发 切换到dev分支 1git checkout dev 拉代码 1git pull origin dev 继续开发 提交代码 123git add .git commit -m &quot;版本内容&quot;git push origin dev 在公司开发 切换到dev分支 1git checkout dev 拉代码 1git pull origin dev 继续开发 提交代码 123git add .git commit -m &quot;版本内容&quot;git push origin dev 然后循环在家在公司开发 开发完毕 切换master分支 1git checkout master 将dev分支合并到master分支 1git merge dev 提交代码 1git push origin master 切换dev代码 1git checkout dev 将master分支合并到dev分支 1git merge master 提交代码 1git push origin dev 深挖git pull场景当我们从远程仓库下拉代码的时候，会和本地代码有冲突，本地冲突分支会把远程分支合并在一起. 两个命令git pull其实里面分为两个命令： 1234git pull origin 分支======================git fetch origin 分支git merge origin/分支 命令解释 将远程分支更新到本地 1git fetch origin 远程分支 将远程分支合并/变基到本分支 1git merge origin/远程分支 ![git基本命令（含git pull）.drawio](/image/git基本命令（含git pull）.drawio.svg) 变基git rebase变基：本质上是使git记录简洁 场景一场景介绍(多个版本合并) 当我们开发的时候，提交了一堆版本，我们想经某些版本合并成一个版本，这样可以让版本记录更加简洁. 这些版本不能有已经上传到远程仓库的版本 具体操作原本版本有v1,v2到v5版本,我希望将v3到v5合并 使用git rabse范围区分： 从HEAD到对应版本号 1git rebase -i 版本号 HEAD~合并版本数量 1git rebase -i HEAD~数量 例： 执行： 12git rebase -i HEAD~3表示 从HEAD开始计算，将3个版本合并 合并版本并且添加合并后的描述 将下面两个pick改成s Ctrl+O保存 Ctrl+X退出 修改合并后的版本描述 Ctrl+O保存 Ctrl+X退出 例： 原本 修改 修改合并后版本描述(框中修改) 查看结果 git log查看 场景二场景描述(将分叉变为直线) 当我们进行两个分支合并的时候，我们会在两条不同的分支合并在一条分支上(也就是产生分叉)，但是我不希望这样做，我希望直接就在用同一条分支： 具体操作 原来 在dev分支执行git rebase 1git rebase master 假设出现Merge conflict冲突错误 进入源文件解决冲突 执行git add 1git add . 继续变基 1git rebase --continue 切换回master分支，执行git merge dev 12git checkout mastergit merge dev 完成 12git log --graph将log图形化 原理描述git rebase的本质以及和git merge相比12//在A分支git rebase B分支 将A分支复制到一份到B分支 并且A分支会指向复制那份的最前面 一般合并 变基过程 复制一份并且指向 废弃之前的 变成一条直线 操作过程图解 原本样子 切换dev分支 git rebase master 切换master分支 git merge dev 完成 场景三背景描述从远程仓库的分支下拉，会和本地分支进行合并，从而产生分支. 我们需要消除这个分支. 具体操作 在本地分支 执行git fetch 1git fetch orign 远程分支 执行变基git rebase 1git rebase origin/远程分支 完成 给开源项目贡献代码 点击项目的fork 在自己仓库找到fork的项目 clone下来开发 开发完就PR给原项目 其他配置 本项目配置(路径:项目/.git/config) 12git config --local user.name=&quot;名&quot;git config --local user.email=&quot;邮箱&quot; 全局配置(路径:~/.gitconfig) 12git config --global user.name=&quot;名&quot;git config --global user.email=&quot;邮箱&quot; 系统配置(路径:/etc/.gitconfig) 12git config --system user.name=&quot;名&quot;git config --system user.email=&quot;邮箱&quot; 忽略文件可以将某些文件不被git管理,例如各种库，没有必要被管理. 创建**.gitignore**文件 填写内容 具体文件 1read.txt 后缀文件 1*.txt 忽略路径下文件 1file/ 取反 1!a.txt 匹配 1abc[a|b|c].txt 忽略本身 1.gitignore 向项目提问题issues当你发现项目有bug，或者文档错误等等，想要询问项目作者本人.可以使用issues 提问者 点击New issue 书写标题和内容 选择Labels 将提问分类 选择Assignees 选择要提问的人 提交 书写wiki你可以给你的项目添加wiki，来说明你的项目.","link":"/Liust1918.githud.io/2022/12/03/git%E5%92%8Cgithud/"},{"title":"java8","text":"Java8核心 Lamda表达式 Stream流和默认方法 方法引用 为什么要用lamda表达式场景问题当用户的需求变得很多，开放的参数也越多,代码里面的if-else嵌套也会增加.有时用户不想使用这个属性,换成另一个属性,这时要把其他地方的代码复制过来,这样增加了重复代码.代码冗余,可读性很差. 解决方法策略模式先建个接口,在实现这个接口,把策略写入实现类中,用的时候在导入不同现实类. 缺点解决了代码冗余的问题,但是随着客户需求的不断变更,会产生很多实现类,更复杂. 匿名内部类建个接口,在使用的时候，直接用匿名内部类重写方法. 123456List&lt;Car&gt; carByMethod = getCarClass.getCarByMethod(cars, new CarPredicate() { @Override public boolean test(Car car) { return car.getPrice() &gt; 20; }}); 缺点不易理解,耗费空间资源. 更好的解决方法Lamda表达式本质：是匿名类,也是函数式接口的实现. 函数式接口和lamda表达式结构的关系 首先准备接口,并且给类接口**@FunctionalInterface** 1234@FunctionalInterfacepublic interface CarPredicate { boolean test(Car car);} 在用的类使用lamda表达式实现 123... car -&gt; car.getPrice() &gt; 30 ... Lamda表达式结构 参数列表:a,(a),(a,b) 箭头:-&gt; 函数主体：{…}或者{return ….;} 函数式接口和lamda表达式的类型判断 lamda表达式的参数要和接口方法的参数一样 lamda表达式的函数主体返回类型要和接口方法返回类型一样.(为void,也一样) 内置的函数式接口按lamda表达式结构来看 Predicate&lt;T&gt; .test() 12345//T -&gt; boolean public static void predicateTest(){ Predicate predicate = o -&gt; o.equals(&quot;114514&quot;); boolean test = predicate.test(&quot;114514&quot;); } Consumer&lt;T&gt; .accept() 12345//T -&gt; voidpublic static void consumerTest(){ Consumer consumer=o -&gt; System.out.println(o); consumer.accept(&quot;测试&quot;);} Function&lt;T,R&gt; .apply() 1234567//T -&gt; R public static void functionTest(){ ArrayList&lt;Object&gt; objects = new ArrayList&lt;&gt;(); Function function = o -&gt; objects.add(o); function.apply(&quot;114514&quot;); System.out.println(objects); } Supplier&lt;T&gt; .get() 123456//void -&gt; Tpublic static void supplier(){ Supplier supplier=() -&gt; &quot;114514&quot;; Object o = supplier.get(); System.out.println(o);} 方法引用和构造引用方法引用是什么Lamda表达式的简写 使用规则 方法引用的参数和函数式接口中参数一样 返回值也一样 类型 实例化对象::实例方法 类名::静态方法 类名::实例方法 2和3的区别当第一个参数是实例方法的调用者,第二个参数是其实例方法的参数(或者无参).则为类名::实例方法名 案例 实例化对象：：实例方法一 123456Box abc = new Box(&quot;abc&quot;, &quot;123&quot;); Supplier&lt;String&gt; a = () -&gt; abc.getName(); a.get(); Supplier&lt;String&gt; a1 = abc::getName; a1.get(); 实例化对象：：实例方法二 12345Consumer&lt;String&gt; b = (x) -&gt; System.out.println(x); b.accept(&quot;hello&quot;); Consumer&lt;String&gt; b1 = System.out::println; b1.accept(&quot;hello world&quot;); 类名：：静态方法 12345Function&lt;Integer, Integer&gt; c = (num) -&gt; Math.abs(num); Integer apply = c.apply(5); Function&lt;Integer,Integer&gt; c1=Math::abs; Integer apply1 = c1.apply(5); 类名：：实例方法 12345BiPredicate&lt;String, String&gt; d = (x, y) -&gt; x.equals(y); boolean test = d.test(&quot;a&quot;, &quot;b&quot;); BiPredicate&lt;String, String&gt; d1 = String::equals; boolean test1 = d1.test(&quot;a&quot;, &quot;b&quot;); 构造引用是什么构造新对象 使用条件构造引用的参数与对象的构造方法参数相同. 案例12345BiFunction&lt;String,String,Box&gt; e=(x,y)-&gt;new Box(x, y); Box abc1 = e.apply(&quot;abc&quot;, &quot;123&quot;); BiFunction&lt;String, String, Box&gt; e1 = Box::new; Box abc2 = e1.apply(&quot;abc&quot;, &quot;123&quot;); Stream流API是什么像工厂上的流水线一样操作集合,是一种迭代器. 优点 集合遍历不能中断,Stream流可以中断. Stream流是一次性的 Stream内部迭代,集合遍历时外部迭代. 外部迭代:由用户决定”做什么”和”怎么做（iterator遍历）” 内部迭代:用户只决定”做什么”,”怎么做”交给JVM 操作流程 源操作(构造流)集合-&gt;流 集合类.stream()12ArrayList&lt;Object&gt; objects = new ArrayList&lt;&gt;();objects.stream(); 数值-&gt;流 Stream.of()12Stream&lt;String&gt; stringStream = Stream.of(&quot;1&quot;, &quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;1&quot;, &quot;4&quot;);stringStream.forEach(System.out::println); 数组-&gt;流 Arrays.stream()12int[] ints={5,6,5,6,27};Arrays.stream(ints).forEach(System.out::println); 文件-&gt;流(了解)Files.lines() 12345678910 public void buildStreamByFile() { Stream&lt;String&gt; lines= null; try { lines = Files.lines(Paths.get(&quot;路径&quot;), Charset.defaultCharset()); lines.forEach(s -&gt; System.out.println(s));// lines.map(s -&gt; s.split(&quot;&quot;)).flatMap(strings-&gt;Arrays.stream(strings)).forEach(System.out::println); } catch (IOException e) { e.printStackTrace(); } } 创建-&gt;无限流(了解)Stream.iterate() 无限创建元素 1234long count = Stream.iterate(1, integer -&gt; integer + 1) .limit(50) .count();System.out.println(count); 中间操作筛选filter T-boolean过滤元素 12345List&lt;Car&gt; black = this.cars.stream() .filter(car-&gt;car.getColor().equals(&quot;black&quot;)) .collect(Collectors.toList());System.out.println(black); 排序sorted升序排序 1234int[] ints={0,5,7,6,15,13,3};Arrays.stream(ints). sorted(). forEach(value -&gt; System.out.println(value)); 去重distinct1234int[] ints={5,6,5,6,27};Arrays.stream(ints) .distinct() .forEach(System.out::println); 限制limit1234int[] ints={5,6,5,6,27};Arrays.stream(ints) .limit(2) .forEach(System.out::println); 跳过skip跳过n个元素 1234int[] ints={5,6,5,6,27};Arrays.stream(ints) .skip(4) .forEach(System.out::println); 映射map T-R接收一个函数为参数，将函数的结果映射成新的元素. 1234this.cars.stream() .limit(1) .map(car-&gt;car.getPrice()) .forEach(System.out::println); 流的扁平化flatMap将数组中每项参数并不是映射为一个流，而是映射成共同一个流的内容并合并起来—-&gt;扁平化为一个流. 例如: 给定:[“114514”],[“1919810”] 目标:[“1”,”1”,”4”,”5”,”1”,”4”,”1”,”9”,”1”,”9”,”8”,”1”,”0”] 非扁平化Map1234567String[] strings ={&quot;114514&quot;,&quot;1919810&quot;};List&lt;String[]&gt; collect = Arrays.stream(strings) .map(s -&gt; s.split(&quot;&quot;)) .collect(Collectors.toList());//输出数组//[Ljava.lang.String;@5fd0d5ae//[Ljava.lang.String;@2d98a335 扁平化flatMap1234567List&lt;String&gt; collect = Arrays.stream(array) .map(s -&gt; s.split(&quot;&quot;)) .flatMap(Arrays::stream) .collect(Collectors.toList());System.out.println(collect);//输出//[1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 1, 0] 任意匹配anyMatch T-boolean任意匹配到流中的某个元素返回true. 123boolean yello = this.cars.stream() .anyMatch(car -&gt; car.getColor().equals(&quot;yello&quot;));System.out.println(yello); 完全匹配allMatch T-boolean全部流都匹配才返回true 123boolean yello = this.cars.stream() .allMatch(car -&gt; car.getColor().equals(&quot;yello&quot;));System.out.println(yello); 非匹配noneMatch T-boolean没有匹配到任意一个元素返回true 123boolean b = this.cars.stream() .noneMatch(car -&gt; car.getColor().equals(&quot;14514&quot;));System.out.println(b); 任意寻找流中某个对象元素findAny().orElse()1234Car car = this.cars.stream() .findAny() .orElse(new Car(&quot;104&quot;, &quot;red&quot;, &quot;中国&quot;, 30));System.out.println(car); 寻找流中第一个元素findFirst().get()123Car car = this.cars.stream() .findFirst().get();System.out.println(car); 数值流IntStream,DoubleStream,LongStream将Stream流转为特化的流 IntStream 12int[] ints = {5, 6, 5, 6}; IntStream stream = Arrays.stream(ints); DoubleStream 12double[] doubles={5,6,5,6};DoubleStream stream1 = Arrays.stream(doubles); LongStream 12Long[] longs={5l,6l,5l,6l};Stream&lt;Long&gt; stream2 = Arrays.stream(longs); 流转换boxed将intStream,DoubleStream,LongStream流转为Stream 为什么用Boxed当你想把intStream，doubleStream，longStream直接转为list输出，会出错,这里是因为基本类型的int,double，long是不能直接装入集合类的，这里需要自动装箱,那么我们可以用boxed自动装箱. 案例 报错 1Arrays.stream(ints).collect(Collectors.toList()); 正确 1Arrays.stream(ints).boxed().collect(Collectors.toList()); 终止操作遍历元素forEach T-void123this.cars.stream().forEach(car -&gt; System.out.println(car.getColor()));//或者this.cars.stream().forEach(System.out::println); 统计元素count统计有多少个流 1this.cars.stream().count(); collect和Collectors数量Collectors.counting()12Long collect = this.cars.stream() .collect(Collectors.counting()); 最大值Collectors.maxBy(Comparator.comparingDouble(T-&gt;R)).get()123Car car = this.cars.stream() .collect(Collectors.maxBy(Comparator.comparingDouble(value -&gt; value.getPrice()))) .get(); 最小值Collectors.minBy(Comparator.comparingDouble(T-&gt;R)).get()123Car car = this.cars.stream() .collect(Collectors.minBy(Comparator.comparingDouble(value -&gt; value.getPrice()))) .get(); 求和Collectors.summingDouble(T-&gt;R)12Double collect = this.cars.stream() .collect(Collectors.summingDouble(value -&gt; value.getPrice())); 求平均值Collectors.averagingDouble(T-&gt;R)12Double collect = cars.stream() .collect(Collectors.averagingDouble(Car::getPrice)); 字符串连接Collectors.joining(内容)123String collect = this.cars.stream() .map(Car::getColor) .collect(Collectors.joining(&quot;,&quot;)); 分组Collectors.groupingBy(T-&gt;R)按照T-&gt;R来分组 12Map&lt;String, List&lt;Car&gt;&gt; collect = this.cars.stream() .collect(Collectors.groupingBy(Car::getCun)); 多级分级Collectors.groupingBy(T-&gt;R,Collectors.groupingBy(T1-R1))先按照T-&gt;R分组,在按照T1-&gt;R1分组 12Map&lt;String, Map&lt;Integer, List&lt;Car&gt;&gt;&gt; collect = this.cars.stream() .collect(Collectors.groupingBy(Car::getCun,Collectors.groupingBy(Car::getPrice))); 分区Collectors.partitioningBy(T-&gt;boolean)分区是分组一种,但是是根据true和false区分. 12Map&lt;Boolean, List&lt;Car&gt;&gt; collect = this.cars.stream() .collect(Collectors.partitioningBy(o -&gt; o.getPrice() &gt; 30)); 转为list Collectors.toList()123List&lt;String&gt; collect = this.cars.stream() .map(car -&gt; car.getColor()) .collect(Collectors.toList()); 转为set Collectors.toSet()123Set&lt;Integer&gt; collect = this.cars.stream() .map(car -&gt; car.getPrice()) .collect(Collectors.toSet()); 提取key-value为Map Collectors.toMap(key,value)12Map&lt;String, Integer&gt; collect = this.cars.stream() .collect(Collectors.toMap(car -&gt; car.getColor(), Car::getPrice)); 特型Stream总和 Collectors.summarizingInt(T-&gt;R)特化Stream其实就是intStream,doubleStream,longStream然后计算R 求和: 1collect.getSum() 求平均值 1collect.getAverage() 最大值 1collect.getMax() 最小值 1collect.getMin() 求个数 1collect.getCount() Stream流的归约操作什么是归约操作将类中的所有元素反复利用起来,最后得到一个值 求和reduce为啥用reduce利用for-each求和 1234int sum = 0;for (int x : numbers) { sum += x;} 初始值:0 操作:两个参数相加 用Stream中的reduce 12int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b); 初始值:0 操作:a和b相加 如何运行(类似累加器) 无初始值reduce前面介绍都必须有个参数,例如0 这里介绍无初始值 12Optional&lt;Integer&gt; sum = numbers.stream() .reduce((a, b) -&gt; (a + b)); 为什么返回Optional而不返回int?没有初始值.此时流中的初始值为null， 所有包含在Optional来表示和可能存在也可能不存在. 求最值最大值1Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max); 最小值1Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);","link":"/Liust1918.githud.io/2022/12/03/java8/"},{"title":"重学SpirngBoot2.X","text":"SpringBoot 2.X [TOC] 什么是SpringBoot特性 约定大于配置：配置简化,不用像传统SSM的配置地狱 无需关心依赖版本：springboot已经测试好各种依赖关系最好的版本，无需自己考虑依赖版本. 用途 快速并且简易的开发：不用很多配置 未来的SpringCloud是以SpringBoot为基础 使用IDEA构建简单SpringBoot项目file-&gt;new-&gt;project-&gt;Spring Initializr修改内容-&gt;选择需要的依赖-&gt;finish 项目结构和导出结构 src：项目主要结构 java：java源代码 主启动类：XXXApplication resources： static：静态文件 templates：模板引擎存放 application.properties：配置文件 target：项目编译后文件 pom.xml：项目描述和依赖 注意：源代码必须在主启动类的同一或者以下的文件目录 maven项目导出利用maven导出 打开IDEA右边的Maven 使用package打包 在Run中出现BUILD SUCCESS 在target文件中找到.jar文件 项目运行(win平台) 获得.jar文件 cmd运行指令：java -jar 项目名.jar 不关闭窗体就一直运行 SpringBoot主启动类启动类XXXXApplication.class @SpringBootApplication注解用途 自动初始化Spirng IOC容器 扫描并实例化Bean 自动配置组件参数 其中包含三个子注解@SpringBootConfiguration类似加载配置文件的效果,一般还会使用java类型的配置文件： 类级别：@Configuration 方法级别：@Bean 实例名：方法名 实例类：返回方法 @EnableAutoConfiguration自动配置. @ComponentScan扫描并实例化组件. @Controller——控制层 @Serivce——服务层 @Repository——持久化层 @Component——组件类 SpringBoot的Controller层用途 接收前端数据 处理业务逻辑 返回响应数据 返回响应数据页面跳转 类设置**@Controller** 创建ModelAndView对象 参数为：跳转页面 可以调用方法输入响应参数 方法返回值ModelAndView 返回JSON序列化Jackson是SpringBoot默认的JSON序列化组件 @Controller+@ResponseBody 返回对象值（对象值会被jackson序列化） @RestController相当于添加类级别@Controller，该类下面的所有方法都是默认添加@ResponseBody. 返回对象值(对象会被jackson序列化) 接收前端数据GetMapping路径变量@PathVariable 修改路径 添加**@PathVariable** 1234567@GetMapping(path = &quot;/{group}/{uid}&quot;)public Map findUser(@PathVariable(&quot;group&quot;)String group,@PathVariable(&quot;uid&quot;)String uid){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;group&quot;, group); map.put(&quot;uid&quot;, uid); return map;} 表单提交和@RequestParam表单提交 表单类型：表单名 1234567@GetMapping(value = &quot;/page1&quot;)public Map page1(int page,int rows){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;page&quot;, page); map.put(&quot;rows&quot;, rows); return map;} 添加@RequestParam @RequestParam(defaultValue=默认值,name=表单名) 12345678910@GetMapping(value = &quot;/page2&quot;)public Map page2( @RequestParam(defaultValue = &quot;1&quot;,name = &quot;p&quot;)int page, @RequestParam(defaultValue = &quot;10&quot;,name = &quot;r&quot;)int rows){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;page&quot;, page); map.put(&quot;rows&quot;, rows); return map;} 获取http头信息@RequestHeader添加header信息 @RequestHeader（”key值”） 1234567@GetMapping(value = &quot;/get_header&quot;)public Map getHeader(@RequestHeader(&quot;token&quot;)String accessToken,String id){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;access_token&quot;, accessToken); map.put(&quot;id&quot;, id); return map;} 调用原生HttpServletRequest不推荐使用，程序和Servlet容器会强耦合 123456@GetMapping(value = &quot;/raw_request&quot;)public Map testRequest(HttpServletRequest request) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;, request.getParameter(&quot;id&quot;)); return map;} PostMapping表单Bean提交 方法参数为对象 1234@PostMapping(&quot;/save_user1&quot;)public User saveUser1(User user){ return user;} JSON提交和@RequestBody接收 方法参数Bean添加**@RequestBody** 要通过application/json提交 123456@PostMapping(&quot;/save_user2&quot;)public Map saveUser2(@RequestBody User user){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;user&quot;, user); return map;} PutMapping1234567@PutMapping(&quot;/update/{uid}&quot;)public Map updateUser(@PathVariable(&quot;uid&quot;)String uid){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, &quot;0&quot;); map.put(&quot;message&quot;, uid + &quot;员工数据更新成功&quot;); return map;} DeleteMapping1234567@DeleteMapping(&quot;/delete/{uid}&quot;)public Map deleteUser(@PathVariable(&quot;uid&quot;)String uid){ Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;, &quot;0&quot;); map.put(&quot;message&quot;, uid + &quot;员工数据删除成功&quot;); return map;} XXXMapping的妙用注解中的参数 path：请求路径 consumes：指定请求输入类型 produces：指定请求返回类型 123456789101112@RestController@RequestMapping(path = &quot;/box&quot;,produces = {&quot;application/json&quot;,&quot;text/xml&quot;})//这个控制类基础请求时/box 并且这个类下面全部方法的指定返回类型是JSON或者XMLpublic class BoxController { ... @PostMapping(consumes = &quot;application/json&quot;) //这个方法的请求类型是JSON public Box saveBox(@RequestBody Box box){ ... } ...} 请求成功后返回Stats(状态码) 方法级别**@ResponseStatus(HTTPStatus.状态码类型)** 返回ResponseEntity对象 ```javareturn new ResponseEntity&lt;&gt;(返回对象/NUll,HTTPStatus.状态码类型);1234567891011121314151617181920212223242526例子：```java@RestController@RequestMapping(path = &quot;/box&quot;,produces = &quot;application/json&quot;)public class BoxController { ... @DeleteMapping(&quot;/{id}&quot;) @ResponseStatus(code=HttpStatus.NO_CONTENT) //当请求到/box/{id} 服务器就会返回状态码NO_CONTENT(204) public ResponseEntity deleteBox(@PathVariable Long id){ try { boxRepository.deleteById(id); return new ResponseEntity(HttpStatus.OK); // 当删除数据成功 就返回ResponseEntity对象，并指定状态码OK(200) } catch (EmptyResultDataAccessException e) { return new ResponseEntity&lt;&gt;(null,HttpStatus.NOT_FOUND); // 当抛出没有找到的异常时 就返回ResponseEntity对象，并指定响应体=null，返回状态码404 } } ...} 测试脚本我们一般使用浏览器验证请求是否符合，过于麻烦，我们可以通过IDEA自带的测试脚本来验证. 自动添加测试 点击连接的球 测试文件(位于Scratches and Consoles-&gt;Scratches-&gt;generated-request.http) 各种请求测试普通请求12###测试使用GET http://localhost:8080/v1/hello 表单参数12###GET http://localhost:8080/v1/page1?page=1&amp;rows=5 Header参数123###GET http://localhost:8080/v1/get_header?id=456token:123 Bean对象参数12345###POST http://localhost:8080/v1/save_user1Content-Type: application/x-www-form-urlencodeduid=123&amp;username=456&amp;pwd=789 JSON请求123456789###POST http://localhost:8080/v1/save_user2Content-Type: application/json{ &quot;uid&quot;: &quot;123&quot;, &quot;username&quot;: &quot;456&quot;, &quot;pwd&quot;: &quot;789&quot;} 不重启服务器来更新内容操作在使用debug运行的时候，我们可以使用Reload Changed Classas来重载我们修改过的内容，这样我们不用完全重启整个服务器来更新内容. 快捷键设置 ctrl+alt+s：打开设置 搜索reload，在Keymap中知道对应按键 控制JSON输出在SpringBoot中默认使用Jackson对javaBean进行序列化输出,我们可以通过给POJO类添加相关注解来控制JSON序列化的输出方式: @JsonIgnore忽略该属性，不对该属性进行序列化 @JsonFormat对该属性进行格式化操作，一般用在格式化日期 1@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;) pattern：格式化形式 locale：本地语言 timezone：时区 @JsonInclude给该属性添加条件，例如： 当该属性为空的时候，进行序列化 1@JsonInclude(JsonInclude.Include.NON_NULL) @JsonProperty给该属性添加别名 1@JsonProperty(&quot;别名&quot;) 例子Pojo类 12345678910111213@Datapublic class User { private String uid; private String username; @JsonIgnore private String pwd; @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;) private Date data; @JsonInclude(JsonInclude.Include.NON_NULL) private String phone; @JsonProperty(&quot;myun&quot;) private String un;} Controller层 12345678910 @GetMapping(&quot;/getUser&quot;) public User getUser(){ User user = new User(); user.setData(new Date());// user.setPhone(&quot;114514&quot;); user.setUid(&quot;123&quot;); user.setUn(&quot;456&quot;); user.setUsername(&quot;那是真的牛皮&quot;); return user; } 输出 123456{ &quot;uid&quot;: &quot;123&quot;, &quot;username&quot;: &quot;那是真的牛皮&quot;, &quot;data&quot;: &quot;2022-01-20&quot;, &quot;myun&quot;: &quot;456&quot;} SpringBoot的配置文件类型 .properties文件 .yaml文件 两种文件作用都一样，但是书写不一样. 书写格式(以yaml为例) key： (这里双引号后面必须有个空格)value 用空格来层级递进 12345678910server: port: 8080 servlet: context-path: /apiJackson:spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 name: &quot;测试&quot; 常用配置 tomcat端口设置 12server: port: 8080 tomcat上下文路径(在路径前面添加一个总路径)： 123server: servlet: context-path: /api 应用名设置 123spring: application: name: &quot;测试&quot; Jackson的序列化输出的格式化日期 123spring: jackson: date-format: yyyy-MM-dd HH:mm:ss jackson的时区设置 123spring: jackson: time-zone: GMT+8 SpringBoot日志配置日志什么是日志日志文件：记录系统操作事件的记录文件或文件集合 事件日志 消息日志 Spring’Boot的日志设计Spring Boot提供slf4j这个接口来实现日志功能，一般使用log4j，logback等框架实现. slf4jslf4j（simple logging facade for java）是是一种规范，标准，接口，不是具体实现. logbacklogback和log4j都是slf4j的实现框架，而logback是一个”可靠，通用，快速而又灵活的Java日志框架“. 日志配置Spirng Boot配置文件配置常用配置 pattern：日志格式化 file：写入文件的日志格式 console：输出控制台的日志格式 file：输出日志文件 name：日志具体存放地址 level：输出日志等级 root：根节点等级 具体包名：日志等级 123456789logging: pattern: file: &quot;%d{yyyy/MM/dd?HH:mm} [%thread] %-5level %logger? %msg%n&quot; console: &quot;%d{yyyy/MM/dd?HH:mm:ss} [%thread] %-5level %logger? %msg%n&quot; file: name: C:\\Users\\user\\Desktop\\spd.log level: root: info com.springboot.firstspringboot2: debug 自定义输出日志 在类中方法通过Logger工厂获得Logger对象，并且调用对应对象的方法，来输出日志内容 1234Logger logger = LoggerFactory.getLogger(this.getClass()); logger.debug(&quot;输出内容&quot;);//1.创建Logger对象//2.调用对象中方法输出相关内容 在配置文件中指定包以及对应的日志等级(类似上面) 123logging: level: com.springboot.firstspringboot2: debug logback配置文件配置由于Spring Boot的约定大于配置的设计，可以直接重写logback的配置文件来配置日志，logback配置文件的固定为：logback-spring.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!--定义日志保存的路径--&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/刘裕龙/Desktop/临时文件/logs/&quot; /&gt; &lt;!--定义一个控制台输出器，名为console--&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--按pattern指定的格式输出日志，编码为UTF-8--&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-5level [%thread] %logger{30} - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--定义一个日滚动（每天生成一份）的日志文件--&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!--按pattern指定的格式输出日志，编码为UTF-8--&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-5level [%thread] %logger{30} - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 定义保存的文件名 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--%d{yyyy-MM-dd}代表每天生成一个新的日志--&gt; &lt;fileNamePattern&gt;${LOG_HOME}/sprintboot_%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt; &lt;!--日志最多保存90天，也就是90份--&gt; &lt;maxHistory&gt;90&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 在日滚动文件中，强制只保存错误级别以上信息 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 定义日志全局最低输出级别是INFO，同时向控制台和日滚动文件输出 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;appender-ref ref=&quot;file&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; Freemark模板引擎模板引擎是什么数据+模板–&gt;通过模板引擎–&gt;生成HTML 目的是解耦 类型JSP J2EE标准 太老 强耦合 thymealeaf 速度慢 很难用 很少用 Freemark xxx.ftl FreeMarker Template Language(FTL) 依赖MVC模式，不依赖Servlet容器 容易使用，快速 Freemarker引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yaml cache缓存：关闭 设置字符集：UTF-8 修改模板文件后缀：.ftl 默认为 .ftlh 格式化数字显示：0.## 显示前面整数，后面两位小数 默认为3位为一个单位，各一个添加一个逗号 12345678910spring: freemarker: cache: false charset: UTF-8# 默认为.ftlh suffix: .ftl# 设置freemarker的配置项 settings:# 前面整数，后面两位小数 number_format: 0.## 基本语法三个取值语法 ${变量} ${变量!默认值} ${变量？强制转换类型/函数} 123&lt;p&gt;${user.password}&lt;/p&gt;&lt;p&gt;${user.price!&quot;(数据为空时)测试默认值&quot;}&lt;/p&gt;&lt;p&gt;${user.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/p&gt; 调剂判断 &lt;#if 条件判断 &gt;包围 &lt;#elseif 条件判断&gt; &lt;#else&gt; 调剂判断 括号 变量？？：判断对象为空的方式 1234567&lt;#if ifuser.price?? &gt; &lt;p&gt;用户余额等于1000&lt;/p&gt; &lt;#elseif (ifuser.price&gt;1000)&gt; &lt;p&gt;用户余额:${ifuser.price}&lt;/p&gt; &lt;#else&gt; &lt;p&gt;用户余额不足1000&lt;/p&gt;&lt;/#if&gt; 循环 &lt;ul&gt;或者&lt;ol&gt; &lt;#list 集合变量 as 单个变量&gt;包围 &lt;li&gt; 12345678910&lt;ul&gt; &lt;#list users as u&gt; &lt;li&gt;${u_index + 1}&lt;/li&gt; &lt;li&gt;${u.username}&lt;/li&gt; &lt;li&gt;${u.password}&lt;/li&gt; &lt;li&gt;${u.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/li&gt; &lt;li&gt;${u.price}&lt;/li&gt; &lt;hr&gt; &lt;/#list&gt;&lt;/ul&gt; include子页面实现页首和页尾 &lt;#include “其他ftl页面”&gt; 123456&lt;#include &quot;OtherPage/header.ftl&quot;&gt;&lt;p&gt;${user.username}&lt;/p&gt;&lt;p&gt;${user.password}&lt;/p&gt;&lt;p&gt;${user.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/p&gt;&lt;p&gt;${user.price}&lt;/p&gt;&lt;#include &quot;OtherPage/floot.ftl&quot;&gt; 内置函数(了解即可) 作用 函数名 大小写转换 lower_case/upper_case 首字母大写 cap_first 查找字符串索引 index_of 返回字符串长度 length 四舍五入/下取整/上取整 round/floor/ceiling 得到集合元素总数 size 获取第一个/最后一个元素 first/last 按某个属性对集合排序 sort_by JUnit5单元测试单元测试对软件中最小部分进行检查和验证. JUnit5常用注解测试方法类级别测试 @SpringBootTest(classes=本类.class) @TestInstance Lifecycle.PER_METHOD 本类的方法必须要静态 要关注实例常量的状态 Lifecycle.PER_CLASS 本类的方法不用静态 每次测试都是新的实例 12345@SpringBootTest(classes = TestAll.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)public class TestAll {...} 普通测试进行一次简单的测试 @Test 1234@Testpublic void oneTest(){ System.out.println(&quot;测试一&quot;);} 参数化测试可以一次性多个参数参数测试 固定返回参数 @ParameterizedTest @ValueSource(类型={内容}) 12345@ParameterizedTest@ValueSource(strings = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;})public void testParamForMethodValue(String param){ System.out.println(param);} 方法返回参数 @ParameterizetedTest @MethodSource(“方法民”) 12345678910@ParameterizedTest@MethodSource(&quot;getSource&quot;)public void testParamForMethodValue(String param){ System.out.println(param);}public Stream&lt;String&gt; getSource(){ return Stream.of(&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;);} 重复测试 RepeatedTest(重复次数) 1234@RepeatedTest(10)public void repeatTest(TestInfo testInfo){ System.out.println(&quot;测试&quot;+testInfo.getDisplayName());} 其他测试 @BeforeAll：在所有单元测试之前执行 @AfterAll：在所有单元测试之后执行 @BefroeEach：在每个单元测试之前执行 @AfterEach：在每个单元测试之后执行 @DisplayName(“描述”)：给每个测试单元添加描述 @Timeout：当测试方法运行超过某个时间就报错 123456@Test@Timeout(value = 190, unit = TimeUnit.MILLISECONDS)public void twoTest() throws InterruptedException { Thread.sleep(200); System.out.println(&quot;测试二&quot;);} @Tag:标签 断言上面的普通测试，只能保证程序是正确运行，不能保证结果参数是正确的. 当我们想要验证结果是否符合预期的时候，我就可以使用断言. 一般断言使用在测试类中的测试方法添加断言，一般为Assertions.XXXX 1234567@Test @DisplayName(&quot;断言:值等于&quot;) public void assertEqualsTest(){ String a=&quot;abc&quot;; String b = new String(&quot;abcd&quot;); Assertions.assertEquals(a,b,&quot;a和b值不相等&quot;); } 当a和b相同的时候，不输出后面的”a和b值不相等” 当a和b不相同(条件不符合)的时候，输出后面的”a和b值不相等” 下面常见的断言也一样，当条件不符合（a为不符合的值，b为实际值）的时候，会输出后面的message 1Assertions.XXXX(不符合的值,实际的值,message); 常见断言 断言 作用 assertEquals 两个对象或原始类型是否相等 assertNotEquals 两个对象或原始类型是否不相等 assertSame 两个对象引用是否指向同一个对象 assertNotSame 两个对象应用是否指向不同的对象 assertTrue 给定的值是否为true assertFalse 给的值是否为false assertNull 给的值是否为空 assertNotNull 给的值是否不为空 MockMVC构建Web测试什么是Mock在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。 为什么使用MockMVC MockMvc是由spring-test包提供 实现了对Http请求的模拟，能够直接使用网络的形式转换到Controller的调用，使得测试速度快、不依赖网络环境。 同时提供了一套验证的工具，结果的验证十分方便 操作MockMVC创建MockMVC测试类 添加注解类级别 SpringBootTest classes：主方法类 webEnvironment： SpringBootTest.WebEnvironment.RANDOM_PORT：设置每次测试随机端口 AutoConfigureMockMVC 方法级别 方法添加@Test 注入MockMVC属性12345678910@SpringBootTest(classes = {LaoQiSpringBoot2Application.class},webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)@AutoConfigureMockMvcpublic class MockMvcTest { @Resource private MockMvc mockMvc; ....} MockMVC测试 设置请求和参数 perform 期望条件和todo组合 andExpect andDo 提交请求 andReturn 设置请求和参数perform 模拟访问url，可以选择get或者post方法 添加各种参数 123mockMvc.perform( MockMvcRequestBuilders.get(&quot;要访问的URL&quot;)) 不添加参数1MockMvcRequestBuilders.get(&quot;要访问的地址&quot;) 例子 12345@Testpublic void testMock1() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/v1/getLog&quot;)) .andReturn();} 表单参数 param(“key”，value) 12MockMvcRequestBuilders.get(&quot;要访问的地址&quot;) .param(&quot;key&quot;, value) 例子 12345678@Testpublic void testMock1() throws Exception { mockMvc.perform( MockMvcRequestBuilders.get(&quot;/v1/getLog&quot;) .param(&quot;id&quot;,123) ) .andReturn();} header参数 header(“key”,value) 12MockMvcRequestBuilders.get(&quot;要访问的地址&quot;) .header(&quot;key&quot;, value) 例子 12345678@Test@DisplayName(&quot;JSON响应测试应用&quot;)public void testMock2() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/v1/get_header&quot;) .header(&quot;token&quot;, &quot;abcd&quot;) ) .andReturn();} json参数 content(json的字符串) contentType(MediaType.APPLICATION_JSON_VALUE) 1234MockMvcRequestBuilders.post(&quot;/v1/save_user2&quot;) .accept(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(s1) .contentType(MediaType.APPLICATION_JSON_VALUE) HashMap转json字符串 HashMap对象 ObjectMapper对象 writeValueAsString方法 1234HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();ObjectMapper mapper = new ObjectMapper();map.put(&quot;myun&quot;, &quot;123456&quot;);String = mapper.writeValueAsString(map); 例子 1234567891011121314151617@Testpublic void testMock4() throws Exception { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); ObjectMapper mapper = new ObjectMapper(); map.put(&quot;uid&quot;, &quot;123&quot;); map.put(&quot;username&quot;, &quot;用户名字&quot;); String s1 = mapper.writeValueAsString(map); mockMvc.perform(MockMvcRequestBuilders.post(&quot;/v1/save_user2&quot;) .accept(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(s1) .contentType(MediaType.APPLICATION_JSON_VALUE) ) .andReturn();} 解决响应的乱码 上面的各种参数上传时候，都会默认UTF-8编码 响应数据必须要使用accept来设置UTF-8编码 12.accept(MediaType.APPLICATION_JSON_UTF8_VALUE) //虽然APPLICATION_JSON_UTF8_VALUE弃用，但其实依然是会生效的 期望条件andExpect当我们设置请求后，我们希望响应满足我们一些条件，就可以用这个玩意. 1.andExpect(MockMvcResultMatchers.XXXXX) 判断符合请求 判断请求成功，也就是状态码是不是200 当状态码不符合的时候，就会抛出测试错误 1.andExpect(MockMvcResultMatchers.status().isOk()) 例子 123456789@Test@DisplayName(&quot;JSON响应测试应用&quot;)public void testMock2() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/v1/get_header&quot;) .header(&quot;token&quot;, &quot;abcd&quot;) .param(&quot;id&quot;, &quot;123&quot;) ).andExpect(MockMvcResultMatchers.status().isOk()) .andReturn();} 判断json是否符合 判断json的值是否符合 1.andExpect(MockMvcResultMatchers.jsonPath(&quot;key值&quot;).value(&quot;value值&quot;)) 例子 12345678910@Test@DisplayName(&quot;JSON响应测试应用&quot;)public void testMock2() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/v1/get_header&quot;) .header(&quot;token&quot;, &quot;abcd&quot;) .param(&quot;id&quot;, &quot;123&quot;) ) .andExpect(MockMvcResultMatchers.jsonPath(&quot;access_token&quot;).value(&quot;abcd&quot;)) .andReturn();} 匹配操作andDo一般来说，当我们符合期望条件后，可以再做下一步的测试，当然也可以单独使用.. 1.andDo(MockMvcResultHandlers.XXXX) 输出内容 单纯输出各种内容 1.andDo(MockMvcResultHandlers.print()) 例子 1234567891011@Test @DisplayName(&quot;JSON响应测试应用&quot;) public void testMock2() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/v1/get_header&quot;) .header(&quot;token&quot;, &quot;abcd&quot;) .param(&quot;id&quot;, &quot;123&quot;) ).andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;access_token&quot;).value(&quot;abcd&quot;)) .andReturn(); } 提交请求(必须)andReturn 在上面的流式编程完成后,最后必须以.andReturn作为结尾 .andReturn才是真正发出请求的时候 标准化404和500异常为什么标准化404和500在前后端分离应用的情况下，前端发送http请求个springboot里面的tomcat容器，tomcat容器再发送json数据给前端. 前端必须全部都接收json，但是404和500都会显示默认错误页面，而不是返回json.所以我们需要把404和500的异常都变成标准的json返回. 布置全局异常拦截开发全局异常处理通知对404异常进行配置在apllication.yaml中设置404抛出NoHandlerFoundException，并且关闭默认资源映射.这样当访问404时候，不再显示默认的404错误页面，而是返回json数据. spring.mvc.throw-exception-if-no-handler-found: true spring.mvc.resources.add-mappings: false 12345678spring:# 出现404错误 直接抛出NoHandlerFoundException mvc: throw-exception-if-no-handler-found: true# 关闭默认资源映射，会导致static静态资源无法映射 web: resources: add-mappings: false 创建异常处理类Srping Boot提供内置的AOP通知实现404或者500异常的全局处理 在类上添加**@RestControllerAdvice**（环绕通知） 在方法中添加**@ExceptionHandler**（要处理的异常类.class） 一般返回Exception.class（也就是所有异常类的父类） 使用Exception参数 返回Object（返回json） 12345678910111213141516171819@RestControllerAdvicepublic class ControllerHandlerException { private Logger logger = LoggerFactory.getLogger(this.getClass()); @ExceptionHandler(Exception.class) Object handleException(Exception e, HttpServletRequest request) { Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); if (e instanceof NoHandlerFoundException) { map.put(&quot;code&quot;, 404); } else { map.put(&quot;code&quot;, 500); } map.put(&quot;exception&quot;, e.getClass().getSimpleName()); map.put(&quot;msg&quot;, e.getMessage()); logger.error(&quot;捕捉Web应用抛出错误&quot;, e); return map; }} 拦截器Interceptor在平时我们需要对用户的请求进行拦截并作出相应处理. 一般用来权限验证，记录请求信息，判断用户是否登录等 创建拦截器类 创建拦截器类 继承HandlerInterceptor 重写preHandler和postHandler方法 在用户请求之前或之后，进行拦截 返回false，则拦截 返回ture，则放行 拦截方法 前置拦截preHandle 验证token 权限验证 后置拦截postHandle 例子 123456789101112131415161718192021222324252627282930public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getHeader(&quot;token&quot;); if(token!=null){ System.out.println(&quot;token&quot;); return true; }// 输出json LinkedHashMap&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;code&quot;, &quot;500&quot;); map.put(&quot;msg&quot;, &quot;验证token失败&quot;);// jackson序列化 ObjectMapper mapper = new ObjectMapper(); String s = mapper.writeValueAsString(mapper); response.setContentType(&quot;application/json&quot;); response.getWriter().println(s); return false; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); }} 拦截器类映射 创建配置类，添加**@Configuration** 继承WebMvcConfigurer 重写addInterceptors添加拦截器映射 addInterceptors方法 addInterceptor（拦截器类对象） addPathPatterns（”拦截地址”） excludePathPatterns（”排除拦截地址”） 路径设置 拦截所有链接：/** 拦截多个地址：String数组 拦截单个地址：String 例子 123456789101112@Configurationpublic class MyInterceptorConfigure implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(new String[]{&quot;/static/**&quot;, &quot;/img/**&quot;}); } }} 资源映射使用WebMvcConfiguration方法，对静态资源进行放行 继承WebMvcConfigurer类 重写addResourceHandlers方法 addResourceHandler(“请求路径”) addResourceLocations(“映射路径”) 设置映射 123456789@Configurationpublic class MyInterceptorConfigure implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); }} Actuator和Endpoint什么使用Actuator在一个微服务在云上部署之后，我们要对其进行监控，追踪，审计，控制等. 文档地址： https://docs.spring.io/spring-boot/docs/2.4.6/reference/html/production-ready-features.html#production-ready 如何使用Actuator添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 暴露接口开启所有监控管理actuator下面所有端点开启 123456management: endpoints: enabled-by-default: true #开启所有监控 web: exposure: include: '*' 启用端点因为安全问题，所以不会开启所有端点. 会选择用一个功能开启一个端点，enabled：true 注意查询文档，看该端点是WEB支持还是JMX支持 1234567891011121314management: endpoints: enabled-by-default: false #开启所有监控 web: exposure: include: '*' endpoint: #对外暴露端点 health: show-details: always #显示健康状态的信息 enabled: true info: enabled: true metrics: enabled: true 常用端点 health info metrics 访问路径 访问总路径：http://localhost:8080/actuator 以超链接的方式返回下级可访问连接 访问端点路径：http://localhost:8080/actuator/XXXX 例：访问health端点：http://localhost:8080/actuator/health 常用端点列表 端点 描述 auditevents 暴露当前应用程序的审核信息.需要一个AuditEventRepository组件 beans 显示应用程序中所有Spring bean的完整列表。 conditions 显示自己配置的所以条件信息，包括匹配或者不匹配的原因 caches 暴露可用的缓存。 configprops 显示所有@ConfigurationProperties env 露出Spring的属性ConfigurableEnvironment flyway 显示已应用的所有Flyway数据库迁移，需要一个或对各Flyway组件 health 显示应用程序运行状态信息 httptrace 显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）.需要一个HttpTraceRepository组件 info 显示应用程序信息 integrationgraph 显示Spring intergrationraph，需要依赖spring-integration-core loggers 显示和修改应用程序中日志的配置 liquibase 显示已应用的所有Liquibase数据库迁移.需要一个或多个Liquibase组件 metrics 显示当前应用程序的”指标“信息 mappings 显示所有@RequestMapping路径列表 scheduledtasks 显示应用程序中的计划任务 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话，需要使用Spring Session的基于Servlet的Web应用程序 shutdown 显示由ApplicationStartup收集的启动步骤数据.需要使用SpringApplication进行配置BufferingApplicationStartup threaddump 执行线程转储。 Spring-Boot-AdminSpring-Boot-Admin作用管理和监视Spring Boot应用程序.提供： 详细的健康(Health)信息 内存信息 JVM系统和环境属性 垃圾回收信息 日志设置和查看 定时任务查看 Spring Boot缓存查看和管理 等 功能. 文档:https://codecentric.github.io/spring-boot-admin/2.3.1/ Spring-Boot-Admin配置Spring-Boot-Admin采用C/S的模式，有一个Admin服务器用来监控一个或多个Admin client的Spring boot项目，且项目中添加了actuator框架. Admin服务器添加依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 修改端口防止和客户端冲突 1server.port=9000 主启动类添加@EnableAdminServer123456789@SpringBootApplication@EnableAdminServerpublic class AdminServerApplication { public static void main(String[] args) { SpringApplication.run(AdminServerApplication.class, args); }} Admin客户端添加依赖12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; 指向Admin服务器 spring.boot.admin.client.url：指向Admin服务器地址 spring.boot.admin.client.instance.prefer-ip：开启基于IP进行注册，默认为域名注册 1234567spring: boot: admin: client: url: http://127.0.0.1:9000 #服务器地址 instance: prefer-ip: true #基于IP进行注册 操作SpringBootAdmin页面 访问 http://localhost:9000 异常监控 OFFLINE：服务挂掉 UP：正常运行 配置查看更多监控项确保配置actuator添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 开放所有端点在application.yaml里配置， 123456management: endpoints: enabled-by-default: true #开启所有监控 web: exposure: include: '*' 更多监控项在actuator开启全部端点后，可以看到以下内容： 启动时间、累计运行时间； 进程和线程数量和占用的 CPU 资源； 垃圾回收详情信息，回收次数和花费时间； JVM 线程转储、内存转储详情和对应的文件下载； 可以查看和配置 Spring Boot 项目中的日志级别； 查看 Spring Boot 项目性能监控； 查看 Spring Boot 运行环境信息； 查看 Spring Boot 所有类信息； 查看 Spring Boot 中的定时任务； 查看和管理 Spring Boot 项目中的所有缓存。 查看运行环境 查看定时任务 项目日志级别配置可以很可观的看到日志级别，并且很容易设置 JVM线程和内存查看 查看缓存 配置项目实时日志 在客户端设置logback日志地址 ```yamllogging: file:name: 日志地址12345678910111213141516171819202122232425262728293031323334353637- 查看Admin日志![屏幕截图 2022-01-27 094411](/image/屏幕截图_2022-01-27_094411.png)# Spring-Boot-Profile## 为什么使用Profile- Profile是Spring对**不同环境提供不同配置**功能的支持(方便多环境适配)- 可以通过多种方式激活 - 默认application.yml激活 - 生产环境激活 - 命令行参数激活- 通过Profile，**在不同环境创建不同的bean**## 配置属性我们不希望把对象中参数直接写死在程序中，我们希望可以通过配置application.yml中的属性来控制对象的参数.所以有了配置属性.### 引入其他配置属性从其他的配置属性注入到其他配置##### ${}占位符```yamla: b: you ${b.c} 创建自己的配置属性创建配置属性@ConfigurationProperties 首先在需要配置属性的类中添加 12345678@Data@Component@ConfigurationProperties(prefix = &quot;mybean&quot;)public class InsertBean { private String a; private String b;} 在application.yml配置属性 123mybean: a: &quot;测试&quot; b: &quot;测试&quot; 给配置属性添加文档 将光标放到.yaml文件中的配置属性 新生成文件 新生成json，修改注释 123456789101112{ &quot;properties&quot;: [ { //配置属性的全名 &quot;name&quot;: &quot;mybean.b&quot;, //配置属性的参数类全名 &quot;type&quot;: &quot;java.lang.String&quot;, //这个配置属性的简短描述 &quot;description&quot;: &quot;我是b.&quot; } ]} 显示效果 用Profile进行配置不同的配置profile配置文件 默认配置文件application.yml任何时候都会加载 不同开发环境配置 命名规则：application-{profile名}.yml 例子 application-dev.yml 代表dev环境 application-prod.yml 代表prod环境 application-test.yml 代表test环境 激活优先级别环境配置文件&gt;默认配置文件 激活profile默认激活 在application.yml spring: profiles: active: 环境名(例如&quot;dev&quot;) #代表默认激活dev这个环境的配置属性 123456##### 激活- **命令行参数启动** % java -jar 包名.jar --spring.profiles.active=dev 1234567891011121314151617181920212223242526272829303132## 使用profile条件化创建bean不同环境不用配置参数，同时我们希望IOC容器中加载不同的bean，我们在以java方式配置类添加@Profile注解，来控制加载.##### @Profile注解使用- @Profile(&quot;环境名&quot;)- @Profile({&quot;环境名1&quot;,&quot;环境名2,&quot;.....})- **!符号代表不激活** - @Profile({&quot;！环境名1&quot;,&quot;！环境名2,&quot;.....}) - **当环境1和环境2不激活的时候，这个bean才被创建**##### 在java方式配置类的- @Bean方法级别 ```java @Bean @Profile(&quot;环境名&quot;) public void a(){ ... } @Configuration类级别 12345@Configuration@Profile(&quot;环境名&quot;)public class b{...} 外部化配置为什么用外部化配置当我们在线上环境的时候，我们已经将程序打包成.jar文件，当我们需要修改一下配置文件的时候，需要修改完后重新打包.这样很麻烦，所以我们引入外部化配置来简化这个修改. 外部化配置方式 properties文件 yaml文件 环境变量 命令行参数 外部化配置操作加载优先顺序 命令行参数 ```java -jar jar包.jar –spring.profiles.active={profile}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556572. 在jar包之外(和jar包同级文件)的 application-{profile}.properties或yaml3. 在jar包中的 application-{profile}.properties或yaml4. 在jar包之外(和jar包同级文件)的 application.properties或yaml5. 在jar包中的 application.properties或yaml##### 例子- jar包之外的application-dev.yaml- 用压缩包打开jar包，可以看到jar包中的application-dev.yaml![屏幕截图 2022-01-28 180324](/image/屏幕截图_2022-01-28_180324-16433642299091.png)# SpirngBoot整合Mybatis## 引入依赖- mysql依赖- mybatis依赖- web依赖- test依赖- lombok小插件```xml&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 设置apllicationContext和添加配置文件配置applicationContext.yaml 配置数据库连接 username password driver-class-name url 指定mapper映射文件路径：mapper-locations 指定mybatis配置文件路径：config-location 123456789spring: datasource: username: 用户名 password: 用户密码 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghaimybatis: mapper-locations: classpath:/mapper/*.xml config-location: classpath:/mybatis-config.xml 添加配置文件在Resource文件中添加： mapper文件夹 mybatis-config.xml文件 配置 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; XML开发添加Entity对象 私有变量 getset 有/无构造方法 例子 123456789101112@Data@NoArgsConstructor@AllArgsConstructorpublic class Employee { private Integer empno; private String ename; private String job; private Date hiredate; private Float sal; private Integer deptno;} 添加对应Mapper接口创建对应接口 例子 1234567891011public interface EmployeeMapper { public List&lt;Employee&gt; selectAll(); public int insert(Employee employee); public int update(Employee employee); public int delete(Integer empno);} 添加对应mapper.xml文件 namespace：指向Mapper接口类 增删改查 id：指向接口类中的方法名 resultType：返回结果类 parameterType：输入参数类 sql输入参数位 #{属性名}：预编译(防sql注入) ${属性名}：字符串拼接(最好别用) 参数传入 单个参数：默认加入即可 多个参数：使用Map和@Param(“别名”) 12345678910111213141516171819/** * 自定义SQL分页查询 * * @param page 第一个对象固定为分页对象 * @param param 第二个参数Map向SQL传递多参数，但需要使用@Param(&quot;sql中的前置名&quot;)定义前置 * @return 返回分页结果 */public IPage&lt;Map&gt; selectMap(IPage page, @Param(&quot;p&quot;) Map param);//xml文件中的sql /*&lt;select id=&quot;selectMap&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.LinkedHashMap&quot;&gt; select d.*,g.title from t_goods_detail d,t_goods g where d.goods_id = g.goods_id and d.gd_order= #{p.order} and d.goods_id=#{p.goodsId} &lt;/select&gt;*/ 例子 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.myspringbootmybatis.mapper.EmployeeMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;com.example.myspringbootmybatis.Entity.Employee&quot;&gt; select * from emp &lt;/select&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.example.myspringbootmybatis.Entity.Employee&quot;&gt; INSERT INTO `scott`.`emp`(`empno`, `ename`, `job`, `hiredate`, `sal`, `deptno`) VALUES (#{empno}, #{ename}, #{job}, #{hiredate}, #{sal}, #{deptno}) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.example.myspringbootmybatis.Entity.Employee&quot;&gt; UPDATE `scott`.`emp` SET `ename` = #{ename}, `job` = #{job}, `hiredate` = #{hiredate}, `sal` = #{sal}, `deptno` = #{deptno} WHERE `empno` = #{empno}; &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;com.example.myspringbootmybatis.Entity.Employee&quot;&gt; delete from emp where empno=#{value} &lt;/delete&gt;&lt;/mapper&gt; 单元测试 通过**@Resource**从IOC容器中获得 例子 12345678910111213@SpringBootTestpublic class EmployeeMapperTestor { @Resource private EmployeeMapper employeeMapper; @Test public void testSelect() { List&lt;Employee&gt; employees = employeeMapper.selectAll(); employees.stream().forEach(System.out::println); System.out.println(); }} 全注解开发创建对应的Mapper接口类 给类添加**@Mapper** 给方法添加对应增删改查注解 @Select(sql语句) @Insert(sql语句) @Delete(sql语句) @Update(sql语句) sql语句添加参数：**#{属性名}** 利用@Resource从IOC容器拉取 例子 123456789@Mapperpublic interface DepartmentMapper { @Select(&quot;select * from dept order by dname&quot;) public List&lt;Department&gt; selectAll(); @Insert(&quot;INSERT INTO `scott`.`dept`(`deptno`, `dname`, `loc`) VALUES (#{deptno}, #{dname}, #{loc})&quot;) public Integer insert(Department department); } 声明型事务管理为什么要事务管理当我们批量增删改提交到数据库的时候，其中某条数据发送异常错误，但是在这一批中，前面的已经提交了，后面的因为前面那个异常就不提交了，这样很不好，我们希望要不全提交，要不全不提交.那么就可以使用事务管理. 操作事务事务原理使用Spring声明式事务，当我们提交事务时候： 发送异常(默认RuntimeException异常及其子类异常，或者配置的指定异常类)，回滚事务 不发生异常(或者配置的指定异常类)，提交事务 @Transactional使用级别@Transactional可以在类或者方法是使用 类级别：下面的方法都事务管理 方法级别：只用本方法事务管理 类级别的注解重载方法级别的注解 注解属性(不完全) 属性项 含义 备注 propagation 传播行为 传播行为是方法直接调用的问题.默认值为Propagation.REQUIRED timeout 超时时间 单位为s，超时就事务回滚 readOnly 是否开启只读 默认false rollbackFor 回滚事务的异常类指定(最好指定Exception.class) 只用当方法产生这里指定的异常时，才会回滚事务. rollbackForClassName 回滚事务的异常类名指定 同上，但是用异常类的名指定 noRollbackFor 当产生哪些异常不回滚事务 同上，但是相反 noRollbackForClassName 同上 同上，但是用异常类的名指定 总结 大型项目多人写作采用XML配置有更好维护性 小型敏捷开发项目用注解拥有更好的开发体验 注解开发适用在继承表/字典等明确不需要复杂SQL的场景 当出现多条件动态查询时，建议使用XML形式配置. SpirngBoot整合Mybatis-plus引入Mybaits-plus添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 添加扫描接口 在主启动类添加**@MapperScan(“接口路径”)** 例： 123456789@SpringBootApplication@MapperScan(&quot;com.example.myspringbootmybatis.mapper&quot;)public class MySpringBootMybatisApplication { public static void main(String[] args) { SpringApplication.run(MySpringBootMybatisApplication.class, args); }} 给Entity添加注解要个Entity类找到对应的数据库和字段，添加以下注解: @TableName(“对应表名”) @TableId @TableField(“数据库字段”) 例子 123456789101112@Data@TableName(&quot;salgrade&quot;)public class Mysalrade { @TableId @TableField(&quot;grade&quot;) private Integer grade; @TableField(&quot;losal&quot;) private Integer lostSal; @TableField(&quot;hisal&quot;) private Integer highSal;} 创建Mapper接口创建对应接口类，并且**继承BaseMapper&lt;对应Entity类&gt;**，里面默认写了简单的增删查改方法，可以方便我们使用.并且加载到IOC容器中 例子 123public interface MysalradeMapper extends BaseMapper&lt;Mysalrade&gt; { public IPage&lt;Mysalrade&gt; selectAllofPage(IPage&lt;Mysalrade&gt; iPage);} 添加对应XML文件(可选)当我们的需求已经没有办法满足BaseMapper提供的方法的时候，我们可以像之前的mybatis一样，使用对应xml文件来写sql. 简单操作增删改查语句内置基本的增删改查的基本sql方法，以一下开头： selectXXX deleteXXX insert updateXXX 简单测试例子 1234567891011121314@SpringBootTestclass salgradeMapperTest { @Resource private MysalradeMapper salgradeMapper; @Test public void testOnlySelect(){ Mysalrade mysalrade = salgradeMapper.selectById(1); System.out.println(mysalrade.toString()); } } 查询构造器查询构造器相当于我们在原来BaseMapper提供的基本语句中，通过java代码的方式，再添加其他条件sql语句. 简单使用 创建QueryWrapper类 调用里面的对应sql方法 作为参数添加到原本查/删/改/插的语句 例子 123456789101112131415161718@SpringBootTestclass salgradeMapperTest { @Resource private MysalradeMapper salgradeMapper; @Test public void testQueryWrapper(){ QueryWrapper&lt;Mysalrade&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.ge(&quot;hisal&quot;,1000); wrapper.le(&quot;hisal&quot;,5000); //原来: SELECT grade,losal AS lostSal,hisal AS highSal FROM salgrade //添加查询构造器后： //SELECT grade,losal AS lostSal,hisal AS highSal FROM salgrade WHERE (hisal &gt;= 1000 AND hisal &lt;= 1500) List&lt;Mysalrade&gt; mysalrades = salgradeMapper.selectList(wrapper); mysalrades.stream().forEach(System.out::println); }} 常用查询构造器文档：https://baomidou.com/pages/10c804/#abstractwrapper 方法名 作用 备注 allEq 全部字段都等于 默认可以空，添加false关闭 eq = ne &lt;&gt; gt &gt; ge &gt;= lt &lt; le &lt;= between between and notBetween not between and like like ‘%值%’ notLike not like ‘%值%’ likeLeft like ‘%值’ likeRight like ‘值%’ isNull is null isNotNull is not null in in( ..) notIn not in( ..) isSql in(sql语句) notInSql not in(sql语句) groupBy Group By 字段 orderByAsc ORDER BY 字段, … ASC orderByDesc ORDER BY 字段, … DESC orderBy ORDER BY 字段 having HAVING ( sql语句 ) or or 不调用or(),其他默认为and and and exists EXISTS ( sql语句 ) 分页插件一般分页（mysql为例）以往的分页步骤，如下： 执行分页语句,获取当前页数据 1select * from tab limit 0,10 获取在不分页情况下的数据总数,用来计算总页数 1select count(*) from tab 以往这个过程费时费力,但在引入MyBatis-plus分页插件后就成为过去 配置分页插件 在主启动类添加自定义bean MybatisPlusInterceptor拦截器用于拦截MyBatis中SQL的执 行,自动生成 select count(*) 语句 1234567@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); //给拦截器添加 PaginationInner拦截器 并且指定Mysql数据库的分页方式 mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return mybatisPlusInterceptor;} 操作分页插件继承BaseMapper 创建Page&lt;Entity类&gt;对象(第几页数，每页总数) 作为参数添加到方法中 返回IPage对象 方法名 作用 getPages() 总页数 getSIze() 每页大小 getTotal() 查询条数 getRecords() 具体数据 getCurrent() 当前页数 分页例子 12345678910111213141516171819@SpringBootTestclass salgradeMapperTest { @Resource private MysalradeMapper salgradeMapper; @Test public void TestPage(){ IPage&lt;Mysalrade&gt; iPage = new Page(1, 3); QueryWrapper&lt;Mysalrade&gt; queryWrapper = new QueryWrapper&lt;&gt;(); iPage= salgradeMapper.selectPage(iPage, queryWrapper); iPage.getRecords().stream().forEach(System.out::println); }} 自定义分页当基本的sql语句满足不了我们，需要更加复杂的sql语句时候，并且需要分页时候，可以使用XML方式. 在Mapper接口添加对应方法 IPage&lt;Entity类&gt;对象作为参数添加 返回IPage&lt;Entity类&gt;对象 创建对应xml文件 操作并填入IPage对象 不用额外填写parameterType resultType返回Entity类即可 例子 MysalradeMapper类 1234public interface MysalradeMapper extends BaseMapper&lt;Mysalrade&gt; { public IPage&lt;Mysalrade&gt; selectAllofPage(IPage&lt;Mysalrade&gt; iPage);} 对应xml文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.myspringbootmybatis.mapper.MysalradeMapper&quot;&gt; &lt;select id=&quot;selectAllofPage&quot; resultType=&quot;com.example.myspringbootmybatis.Entity.Mysalrade&quot; &gt; select grade,losal as lostSal,hisal as highSal from salgrade &lt;/select&gt;&lt;/mapper&gt; 调用 123456@Test public void testMyXMLPage(){ IPage&lt;Mysalrade&gt; page = new Page&lt;&gt;(1,3); page= salgradeMapper.selectAllofPage(page); page.getRecords().stream().forEach(System.out::println); } 解决字段对应问题 直接在XML文件上修改sql，添加别称 添加mybatis配置驼峰命名法设置（例如:first_name -&gt; firstName） 1&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; Druid连接池为什么要连接池连接池是一种以时间换时间的技术，用程序加载时间的增加来换取执行时间的下降. 每次程序连接数据库都会执行底层TCP/IP协议，会消耗多的资源，当我们预先加载一些连接，等程序连接时候直接使用，这样可以提供执行效率.并且增加了拓展性. 为什么选择Druid常见的连接池技术： dpcp dpcp2 tomcat hikari Druid 当使用tomcat的时候，默认使用tomcat连接池. 如果脱离web，那就是hikari，但是这个没有监控. Druid优点: java语言中最好的数据库连接池 强大的监控和拓展功能 配置Druid连接池和监控基本配置引入依赖123456789&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; druid-spring-boot-starter是阿里巴巴官方提供的Druid Starter spring-boot-starter-aop依赖AOP来开启Druid String监控 配置Druid连接池和监控项在application.yaml中添加如下: 1234567891011121314151617181920212223242526272829303132333435spring: datasource: druid:# 初始创建连接数 initial-size: 20# 最大连接数(一般取最高并发量的1.2-1.3倍) max-active: 20# 开启URI监控和Session监控 web-stat-filter: enabled: true# 启动访问后台 stat-view-servlet: enabled: true# 后台用户名和密码 login-username: root login-password: root# 颗粒度更细的过滤器 filter:# 开启SQL监控 stat: enabled: true# 启动sql合并 merge-sql: true# 启动慢sql信息收集 log-slow-sql: true# 超过1秒记录为慢sql slow-sql-millis: 1000# 启动sql防火墙 wall: enabled: true## 启动日志输出 slf4j: enabled: true# 开启Spring监控 aop-patterns: com.example.myspringbootmybatis.Controller.* 启动Spring Boot启动服务后，访问地址:http://localhost:8081/druid SQL监控：从数据库层面监控 SQL防火墙:控制黑白名单sql，防止sql注入 Web应用：从Web层面获得大概数据 URI监控:基于地址层面监控 Session监控：基于tomcat的会话层面监控 Spring监控：从方法层面监控IoC容器内的方法访问情况 其他可用配置选项1234567891011121314151617181920212223242526272829#数据库类型为mysql spring.datasource.dbType=mysql #启动时初始化5个连接 spring.datasource.initialSize=20 #最小空闲连接5个spring.datasource.minIdle=5#最大连接数量20 spring.datasource.maxActive=20 #获取连接等待时间60秒，超出报错spring.datasource.maxWait=60000 #每60秒执行一次连接回收器 spring.datasource.timeBetweenEvictionRunsMillis=60000 #5分钟内没有任何操作的空闲连接会被回收 spring.datasource.minEvictableIdleTimeMillis=300000 #验证连接有效性的SQL spring.datasource.validationQuery=select 'x' #空闲时校验，建议开启 spring.datasource.testWhileIdle=true #使用中是否校验有效性，推荐关闭 spring.datasource.testOnBorrow=false #归还连接时校验有效性，推荐关闭 spring.datasource.testOnReturn=false spring.datasource.poolPreparedStatements=false #设置过滤器，stat用于接收状态，wall用于防止SQL注入,slf4j则说明使用logback日志输出 spring.datasource.filters=stat,wall,slf4j #统计所有数据源状态 spring.datasource.useGlobalDataSourceStat=true #sql合并统计，与设置慢SQL时间为500毫秒 spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slow SqlMillis=500 封装自定义的start包start包是什么我们在springBoot平时引用依赖的时候，会遇到不同的spring-boot-start包，他们有两种类型： spring-boot-start-XXX：一般为收录到官方的包 XXX-spring-boot-start：一般为第三方的包 封装start包开发业务逻辑接口与实现类 开发接口 实现类 以下例子： 接口Digest 123public interface Digest { public String digest(String s);} 实现类Md5Digest 1234567public class Md5Digest implements Digest { @Override public String digest(String s) { System.out.println(&quot;使用MD5算法生成摘要&quot;); return DigestUtils.md5Hex(s); }} 实现类ShaDigest 1234567public class ShaDigest implements Digest { @Override public String digest(String s) { System.out.println(&quot;使用Sha256算法生成摘要&quot;); return DigestUtils.sha256Hex(s); }} 开发加载配置用的Setting类 @Component ConfigurationProperties(prefix=”前缀”) 例子 1234567891011121314//加载配置信息@Component@ConfigurationProperties(prefix = &quot;digest&quot;)public class Setting { private String type; public String getType() { return type; } public void setType(String type) { this.type = type; }} 配置在application.properties 1digest.type=md5 配置类Config配置注解 @Configuration定义配置类 @EnableConfigurationProperties(Setting.class) 加载设置选项 @Bean 创建对象 方法名为beanId 返回值为class @ConditionalOnProperty 条件化加载，相当于if判断，满足条件就会执行方法创建对象 prefix：前缀 name：属性名 havingValue：满足的值 说明： 以第一个方法为例子，当在application.yaml中出现digest.type的前缀，并且填写的值为md5，就会执行这个方法，创建Md5Digest对象，加载到IoC容器中. 例子 1234567891011121314151617181920@Configuration//激活配置属性@EnableConfigurationProperties(Setting.class)public class Config { @Bean @ConditionalOnProperty(prefix = &quot;digest&quot;,name = &quot;type&quot;,havingValue = &quot;md5&quot;) public Digest md5Digest(){ System.out.println(&quot;Loading Md5Digest object&quot;); return new Md5Digest(); } @Bean @ConditionalOnProperty(prefix = &quot;digest&quot;,name = &quot;type&quot;,havingValue = &quot;sha&quot;) public Digest shaDigest(){ System.out.println(&quot;Loading ShaDigest object&quot;); return new ShaDigest(); }} 其他条件化加载的注解 @ConditionalOnBean：当容器里有指定Bean的条件下 @ConditionalOnClass：当类路径下有指定类的条件下 @ConditionalOnProperty：指定的属性是否有指定的值 新建/resources/META-INF/spring.factories1org.springframework.boot.autoconfigure.EnableAutoConfiguration=配置类路径 在其他工程引用该starter的时候，会自动创建对应的类并实例化对象(EnableAutoConfiguration)，这样在目标工程的IoC容器中就会出现对应对象. 例子 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.liuyulong.digest.conf.Config 屏蔽掉pom.xml的spring-boot-maven-plugin插件 Spring Boot默认创建FatJar 通过屏蔽打包插件来打印标准Jar包 通过maven的install将该Starter在本地安装使用start包想其他依赖引用的方式是用，在pom.xml填写(例子)： 12345&lt;dependency&gt; &lt;groupId&gt;com.liuyulong&lt;/groupId&gt; &lt;artifactId&gt;digest-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;","link":"/Liust1918.githud.io/2022/12/03/%E9%87%8D%E5%AD%A6SpirngBoot2-X/"},{"title":"Spring实战(第5版)","text":"Spring实战(第5版)书(弃用) Spring基础Spring起步Spring框架可以‘支持的: 传统应用:基于浏览器的Web应用,后端由关系型数据库作为支撑 SpringBoot:简化开发模型 微服务：开发面向云的由微服务组成的应用 反应式编程:致力于通过非阻塞操作提供更好的拓展性并提升性能. 什么是SpringSpring核心容器(container)/Spring应用上下文(Spring application context):创建和管理应用组件 组件(bean):在Spring上下文中相互装配 组件的装配方式:依赖注入(denpendency injection,DI):将组件注入到需要它们的bean中. 实现方式: 构造方法 setter方法 指导Spring应用上下文将bean装配的方式(显式配置): XML文件(过时) 基于java的配置文件 @Configuration:设置配置类(容器) @Bean:设置该方法为组件 方法名:相当于id 返回类型:相当于class 优点: 比XML配置更好的重构能力和更强的类型安全性 Tips:只有当Spring不能用自动配置的时候采用显式配置 自动配置自动扫描类路径来装配bean Spring:自动装配(autowiring)和组件扫描(component scanning) Spring Boot:自动配置(autoconfiguration) Spring Boot是Spring框架的拓展,提高生成效率的方法,大幅减少显式配置的数量. Spring项目结构 mvnw和mvnw.cmd:Maven包装类(wrapper)脚本,没有Maven也可构建项目. pom.xml:Maven构建规范 XXXXApplication.java:Spring Boot主类,用来启动项目. application.properties:指定配置文件 static：存放静态内容(图片,样式表,JavaScript等) templates:放渲染内容到浏览器的模板文件 XXXXApplicationTests.java:简单测试类,确保Spring’应用上下文可以成功加载. 探索构建规范控制打包(jar包/war包) JAR包是基于云思维 WAR包是想部署到传统java应用服务器上. 1&lt;packaging&gt;jar或者war&lt;/packaging&gt; 父POM(Spring-Boot-starts-parent)1234567&lt;!-- Spring Boot的版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; spirng-boot-starts-parent有一个父POM, 作用: 提供依赖管理,不用指定里面的依赖版本 父POM提供版本(version) dependencies从父POM拉取库,不包含库代码:在dependencies中spring boot starter依赖本身不包含库代码,只是从父POM拉取. 好处： 构建文件会显著减少并更易于管理,不必为每个所需的依赖库都声明依赖. 可以根据它们所提供的功能来思考依赖，而不是根据库的名称 不用担心库版本的问题 Spring Boot插件 提供Maven goal,允许使用Maven来允许应用 确保依赖的所有库都会包含在可执行JAR文件中,并保证它们在运行时类路径下是可用的. 在JAR中生成一个manifest文件,将引导类声明为JAR的主类 引用应用JAR包有个主类,主类中有mian()方法.是运行jar包执行类中的方法.(XXXXApplication.java) 123456@SpringBootApplicationpublic class TacoCloudApplication { public static void main(String[] args) { SpringApplication.run(TacoCloudApplication.class, args); }} @SpringBootApplication组合注解 @SpringBootConfiguration:将给类声明为配置类. @EnableAutoConfiguration:启用Spring Boot的自动配置 @ComponentScan:组件扫描 过程: JAR包找到主类，再找到mian方法，在mian方法中调用SpringApplication中的静态run()方法，一个是配置类，另一个是命令行参数.然后创建Spring的应用上下文.(所有这个类一般不用管也不用改) 测试应用1234567@RunWith(SpringRunner.class)@SpringBootTestclass TacoCloudApplicationTests { @Test void contextLoads() { }} 即使这个方法为空,也会检查Spirng应用上下文能够成功加载. @RunWith(SpringRunner.class) Spring运行器:提供一个测试运行器(runner)来指导JUnit如何运行测试 SpringRunner:SpringJUnit4ClassRunner的别名 @SpringBootTest 告诉JUnit在启动测试的时候要添加上Spring Boot的功能. SpringBoot项目启动方式 直接通过主类启动 命令行:mvn spring-boot:run(需要spring-boot-maven-plugin插件) 打包jar包/war包,然后java -jar 包名.jar/war 通过servlet容器开启(类似tomcat) Spring Boot DevTools便利的开发工具 代码变更后应用会自动重启 当面向浏览器的资源(如模板,JavaScript,样式表)等发生变化时，会自动刷新浏览器 自动禁用模板缓存 如果使用H2数据库的话,内置了H2控制台. 应用自动重启DevTools运行时,应用程序加载到java虚拟机(JVM)两个独立的类加载器: 加载你的java代码,属性文件以及项目中”src/main/“路径下所有内容 加载依赖的库 过程: 当监测到变化就重新加载包含项目代码的类加载器并重启容器,另一个类加载器和JVM不会动. 不足： 当依赖发生变化的时候,需要重启应用. 浏览器自动刷新和禁用模板缓存废话阶段: 在具体生成环境,模板会在解析后缓存在浏览器,这样每次请求都不用再解析. 但是再开发环境中，修改模板后,模板不会更新.DevTools禁用所用模板缓存. 具体操作: 只需要刷新浏览器就可用刷新模板. 静态内容修改自动刷新 内置的H2控制台如果有H2数据库,就直接去http://localhost:8080/h2-console打开控制台. 开发Web应用Spring MVC的模型数据和处理表单输入 设计后端 Pojo类 Spring MVC控制器类:获取和处理数据 视图模板:将数据渲染到HTML中并在浏览器展示. 构建Pojo类现实中实际问题抽象化. 使用Lombok中的@Data,重写getter,setter,equals,hashCode,toString方法. 但是如果想使用构造方法,就添加final.(但是setter不会写) 1private final String info; 没有final,就只有setter注入. 1234@Datapublic class Bean { private String info;} 创建控制器类主要职责处理HTTP请求 将请求传递给视图 直接将数据写入响应体(RESTful) 控制器类基本构成 @Slf4j 属于Lombok注解,SLF4J(Simple Logging Facade for Java) Logger 本质上: 1private static final org.slf4j.Logger log=org.slf4j.LoggerFactory.getLogger(本类.class); @Controller @RequestMapping(“/路径1/路径2”) 类级别:指定基本路径 @RequestMapping 方法级别:更具体注解 @GetMapping @PostMapping @DeleteMapping @PatchMapping Model数据模型 职责:控制器和展示数据的视图之间传递数据. Model属性中的数据将会复制到Servlet Response的属性，视图能从这里找到所需的数据. ```javapublic String to(Model model){model.addAttribute(“key名字”, 数据对象);return “TemplateOne”;} 12345678910111213141516171819202122232425262728295. **返回视图逻辑名称** - 映射到templates文件中(相当于视图解析器). - **转发** - &quot;地址&quot;(默认) - &quot;forward:地址&quot; - **重定向** - &quot;**redirect**:地址&quot; ##### 设计视图###### 视图模板- Jsp(JavaServer Pages)- Thymeleaf(选择这个)- FreeMarker- Mustache- Groovy###### 添加依赖```xml&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 运行Thymeleaf与特定的Web框架解耦. Thymeleaf视图无法与控制器放到Model中的数据协同工作,但是可以与Servlet的request属性协作. 在Spring将请求移动到视图之前,会把模型数据复制到request属性中,这样视图模板就可以访问Model中的数据. 处理表单提交 method=”post” 表单标签form中的method改为post 控制类设置@PostMapping的方法 1234@PostMapping public String processDesign(Bean bean) { return &quot;redirect:/orders/current&quot;; } 视图中文本输入元素 在表单元素form中，一些input标签中的name=”bean对象中的成员变量“ 12&lt;input type=&quot;text&quot; th:field=&quot;*{info}&quot;&gt;&lt;!--Bean对象中的info属性--&gt; 校验表单输入(JSR-303)目的不用写一大堆if-else(显式编写声明逻辑) JSR-303（Bean Validation API==Java的Bean校验API) 引入依赖 Validation API 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; Validation API的Hibernate 123456&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.20.Final&lt;/version&gt; &lt;/dependency&gt; 步骤 对pojo类声明校验规则 在控制器类中声明要进行校验 修改表单视图来展示错误 声明校验规则 约束注解 说明 @Null 是否为空 @NotNull 是否为非空 @AssertTrue boolean类型是否为true @AssertFalse boolean类型是否为false @Min Number和String最小值 @Max Number和String最大值 @DecimalMin Number和String最小值,允许存在小数 @DecimalMax Number和String最大值,允许存在小数 @Size String和Array,Collection,Map长度指定范围 @Digits Number和String的特殊指定构成 @Past Data和Calendar在指定时间之前 @Future Data和Calendar在指定时间之后 @Pattern String是否符合正则表达式的规则 @NotBlank 是否为空白 @CreditCardNumber 符合信用卡号 案例message:出错后要展示的消息 12345678@Datapublic class Taco { @NotNull @Size(min=5,message = &quot;Name must be at least 5 characters long&quot;) private String name; @Size(min=1,message = &quot;You must choose at least 1 ingredient&quot;) private List&lt;String&gt; ingredients;} 在表单绑定的时候执行校验让表单在POST提交至对应的控制器方法时执行对应的校验. 方法参数 内容 @Valid 添加到提交对象 Errors errors 新增方法参数 步骤 在控制器类中post方法接收参数添加**@Valid** 在参数多一个Errors errors ```java@PostMapping public String processOrder(@Valid Order order, Errors errors) { if (errors.hasErrors()) { return “orderForm”; } return “redirect:/“ ; } 123456789101112131415161718192021###### @Valid注解校验过程1. **绑定表单数据之后**2. SpringMVC对提交的**对象进行校验**3. 如果存在错误,**错误细节会被Errors对象==&gt;传递给Post方法**4. 无错误则调用Post方法5. 调用**hasErrors()**方法##### 展现校验错误在Thymeleaf中通过**访问Errors对象**来展示错误(借助**th:errors**属性和**fields**)###### 案例```html&lt;span th:if=&quot;${#fields.hasErrors('对象中属性名')}&quot; th:errors=&quot;*{对象中属性名}&quot;&gt;Name Error&lt;/span&gt; (也可以看thymeleaf相关校验内容) 使用视图控制器是什么只将请求转发到视图而不做其他事情的控制器. (没有模型数据和逻辑处理的HTTP GET请求) 步骤 @Configuration注册配置类（也可以在主类里面声明） 类实现WebMvcConfigurer接口 重写**addViewControllers()**方法,注册一个/多个视图控制器 调用registry的addViewController(“输入路径”)方法 执行GET请求 再调用**setViewName(“映射路径”)**方法 1234567@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;); }} 作用当访问”/“的时候会转发到”home”视图. WebMvcConfigurer接口有很多方法配置SpringMVC 设置配置类推荐为每种配置(Web,数据,安全等)创建新的配置类,保持应用的引导配置类尽可能整洁和简单. 选择视图模板库选择 构建WAR包并运行在Servlet容器：选择JSP方案 构建JAR包：选择其他方案 缓存模板 **生产环境(默认)**：模板第一次使用解析,解析结果(缓存模板)后面一直使用,对性能好. 开发环境：关闭缓存模板 12#在application.properties中spring.thymeleaf.cache=false Tips：部署到生产环境要记得删. 数据持久化原始的JDBC代码非常多，使用spring相关对象先消除样板代码,然后用JPA进一步消除一部分代码. Spring消除JDBC样板代码引入相关依赖Jdbc1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; H2数据库12345&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 为什么要使用JdbcTemplate原生JDBC： 非常复杂的样板代码 SQLException是一个检查型异常,无法解决创建连接，创建语句或查询语句的错误. Spring的JdbcTemplate: 没有创建任何的连接和语句 不需要处理catch代码 只关心执行查询和结果映射 使用JdbcTemplate 定义接口 1234public interface IngredientRepository { //1.定义接口方法 Iterable&lt;Ingredient&gt; findAll();} 创建Dao实现类继承接口 添加类的@Repository 12@Repositorypublic class JdbcIngredientRepository{...} 继承接口 12@Repositorypublic class JdbcIngredientRepository implements IngredientRepository {...} 注入JdbcTemplate 123456private JdbcTemplate jdbc;@Autowired public JdbcIngredientRepository(JdbcTemplate jdbc) { this.jdbc = jdbc; } 重写方法使用JdbcTemplate 1234@Override public Iterable&lt;Ingredient&gt; findAll() { return jdbc.query(&quot;select id,name,type from Ingredient&quot;, this::mapRowToIngredient); } Controller类接收Dao类并使用 用构造方法引入实现类后使用. JdbcTemplate查询数据PS：jdbc为引入的JdbcTemplate 查询单个对象 格式： 1jdbc.queryForObject(&quot;sql语句&quot;,RowMapper结果映射,参数1,参数2....) 返回单个对象 查询多个对象 格式: 1jdbc.query(&quot;sql语句&quot;,RowMapper结果映射,参数1,参数2....) 返回多个对象:Iterable&lt;对象&gt; 结果映射RowMapper结果映射：将结果集中的每行对象映射为一个对象. 本质是匿名内部类,处理方法: 显式实现RowMapper(不推荐) 用java8的方法引用/函数式编程 123456789public Iterable&lt;Ingredient&gt; findAll() { //this::mapRowToIngredient为函数式编程中的方法引用. return jdbc.query(&quot;select id,name,type from Ingredient&quot;, this::mapRowToIngredient); }//外部实现匿名内部类private Ingredient mapRowToIngredient(ResultSet rs,int rowNum) throws SQLException { return new Ingredient(rs.getString(&quot;id&quot;), rs.getString(&quot;name&quot;), Ingredient.Type.valueOf(rs.getString(&quot;type&quot;))); } JdbcTemplate插入数据 格式: 1jdbc.update(&quot;sql语句参数位置用？符合&quot;,参数1,参数2,...); 返回一个对象 例子 1jdbcTemplate.update(&quot;insert into Taco_Ingredients(taco,ingredient) values(?,?)&quot;,tacoId,ingredient.getId()); 使用SimpleJdbcInsert包装器类插入数据插入数据并返回key 解决方法： 直接使用JdbcTemplate的update()方法(太麻烦) 使用SimpleJdbcInsert包装器类 引入SimpleJdbcInsert 将JdbcTemplate注入 构造SimpleJdbcInsert实例并注入JdbcTemplate 配置相关表 配置key(如果需要) 123456789private SimpleJdbcInsert a;private SimpleJdbcInsert b; public JdbcOrderRepository(JdbcTemplate jdbcTemplate) { this.a = new SimpleJdbcInsert(jdbcTemplate).withTableName(&quot;相关表&quot;).usingGeneratedKeyColumns(&quot;主键&quot;); this.b = new SimpleJdbcInsert(jdbcTemplate).withTableName(&quot;相关表&quot;); } 使用SimpleJdbcInsert b.execute(Map map) a.execute(Map map).AndReturnKey() 返回Long类型 .longValue() 接收Map&lt;String,Object&gt;类型，key为数据库列名，value为插入实际值 1234Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();values.put(&quot;tacoOrder&quot;, orderId);values.put(&quot;taco&quot;, taco.getId());int execute = orderTacoInserter.execute(values); 预加载sql文件配置文件 12spring.jpa.hibernate.ddl-auto=none#解决JPA自动按实体生成数据库而不加载数据库sql 默认路径:src/main/resources文件下 修改路径 1234#修改数据库路径spring.datasource.schema=classpath:sql/schema.sql#修改预加载数据路径spring.datasource.data=classpath:sql/data.sql 加载数据库(默认文件名)schema.sql 预加载数据(默认文件名)data.sql JPA重写数据Repository什么是Spring DataSpring Data是一个大项目，它的子项目负责对不同的数据库类型进行数据持久化. 特性: Spring Data 对所有项目提供基于repository规范接口自动生成repository的功能. Spring Data JPA: 基于关系型数据库进行JPA持久化 Spring Data MongoDB:持久化到Mongo文档数据库 Spring Data Neo4j:持久化到Neo4j图数据库. Spring Data Redis:持久化到Redis key-value存储 Spring Data Cassandra:持久化到Cassandra数据库. 添加相关依赖引入JPA1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; JPA是JAVA EE 5标准的ORM接口. Hibernate是ORM框架. JPA是标准接口，Hibernate是实现 将pojo类标注为实体@Entity标记pojo类为实体类,采用默认ORM规则. (类名=表名,类属性名=表字段名,可选择name=‘“数据库名”) 123456@Entity@Table(name = &quot;abc&quot;)public class GG {...}//代表GG类对应名为abc表,如果没有就指定名为GG的表 映射规则: 实体类要@Entity(javax.persistence.Entity) @id（javax.persistence.Id）注解一个主键 实体类必须要一个public/protected的无参构造函数 实体类不能是final类，也不能有final方法. 如果实体类的一个实例需要用传值的方式调用,则这个实体类需要继承Serializable接口. 1234567891011@Data@Entity@Table(name = &quot;Taco_Order&quot;)public class Order implements Serializable { private static final long serialVersionUID=1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; ...} @Table 直接指定实体类对应哪一个表 优先级：@Table &gt; @Entity 12345@Entity@Table(name = &quot;bcd&quot;)public class abc{ ...} @column 直接指定类属性对应数据库哪一个字段 name=‘字段名’ unique：字段是否唯一 nullable：字段是否空 length：字段长度 12345@Entitypublic class abc{@Column(name = &quot;createdat&quot;) private Date createdAt;} @ID 标记改属性为主键 @GeneratedValue(strategy = 主键生成模式) AUTO：主键由程序控制，是默认选项，不设置即此项 IDENTITY（一般使用这个)：主键由数据库自动生成（Oracle不支持这种方式） SEQUENCE：通过数据库的序列产生主键(数据库不支持自增)，通过@SequenceGenerator 注解指定序列名，mysql不支持这种方式 TABLE：通过特定的数据库表产生主键，易于数据库移植. 123456@Entitypublic class abc{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private long id;} 实体类中的命名策略(以@Entity 为例子)PS:@Table和@column也一样 差不多按照驼峰命名法 全变成小写 当遇到第二个字母大写则前面加下划线 12345678@Entity public class BoxAplle{...} 表名 box_apple @Entity(name=&quot;BA&quot;) public class BoxApple{...} 表名 ba @Entity(name=&quot;BoApple&quot;) public class BoxApple{...} 表名 bo_apple @Entity(name=&quot;boxapple&quot;) public class BoxApple{...} 表名 boxapple 相关注解@PrePersist在上传实体前调用这个注解下的方法. 1234@PrePersistvoid createAt(){ this.createdAt=new Date();} @OneToMany一对多 外键关联 123456789//两个实体类一个有主键(1)，一个有外键(多)@Entity@Table(name=&quot;1的表&quot;)public class 1的类名 implements java.io.Serializable { @OneToMany(cascade={ CascadeType.ALL }) @JoinColumn(name=&quot;在多的表建新列来指向1的主键&quot;) private Collection&lt;多的类型&gt; addresses = new ArrayList&lt;多的类型&gt;();...} 表关联(多一个表关联两个表) 1234567891011@Entity@Table(name = &quot;1的表&quot;)public class 1的类名 implements java.io.Serializable { ... @OneToMany(cascade = { CascadeType.ALL }) @JoinTable(name=&quot;关联用的表&quot;, joinColumns={ @JoinColumn(name=&quot;在多的表建新列来指向1的主键&quot;,referencedColumnName=&quot;1的主键&quot;)}, inverseJoinColumns={@JoinColumn(name=&quot;在多的表建新列来指向1的主键&quot;,referencedColumnName=&quot;1的主键&quot;)}) private Collection&lt;多的类型&gt; addresses = new ArrayList&lt;多的类型&gt;(); ...} 默认关联(直接数据库外键) @ManyToOne多对一 外键关联 12345678910@Entity@Table(name=&quot;多的类表&quot;)public class 多的类 implements java.io.Serializable { @ManyToOne(cascade = { CascadeType.ALL }) @JoinColumn(name=&quot;在多的表建新列来指向1的主键&quot;) private 1的类 customer; // ...} 默认关联(直接数据库外键) @ManyToMany多对多（其他用法和一对多类似） 12@ManyToMany(targetEntity = Guo.class)private List&lt;Guo&gt; guos=new ArrayList&lt;&gt;(); @Transient这个属性不会被持久化 @OneToOne，@OneToMany，@ManyToMany中mappedBy双向关联问题 @OneToMany(mapped=“由One的一方指向Many的一方，并且，这个属性应该等于Many的一方中含有One类的属性的属性名 ”) 如果我们没有填mapped这个属性，则会产生第三张表，这一张表是用来管理这两张表的 mappedBy不能用在@ManyToOne 使用mapperBy的类为主维护者(当这个类不为空时，另一个类可空可不空，但当这个类为空时，另一个类一定是空) 声明 JPA repository使用步骤 通过让Repository接口继承CrudRepository接口， 来让Spring Data JPA 自动生成实现类,然后调用这些repository， 再注入到Controller层实现各种CRUD(创建，读取，更新，删除) Repository接口格式:12public interface 接口名 extends CrudRepository&lt;持久化的实体类型, 实体ID属性的类型&gt; {} Controller调用1接口名.已经写好的CRUD方法() 分页访问1接口名.查询方法(new PageRequest(开始, 结束)) 12PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a beanPage&lt;User&gt; users = repository.findAll(new PageRequest(1, 20)); 自定义 JPA repository处理上面处理不了的问题，有细节的操作.(在接口中定义相关更细节的处理方式) @Query 执行原生SQL 123456public interface UserRepository extends JpaRepository&lt;User, Long&gt; { //注意要设置nativeQuery = true //注意参数要？1 ?2 ?3 ... @Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true) User findByEmailAddress(String emailAddress);} 使用SQL并且带自定义名称 1234567public interface UserRepository extends JpaRepository&lt;User, Long&gt; {//sql列中位置要用 ：列名//参数要用@Param(&quot;列名&quot;) @Query(&quot;select u from User u where u.firstname = :firstname or u.lastname = :lastname&quot;) User findByLastnameOrFirstname(@Param(&quot;lastname&quot;) String lastname, @Param(&quot;firstname&quot;) String firstname);} 实现排序查询 1234567891011//Spring Data JPA拒绝Order包含函数调用的任何实例//参数会多一个Sort类型public interface UserRepository extends JpaRepository&lt;User, Long&gt; { @Query(&quot;select u from User u where u.lastname like ?1%&quot;) List&lt;User&gt; findByAndSort(String lastname, Sort sort);}//Controller层调用//new Sort(&quot;查询列名&quot;)repo.findByAsArrayAndSort(&quot;bolton&quot;, new Sort(&quot;fn_len&quot;)); 实现分页查询 12345678910//value=&quot;sql&quot;//countQuery=&quot;统计sql行数&quot;public interface UserRepository extends JpaRepository&lt;User, Long&gt; { @Query(value = &quot;SELECT * FROM USERS WHERE LASTNAME = ?1&quot;, countQuery = &quot;SELECT count(*) FROM USERS WHERE LASTNAME = ?1&quot;, nativeQuery = true) Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);}//Controlller层调用UserRepository.findByLastname(参数,new PageRequest(开始, 结束)) 领域特定语言(DSL) 原理：Spring Data直接检查repository接口的所有方法并解析方法名称. 格式： 一个动词 get / read / find count返回int 一个可选主题 不写则默认本实体中的数据库 写就指定 关键词By 一个断言（字段名） 操作符 12345678//例子readOrdersByDeliveryZipAndPlacedAtBetween();//read=读取//Orders=数据库//By关键词//DeliveryZip=字段名deliveryZip或者delivery.zip//PlacedAt=字段名placedAt或者placed.at//Between=PlacedAt的范围 @ModelAttribute运用类运用1234@SessionAttributes(value ={&quot;name&quot;,&quot;name1&quot;,...} )public class a{ ...} 原理将名为name的ModelAttribute保存在Session实现跨域访问. 记得重置Session引入参数SessionStatus，然后调用其中的方法.setComplete() 来重置Session 1234public String processOrder(@Valid Order order, Errors errors, SessionStatus sessionStatus) { sessionStatus.setComplete(); return &quot;redirect:/&quot;;} 方法运用访问Controller中的链接时，优先执行@ModelAttribute的方法。但是当一个Controller类有多个链接,要小心生成的model. 无返回值方法@ModelAttribute 12345@ModelAttributepublic void order(){ //相当于一个可以优先使用的方法，一般用来先将参数放入model //model.addAttribute(&quot;名字&quot;, 参数);} 有返回值方法@ModelAttribute 12345@ModelAttributepublic Order order(){ return new Order();}//相当于优先执行model.addAttribute(&quot;order&quot;, new Order()); 有返回值方法@ModelAttribute(value=”name”) 12345@ModelAttribute(name=&quot;abc&quot;)public Order order(){ return new Order();}//相当于优先执行model.addAttribute(&quot;abc&quot;, new Order()); 参数运用 从Model上获取@Controllerpublic class HelloWorldController { 123456789101112@ModelAttribute(&quot;a&quot;)public Order addAccount() { return new Order(&quot;1&quot;,&quot;2&quot;); //在model生成{key='a',value=Order对象}} @RequestMapping(value = &quot;/helloWorld&quot;)public String helloWorld(@ModelAttribute(&quot;a&quot;) Order order) { //相当于从model获得key='a'的数据 return &quot;helloWorld&quot;;} 从表单Form/URL路径参数获得 12345@RequestMapping(value = &quot;/helloWorld&quot;) public String helloWorld(@ModelAttribute(&quot;a&quot;) User user) { //从表单获得a对象 return &quot;helloWorld&quot;; } 保护Spring引入Spring Security1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 引入后获得的安全特性 所有的HTTP请求路径都需要认证 不需要特定的角色和权限 没有登陆页面 认证过程是通过HTTP basic认证对话框实现的 系统只有一个用户user 12//密码在输出框中显示Using default security password: 60位加密密码... 显式配置可覆盖掉自动配置如果实现来了下面配置Spring Security，上面的部分特性会被覆盖掉. 配置Spring Security 新生成安全配置类 继承WebSecurityConfigurerAdapter接口 添加类级别**@Configuration** 添加类级别**@EnableWebSecurity**来启动安全配置 123456@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {... //用户存储以及保护web请求，跨站攻击的具体配置} 用户存储 安全配置类实现WebSecurityConfigurerAdapter接口 重写configure(AuthenticationManagerBuilder auth)方法 12345678@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {protected void configure(AuthenticationManagerBuilder auth) throws Exception { ... //具体用户存储配置 }} 基于内存优点 应用于测试/简单应用 用户信息数量有限且不会发送变化 缺点 难以编辑用户 要重新构建和部署应用 具体使用 调用AuthenticationManagerBuilder中的inMemoryAuthentication方法 配置用户withUser(“用户名”) 配置密码password(“{noop}密码”) 用户不加密的密码必须前面加{noop} 用户加密的密码不用 配置权限authorities(“ROLE_权限名”) 123456789101112protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(&quot;buzz&quot;) .password(&quot;{noop}abc123456&quot;) .authorities(&quot;ROLE_USER&quot;) .and() .withUser(&quot;abc&quot;) .password(&quot;{noop}abc&quot;) .authorities(&quot;ROLE_USER&quot;); //配置了用户buzz 密码abc123456 权限ROLE_USER //配置了用户abc 密码abc 权限ROLE_USER} 基于JDBC优点 直接使用关系型数据库 缺点 对比LDAP会慢点 默认用户使用方法 注入DataSource 调用AuthenticationManagerBuilder中的jdbcAuthentication()方法 调用dataSource(注入DataSource) 12345678@Autowiredprivate DataSource dataSource;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.jdbcAuthentication() .dataSource(dataSource);} 默认有用户查询功能（但是数据库要按它的要求建立）(了解即可) 查找用户的用户名,密码,是否启用的信息 1public static final String DEF_USERS_BY_USERNAME_QUERY = &quot;select username,password,enabled from users where username = ?&quot;; 查找用户所授予的权限 1public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY = &quot;select username,authority from authorities where username = ?&quot;; 查找用户所在群组id，群组名，所授予的权限. 1public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY = &quot;select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id&quot;; 路径 1org/springframework/security/core/userdetails/jdbc/JdbcDaoImpl 自定义用户使用方法 接着上面的 （可选）重写认证的查询语句usersByUsernameQuery() 参数:用户名username 用户名username 密码password 启用状态信息enabled （可选）重写基本权限的查询语句authoritiesByUsernameQuery() 参数:用户名username 用户名username 权限authority （可选）重写群组权限的查询语句groupAuthoritiesByUsername() 参数:用户名username 群组id 群组名group_name 所在群组权限authority 123456789101112@Autowiredprivate DataSource dataSource;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery(&quot;select username,password,enabled from MyUsers &quot; + &quot;where username=?&quot;) .authoritiesByUsernameQuery(&quot;select username, authority from UserAuthorities &quot; + &quot;where username=?&quot;);} PS：里面填的sql的条件和查询结果列一定要一致. 密码转码器 使用方法 1.passwordEncode(加密模块对象) 12345678910111213@Autowiredprivate DataSource dataSource;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery(&quot;select username,password,enabled from MyUsers &quot; +&quot;where username=?&quot;) .authoritiesByUsernameQuery(&quot;select username, authority from UserAuthorities &quot; + &quot;where username=?&quot;) .passwordEncoder(new BCryptPasswordEncoder());} 加密模块 BCryptPasswordEncoder：使用bcrypt强哈希加密 Pbkdf2PasswordEncoder：使用PBKDF2加密 SCryptPasswordEncoder：使用scrypt加密 自定义加密模块 实现PasswordEncoder接口 以LDAP作为后端LDAP(Lightweight Directory Access Protocol,轻量级目录访问协议) 简单使用 调用AuthenticationManagerBuilder中的ldapAuthentication()方法 指定用户查询基础userSearchBase(默认从LDIF文件根开始)—–指定从哪里开始查 为LDAP查询提供过滤条件userSearchFilter 同理有groupSearchBase，groupSearchFilter 123456789@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .ldapAuthentication() .userSearchBase(&quot;ou=people&quot;) .userSearchFilter(&quot;(uid={0})&quot;) .groupSearchBase(&quot;ou=groups&quot;) .groupSearchFilter(&quot;member={0}&quot;); } 配置密码比对LDAP认证策略 绑定操作(默认):直接通过LDAP服务器认证用户 比对操作：在LDAP服务器内直接对比密码 调用passwordCompare()进行比对 比对属性 userPassword属性（默认） 调用passwordAttribute（”属性名“）指定属性 12345678910111213141516@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .ldapAuthentication() .userSearchBase(&quot;ou=people&quot;) .userSearchFilter(&quot;(uid={0})&quot;) .groupSearchBase(&quot;ou=groups&quot;) .groupSearchFilter(&quot;member={0}&quot;) .passwordCompare() //实现密码比对 .passwordEncoder(new BCryptPasswordEncoder()) //实现加密 .passwordAttribute(&quot;passcode&quot;); //指定LDAP服务器内的密码属性 } 应用远程LDAP服务器 用and()分开其他配置 调用contextSource() 调用url(“远程地址”)设置LDAP服务器地址 12345678910111213141516@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .ldapAuthentication() .userSearchBase(&quot;ou=people&quot;) .userSearchFilter(&quot;(uid={0})&quot;) .groupSearchBase(&quot;ou=groups&quot;) .groupSearchFilter(&quot;member={0}&quot;) .passwordCompare() .passwordEncoder(new BCryptPasswordEncoder()) .passwordAttribute(&quot;userPassword&quot;) .and() //分开其他配置 .contextSource() .url(&quot;ldap://tacocloud.com:33389/dc=tacoloud,dc=com&quot;)} 配置嵌入式的LDAP服务器 and()分开其他配置 调用contextSource() 调用root(“根前缀”) 指定LDIF文件ldif(“classpath:resources路径”) 12345678910111213141516@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .ldapAuthentication() .userSearchBase(&quot;ou=people&quot;) .userSearchFilter(&quot;(uid={0})&quot;) .groupSearchBase(&quot;ou=groups&quot;) .groupSearchFilter(&quot;member={0}&quot;) .passwordCompare() .passwordEncoder(new BCryptPasswordEncoder()) .passwordAttribute(&quot;userPassword&quot;) .and() .contextSource() .root(&quot;dc=tacocloud,dc=com&quot;) .ldif(&quot;classpath:users.ldif&quot;); } PS：LDIF(LDAP数据交换形式) 自定义用户认证持久化用户数据 定义用户领域对象和持久化 创建User类 类级别 @Entity @Data @RequiredArgsConstructor @NoArgsConstructor(access = AccessLevel.PRIVATE,force = true) 继承UserDetails接口 重写方法 用户权限集（默认需要添加”ROLE_”前缀）getAuthorities 1234@Overridepublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return Arrays.asList(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));} 账号是否过期isAccountNonExpired 1234@Overridepublic boolean isAccountNonExpired() { return true;} 账号是否锁定isAccountNonLocked 1234@Overridepublic boolean isAccountNonLocked() { return true;} 凭证是否过期isCredentialsNonExpired 1234@Overridepublic boolean isCredentialsNonExpired() { return true;} 用户是否可用isEnabled 1234@Overridepublic boolean isEnabled() { return true;} 实现repository接口,并且定义findByUsername()方法 123public interface UserRepository extends CrudRepository&lt;User,Long&gt; { User findByUsername(String username);} 创建用户服务 创建服务类 添加类注解**@Service** 类继承UserDetailsService 注入UserRepository类 重写loadUserByUsername方法 1234567891011121314151617181920@Servicepublic class UserRepositoryUserDetailsService implements UserDetailsService { private UserRepository userRepository; @Autowired public UserRepositoryUserDetailsService(UserRepository userRepository) { this.userRepository = userRepository; } @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User byUsername = userRepository.findByUsername(username); //当byUsername不为空====&gt;返回User对象 if(byUsername!=null){ return byUsername; } throw new UsernameNotFoundException(&quot;User '&quot;+username+&quot;' not found&quot;); //当byUsername为空 抛出错误 }} 回到Spring Security配置类中的configure（）方法 注入UserDetailsService 在configure调用userDetailsService()方法 123456789@Autowiredprivate UserDetailsService userDetailsService;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .userDetailsService(userDetailsService); } 配置密码转码器 1234567891011121314@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .userDetailsService(userDetailsService) .passwordEncoder(encoder()); //对于encoder()的任何调用都会被拦截,并返回应用上下文中的bean实例}@Beanpublic PasswordEncoder encoder(){ return new BCryptPasswordEncoder(); //注册一个名为encoder的bean实例 返回PasswordEncoder对象} 注册用户 创建用户表单类 将密码加密 1234567891011@Datapublic class RegistrationForm { ... private String password; ... public User toUser(PasswordEncoder passwordEncoder) { return new User(username, passwordEncoder.encode(password), fullname, street, city, state, zip, phone); //密码在保存数据库前.通过PasswordEncoder中的encode将密码加密 }} 创建用户注册控制类 添加类级别**@Controller ,@RequestMapping(“/register”)** 注入UserRepository和PasswordEncoder 设置注册视图以及在控制类中配置跳转到注册视图的方法. 当表单输入成功后，调用UserRepository来保存用户 12345@PostMapping public String processRegistration(RegistrationForm form){ userRepository.save(form.toUser(passwordEncoder)); return &quot;redirect:/login&quot;; } 保护Web请求我们需要把主页,登录页和注册页开放给未认证的用户. 在Spring Security配置类实现**configure(HttpSecurity http)**方法 12345678@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {@Override protected void configure(HttpSecurity http) throws Exception { ... }} HttpSecurity配置功能 在为某个请求提供服务之前，需要先预先满足特定的条件 配置自定义的登录页 支持用户退出 预防跨站请求伪造 保护请求对不同的请求有不同的安全需求 使用方法在configure(HttpSecurity http)中 1234567@Overrideprotected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(&quot;请求指定URL路径&quot;) .安全配置方法;} 配置有顺序声明在前面的安全规则比后面声明的规则有更高优先级. 12345678910@Overrideprotected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(&quot;/design&quot;,&quot;/orders&quot;) .hasRole(&quot;USER&quot;) //默认开头”ROLE_“,所有不填&quot;ROLE_USER&quot; .antMatchers(&quot;/&quot;,&quot;/**&quot;) .permitAll(); } 案例说明 具备”ROLE_USER”权限的用户才能访问”/design”和”/orders” 其他请求允许所有用户访问. 安全配置方法 方法 能干什么 access(String) 给SpEL表达式并且最后结果为true，就给访问 anonymous() 允许匿名访问 authenticated() 允许认证过的用户访问 denyAll() 无条件拒绝所有访问 not() 对其他访问方法的结果求反 permitAll() 无条件允许访问 hasRole(String) 如果用户具备给定角色，就允许访问 hasAnyRole(String …) 如果用户具备给定角色中的某一个，就允许访问 hasAuthority(String …) 如果用户给定权限，就允许访问 hasAnyAuthority(String …) 如果用户具有权限中·某一个，就允许访问 hasIpAddress(String …) 如果请求是给定IP，就允许访问 fullyAuthenticated() 如果用户是完整认证(不是Remember-me功能认证),就允许访问 rememberMe() 如果用户是通过Remember-me功能认证的，就允许访问 access()方法中的SpEL表达式acccess()通过SpEL表达式来实现各种各样的安全性限制 使用方法 1234567@Overrideprotected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(&quot;/design&quot;,&quot;/orders&quot;) .access(&quot;hasRole('USER')&quot;+&quot;&amp;&amp;&quot;+&quot;year==3&quot;) } 功能说明 对于请求路径”/design”,”/orders”来说,只用当具备”ROLE_USER”并且year等于3的用户才可以访问 总结:在access(SpEL表达式) SpEL表达式的结果是boolean值就行. SpEL表达式 表达式 计算结果 authentication 用户认证对象 denyAll 结果一直是false permitAll 结果一直是true hasRole(roles) 如果用户具备给定角色，结果为true hasAnyRole(list of roles) 如果用户具备给定角色中的某一个，结果为true hasIpAddress(IP Address) 如果请求是给定IP，结果为true isAnonymous() 如果当前是匿名用户，结果为true isAuthenticated() 如果当前是进行认证，结果为true isFullyAuthenticated() 如果用户是完整认证(不是Remember-me功能认证),结果为true isRememberMe() 如果用户是通过Remember-me功能认证的，结果为true principal 用户的principal对象 创建自定义的登录页功能 配置自定义登陆页 可配置上传路径和输入域 配置登陆成功后指向的页面 可配置是否返回登陆之前正在访问的页面 使用方法 在Spring Security安全配置类中重写configure(HttpSecurity http) **and()**分开安全配置 **formLogin()**配置登陆自定义的的登陆表单 **loginPage(“登陆页面路径”)**提供自定义登陆页面的路径(当用户没有认证需要登陆的时候就重定向到这) 需要控制器处理上面请求 在Webconfig类/主启动类中的addViewControllers添加登陆页面的视图控制器 12345@Overridepublic void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;); registry.addViewController(&quot;登陆页面路径&quot;);} **loginProcessingUrl(“/新路径”)**配置登陆表达上传路径（默认=”/login”） 配置登陆表达输入域 usernameParameter(“表单中用户输入域的名称”)(默认=“username) **passwordParameter(“表单中用户密码输入域的名称”)**（默认=”password”） defaultSuccessUrl(“/新路径”,boolean(默认=false)）配置登陆成功后跳转页面和是否返回登陆之前浏览页面 1234567891011121314151617181920212223@Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(&quot;/design&quot;,&quot;/orders&quot;) .access(&quot;hasRole('USER')&quot;) .antMatchers(&quot;/&quot;,&quot;/**&quot;) .access(&quot;permitAll()&quot;) .and() .formLogin() //配置登陆表单 .loginPage(&quot;/login&quot;) //配置登陆表单的路径为 ”/login“===&gt;视图控制器====》&quot;loign&quot;视图 .loginProcessingUrl(&quot;/abc&quot;) //登陆表单上传到路径&quot;/abc&quot; .usernameParameter(&quot;user&quot;) //表单中输入域名称为“user”作为用户账号 .passwordParameter(&quot;pwd&quot;) //表单中输入域名称为“pwd”作为用户密码 .defaultSuccessUrl(&quot;/design&quot;,true); //登陆成功后重定向到&quot;/design&quot;,开启登陆后重定向到未登陆之前浏览的页面 } 退出登陆功能 退出用户登陆按钮 配置退出登陆后指定页面 使用方法 在Spring Security安全配置类中重写configure(HttpSecurity http) **and()**分开安全配置 **logout()**退出登陆 **logoutSuccessUrl(“新路径”)**退出成功后重定向页面 1234.and().logout().logoutSuccessUrl(&quot;/&quot;) //退出登陆后 访问路径为&quot;/&quot; 表单 程序会拦截”/logout”的请求 当用户按下按钮时，用户的session会重置 123&lt;form th:action=&quot;@{/logout}&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Logout 退出登陆&quot;&gt;&lt;/form&gt; 防止跨站请求伪造CSRF是什么一种安全攻击.他会让用户在一个恶意的Web页面上填写信息，然后自动(秘密的)将表单以攻击受害者的身份提交到另一个应用上. 案例C用户登陆到A银行网站，但是突然有个弹窗弹出来，C用户点了，那么这个弹窗有个恶意表单提交(通常是隐藏的)给A银行，然后以C用户的cookie和session来发送，最后C用户银行钱不见了.(C用户的cookie和session没有泄露) 应对策略 在展示表单中生成一个在隐藏域的CSRF token 提交表单的时候，token将和其他的表单数据以前发送至服务端 请求被服务端拦截，并与最初生成的token对比 如果匹配，请求会被处理 PS：Spring Security默认提供CSRF保护. 表单设置每个表单都必须有”_csrf”的字段，它会持有CSRF token 1&lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; th:value=&quot;${_csrf.token}&quot;&gt; 禁用CSRF支持(最好别干)123.and().csrf().disable(); 获取用户信息我们不仅要用户注册登陆访问，还要获得用户的信息 使用@AuthenticationPrincipal注解来标注方法(best)优点 不用类型转换 把安全代码限制在注解层面 缺点 你要知道用户的对象类型User 使用方法 添加方法参数注解@AuthenticationPrincipal 直接获得User对象 123456@PostMapping public String processOrder(@Valid Order order, Errors errors, SessionStatus sessionStatus, @AuthenticationPrincipal User user) { ... order.setUser(user); ... } 注入Principal对象到控制器方法中优点 参数可直接调用用户对象 缺点 在非安全相关代码掺杂安全代码 使用方法 方法参数Principal principal.getName()直接返回用户名 这个Principal参数其实包含User对象 12345678@PostMappingpublic String processOrder(@Valid Order order, Errors errors, SessionStatus sessionStatus, Principal principal) { ... User byUsername = userRepository.findByUsername(principal.getName()); //通过名称 查询User对象 order.setUser(byUsername); ...} 注入Authentication对象到控制器方法中优点 直接获得User对象 缺点 需要转换类型 使用方法 参数方法Authentication authentication.getPrincipal()获取其中User对象 将Obejct类型转User类型 1234567@PostMapping public String processOrder(@Valid Order order, Errors errors, SessionStatus sessionStatus, Authentication authentication) { ... User user =(User) authentication.getPrincipal(); order.setUser(user); ... } 使用SecurityContextHolder来获取安全上下文优点 可以在应用测序的任何地方使用，不止控制器类 缺点 安全性相关代码太多 使用方法 从Security上下文获得Authentication对象 从Authentication调用getPrincipal得到Principal对象 再转类型到User 1234567@PostMapping public String processOrder(@Valid Order order, Errors errors, SessionStatus sessionStatus) { ... Authentication authentication1 = SecurityContextHolder.getContext().getAuthentication(); User principal = (User) authentication1.getPrincipal(); ... } 使用配置属性springboot可以自动配置，也有配置属性的方法 细粒度的自动配置一般配置方法 bean装配:声明在Spring应用上下文中创建哪些应用组件以及它们之间如何互相注入的配置 属性注入:设置Spring应用上下文中bean的值的配置. 显式声明 XML方式 基于java的配置 通过不同属性源配置Spring属性源以修改端口为例子 JVM系统属性 操作系统环境变量 12$ export SERVER_PORT=9090操作系统的环境变量一次性设置 命令行参数 12$ java -jar 包名.jar --server.port=9090命令行参数启动应用时候 Application.properties 12#在src/main/resources/application.propertiesserver.port=9090 Application.yml 123#在src/main/resources/application.ymlserver: port: 9091 PS：SERVER_PORT和server.port一样 配置数据源开发环境:嵌入式H2 生产环境:Mysql 配置数据源在application.yml中 123456spring: datasource: url: jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=UTF-8 username: 用户 password: 密码 driver-class-name: com.mysql.cj.jdbc.Driver 如果类路径中存在Tomcat的JDBC连接池，DataSource将使用该连接池，否则会使用 HikariCP Commons DBCP 2 JNDI配置数据源1234spring: datasource: jndi-name: 路径#配置这个，那么上面的就会失效 配置嵌入式服务器开放可用任意端口12server： port：0 处理HTTPS请求 用JDK的keytool命令行工具生成keystore 1$ keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA 在application.yml配置 123456server： port; 开放端口 ssl： key-store: file:文件路径 或者 &quot;classpath:JAR包路径&quot; key-store-passord: 密码 key-password: 密码 配置日志目的：设置日志级别 使用方法 在application.yml 以logging.level作为前缀的属性 ```yamllogging: level:包全名: 日志级别 12345674. 生成日志地址 - ```yaml logging: file: name: 具体路径包含日志命名 ```yamllogging: file:path: 具体路径#默认生成一个spring.log日志文件1234567891011##### 例子```yamllogging: level: root: warn org.springframework.security: debug file: name: C:\\Users\\13703\\Desktop\\spring.log path: C:\\Users\\13703\\Desktop 限制默认情况下，日志文件超过10MB，就会轮换. 使用其他配置属性的属性值从其他的配置属性注入到其他属性 ${}占位符12a: b: you ${b.c} 目的在配置Spring自己的组件中，使用配置属性可用容易地将值注入到这些组件属性中，并且可以细粒度地调整自己配置功能. 创建自己的配置属性 首先在需要配置属性的类中添加 123456//@ConfigurationProperties(prefix = &quot;配置前缀&quot;)@Controller@ConfigurationProperties(prefix = &quot;b.c&quot;)public class a{...} 设置类里面的值为属性(设置b.c中的a值) 12345678@ConfigurationProperties(prefix = &quot;b.c&quot;)@Controllerpublic class a{ private String a; public void setA(String a){ this.a=a; }} 在application.yml配置属性 123b: c: a: &quot;我是a值&quot; 或者设置环境变量 1$ export B_C_A=&quot;我是A值&quot; 定义配置属性的持有者特点 @ConfigurationProperties只能用在控制器或特定类型的bean @ConfigurationProperties通常设置一种bean专门持有配置数据 通过配置属性持有者bean，我们把所有的配置属性收集到一个地方，这样可以使其他bean因可能保持整洁. 例子：以上为例 123456@Data@Component@ConfigurationProperties(prefix = &quot;b.c&quot;)public clsss d{ private String a=&quot;sb&quot;;} 声明配置属性元数据说白了，给配置属性提供一个最小化的文档. 使用方法 在**”src/main/resources/META-INF”下面创建additional-spring-configuration-metadata.json** ```json{ “properties”: [{ //配置属性的全名“name”: “taco.config.page-size”, //配置属性的参数类全名“type”: “java.lang.String”, //这个配置属性的简短描述“description”: “我是傻逼.” } ]} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748##### 例子![](D:\\TyporaOfimage\\屏幕截图 2021-08-25 032226-1629833010580.jpg)#### 使用profile进行配置##### 目的- **为不同的部署环境配置不同的属性**- 解决配置属性太多，设置麻烦，并且支持回滚##### 是什么profile是一种条件化的配置，在运行时，根据哪些profile处于激活状态，可以使用或忽略不同的bean，配置类和配置属性.#### 定义特定profile的属性##### 全局设置- 创建**application.yml**- **全局的属性配置**##### 分开文件设置- 创建**application-{profile名}.yml**- 一个文件一个环境 - application-dev.yml 代表dev环境 - application-prod.yml 代表prod环境 - application-test.yml 代表test环境#### 激活profile##### 默认激活- 在**application.yml**- ```yaml spring: profiles: active: 环境名(例如&quot;dev&quot;) #代表默认激活dev这个环境的配置属性 激活 生产环境 1% export SPRING_PROFILES_ACTIVE=dev 命令行参数启动 1% java -jar 包名.jar --spring.profiles.active=dev 批量激活 生产环境 1% java -jar 包名.jar --spring.profiles.active=prod,dev,test 默认yaml 123456spring: profiles: active: - prod - dev - test 使用profile条件化创建bean为不同的profile创建一组bean 正常来说，java配置类中声明的bean都会被创建 使用**@Profile注解将某些bean设置成特定的prfile才能被创建** @Bean方法级别 @Profile(“环境名”) @Profile({“环境名1”,”环境名2,”…..}) !符号代表不激活 @Profile({“！环境名1”,”！环境名2,”…..}) 当环境1和环境2不激活的时候，这个bean才被创建 12345@Bean@Profile(&quot;环境名&quot;)public void a(){...} @Configuration类级别与上同理 12345@Configuration@Profile(&quot;环境名&quot;)public class b{...} Spring集成创建Rest服务两种程序设计模式 MPA(MultiPage Application)：传统的多页应用 只需要在Web页面显示信息 SPA(Single-Page Applcaiton)：基于前端框架的单页应用 前后端分离 利于开发相同后端，不同前端的应用. 并不一定都用SPA，简单显示页面就选择MPA 创建RESTful控制器类 类级别@RestController 类级别@Controller和每个方法@ResponseBody 返回ResponseEntity对象 RESTful控制器类中的HTTP请求处理请求处理注解 注解 HTTP 方法 用途 @GetMapping HTTP GET请求 读取资源数据 @PostMapping HTTP POST请求 创建资源 @PutMapping HTTP Put请求 更新全部资源 @PatchMapping HTTP Patch请求 更新部分资源 @DeleteMapping HTTP Delete请求 删除资源 @RequestMapping 全部HTTP请求方法都行 一般在类级别作这个控制器类设置和设置基础地址 注解中的参数 path：请求路径 consumes：指定请求输入类型 produces：指定请求返回类型 123456789101112@RestController@RequestMapping(path = &quot;/box&quot;,produces = {&quot;application/json&quot;,&quot;text/xml&quot;})//这个控制类基础请求时/box 并且这个类下面全部方法的指定返回类型是JSON或者XMLpublic class BoxController { ... @PostMapping(consumes = &quot;application/json&quot;) //这个方法的请求类型是JSON public Box saveBox(@RequestBody Box box){ ... } ...} 请求成功后返回Stats(状态码) 方法级别**@ResponseStatus(HTTPStatus.状态码类型)** 返回ResponseEntity对象 ```javareturn new ResponseEntity&lt;&gt;(返回对象/NUll,HTTPStatus.状态码类型);1234567891011121314151617181920212223242526例子：```java@RestController@RequestMapping(path = &quot;/box&quot;,produces = &quot;application/json&quot;)public class BoxController { ... @DeleteMapping(&quot;/{id}&quot;) @ResponseStatus(code=HttpStatus.NO_CONTENT) //当请求到/box/{id} 服务器就会返回状态码NO_CONTENT(204) public ResponseEntity deleteBox(@PathVariable Long id){ try { boxRepository.deleteById(id); return new ResponseEntity(HttpStatus.OK); // 当删除数据成功 就返回ResponseEntity对象，并指定状态码OK(200) } catch (EmptyResultDataAccessException e) { return new ResponseEntity&lt;&gt;(null,HttpStatus.NOT_FOUND); // 当抛出没有找到的异常时 就返回ResponseEntity对象，并指定响应体=null，返回状态码404 } } ...} 允许跨域请求 类级别**@CrossOrigin(origins = ““)* RESTful控制器类中的HTTP参数处理@PathVariable 通过处理器方法的路径上使用占位符并让方法接收一个路径变量 ```java@GetMapping(“/{id}”)public ResponseEntity getBoxByid(@PathVariable long id){…} 1234567891011121314##### **@RequestBody**- 从请求体中**请求参数(例如JSON)**会被绑定到指定对象中- 如果没有这个注解，程序会将**请求参数(查询参数/表单参数)**绑定到指定对象中- ```java @PutMapping(&quot;/{id}&quot;) public Box putBox(@RequestBody Box box){ ... } 启用超媒体超媒体作为应用状态引擎( Hypermedia as the Engine of Aplication State , HATEOAS )是一种创建自描述 API 的方式. API返回包含资源链接和资源的内容 客户端通过最少API URL可以导航全部API 通过API描述自己的URL，减少客户端硬编码的痛苦. 超文本应用语言(Hypertext Application Language,HAL)一种在JSON响应中嵌入超链接的简单通用格式. _links：为客户端提供导航API recents：引用该API本身 特点优点 向API添加链接变简单 缺点 产生额外代码 如果API的URL模式发生变化，客户端代码就不可用了 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;&lt;/dependency&gt; 添加超链接超链接资源当Spring MVC REST控制器返回时，携带的链接和资源将会包含到JSON中. EntityModel：一个资源 CollectionModel：资源的集合 为资源添加超链接 CollectionModel.wrap(输出对象集合) 1CollectionModel&lt;EntityModel&lt;输出对象&gt;&gt; entityModels = CollectionModel.wrap(输出对象集合); 获得CollectionModel&lt;EntityModel&lt;输出对象&gt;&gt;对象 在返回资源之前，给CollectionModel&lt;EntityModel&lt;输出对象&gt;&gt;对象通过.add方法添加（名为recent，URL为这个方法访问具体URL）的关联关系 1234CollectionModel&lt;EntityModel&lt;输出对象&gt;&gt;对象.add(...//链接构建者,就是下面的 ); 这是给最顶层添加超链接 自动探知主机名，避免直接进行硬编码的方法 ```javaWebMvcLinkBuilder.linkTo(本类.class).slash(“地址1”).withRel(“关联关系名”)//URL：本类URL+/+地址1 要等于 本类本方法的一起的URL//地址1 就是从类中方法URL//.slash(“地址”) 是自动给地址前加斜杠 123456- ```java WebMvcLinkBuilder .linkTo(WebMvcLinkBuilder.methodOn(本类.class).本类中方法()) .withRel(&quot;关联关系名&quot;) //URL: 本类URL + 类中方法URL 返回CollectionModel&lt;EntityModel&lt;输出对象&gt;&gt;对象 案例部分代码123456789101112131415161718192021222324252627@RestController@RequestMapping(path = &quot;/design&quot;,produces = &quot;application/json&quot;)@CrossOrigin(origins = &quot;*&quot;)public class DesignTacoController { ... @GetMapping(&quot;/recent&quot;) public CollectionModel&lt;EntityModel&lt;Taco&gt;&gt; recentTaco(){ PageRequest page = PageRequest.of(0, 12, Sort.by(&quot;createdat&quot;).descending()); List&lt;Taco&gt; content = tacoRepository.findAll(page).getContent(); CollectionModel&lt;EntityModel&lt;Taco&gt;&gt; entityModels = CollectionModel.wrap(content); entityModels.add( WebMvcLinkBuilder.linkTo(DesignTacoController.class) .slash(&quot;recent&quot;) .withRel(&quot;abc123&quot;) ); return entityModels; } ... } 输入URL1http://localhost:8080/design/recent 部分JSON结果1234&quot;_links&quot;: { &quot;abc123&quot;: { &quot;href&quot;: &quot;http://localhost:8080/design/recent&quot; } 创建资源装配器目的把对象类变成带链接和对象的资源类，并通过一个工具类批量转换. 对象集合—&gt;工具类—–&gt;资源类集合 资源类 创建资源类 继承RepresentationModel&lt;本资源类&gt; 提供要输出的属性，并添加**@Getter**注解 创建参数是原本对象的有参构造方法 12345678910111213public class IngredientEntityModel extends RepresentationModel&lt;IngredientEntityModel&gt; { @Getter private String name; @Getter private Ingredient.Type type; public IngredientEntityModel(Ingredient ingredient) { this.name = ingredient.getName(); this.type = ingredient.getType(); }} 工具类（资源装配器） 创建工具类 继承RepresentationModelAssemblerSupport&lt;**对象**, **对象对应的资源类**&gt; 重写超类IngredientEntityModelAssembler 在创建对象对应资源类中的链接时，从控制类中获得所有URL的基础路径 ```javapublic IngredientEntityModelAssembler(Class&lt;?&gt; controllerClass, Class resourceType) {super(控制类.class, 对象对应资源类.class);} 12345678910- 重写**instantiateModel**方法 - 用**对象类**来**实例化对象对应资源类** - ```java @Override protected 对象对应资源类 instantiateModel(对象类 entity) { return new 对象对应资源类(entity); } 重写toModel方法(必须实现) 通过对象类创建对象对应资源类 设置一个self链接（由对象的id属性(主键)自动衍生出来） ```java@Overridepublic 对象对应资源类 toModel(对象类 entity) {return createModelWithId(entity.getId(), entity);} 1234567891011121314151617181920212223242526272829##### 具体使用- 返回值不再是CollectionModel&lt;EntityModel&lt;对象类&gt;&gt;，而是**CollectionModel&lt;对象对应资源类&gt;**- 创建**工具类**对象- 并调用**toModel**方法(单个对象)或者**toCollectionModel**方法(对象集合)- 调用工具类对象.add()来添加最顶层超链接- 返回工具类对象```java@GetMapping(&quot;/recent&quot;)public CollectionModel&lt;TacoEntityModel&gt; recentTaco(){ PageRequest page = PageRequest.of(0, 12, Sort.by(&quot;createdat&quot;).descending()); List&lt;Taco&gt; content = tacoRepository.findAll(page).getContent(); CollectionModel&lt;TacoEntityModel&gt; tacoEntityModels = new TacoEntityModelAssembler().toCollectionModel(content); tacoEntityModels.add( WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(DesignTacoController.class).recentTaco()).withRel(&quot;abc123&quot;) ); return tacoEntityModels;} 嵌套使用当一个资源类中有其他对象类集合时，可以通过对应其他对象相关工具类，来添加链接，也就是从对象类转化为对应资源类 引入对应工具类 1private static final IngredientEntityModelAssembler ingredientEntityModelAssembler = new IngredientEntityModelAssembler(); 在有参构造方法使用工具类中的toModel方法 1ingredientEntityModelAssembler.toCollectionModel(taco.getIngredients()); 12345678910111213141516171819public class TacoEntityModel extends RepresentationModel&lt;TacoEntityModel&gt; { private static final IngredientEntityModelAssembler ingredientEntityModelAssembler = new IngredientEntityModelAssembler(); @Getter private final String name; @Getter private final Date createdAt; @Getter private final CollectionModel&lt;IngredientEntityModel&gt; ingredients; public TacoEntityModel(Taco taco) { this.name = taco.getName(); this.createdAt = taco.getCreatedat(); this.ingredients = ingredientEntityModelAssembler.toCollectionModel(taco.getIngredients()); }} 命名嵌套式的关联关系目标1234&quot;_embedded&quot;: { &quot;tacoEntityModleList&quot;: [ ... } 要修改_embedded下面的名字 @Relation消除JSON字段名和java代码中定义的资源类名之间的耦合. 找到对应资源类 添加类级别的@Relation value：单个资源类的命名 collectionRelation：资源类集合的命名 123456@Relation(value = &quot;taco&quot;,collectionRelation = &quot;tacos&quot;)public class TacoEntityModel extends RepresentationModel&lt;TacoEntityModel&gt; { ...}//Taco资源类集合 命名=“tacos”//单个Taco资源类 命名=&quot;taco&quot; 结果1234&quot;_embedded&quot;: { &quot;tacos&quot;: [ ... } 启用数据后端服务原理使用Spring Data Rest，基于我们定义的接口自动创建REST API. 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt; 设置Spring Data REST端点的基础路径1234spring: data: rest: base-path: /路径 查看主资源(所有端点) 先设置基础路径 1234spring: data: rest: base-path: /api 然后访问 1http://localhost:8080/api 修改端点关系名和路径当为Spring Data repository创建端点的时候，Spring Data REST会尝试使用相关实体类的复数形式. 给实体类添加@RestResource rel：关系名 path：路径 123456@Data@Entity@RestResource(rel = &quot;tacos&quot;,path = &quot;tacos&quot;)public class Taco { ...} 部分功能支持 GET请求 POST PUT PATCH 案例（以ingredients实体类为例） “http://localhost:8080/api/ingredients&quot; GET:查看所有ingredients “http://localhost:8080/api/ingredients/id&quot; GET:查看id的ingredients “http://localhost:8080/api/ingredients&quot; POST:发送JSON内容创建ingredients “http://localhost:8080/api/ingredients/id&quot; DELETE:删除对应id的内容 等等 分页和排序 page：具体的页数 从0开始时第一页 size：每页的数量 sort：根据实体的某个属性对结果进行排序 特殊功能当指定page和size时，HATEOAS为我们提供第一页，下一页，上一页和最后一页的链接. 案例链接 1http://localhost:8080/api/tacos?sort=createdAt,desc&amp;size=3&amp;page=1 结果 123456789101112131415161718192021222324252627282930313233343536373839// 20210829000859// http://localhost:8080/api/tacos?sort=createdAt,desc&amp;size=3&amp;page=1{ &quot;_embedded&quot;: { &quot;tacos&quot;: [ ... ] }, &quot;_links&quot;: { &quot;first&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/tacos?page=0&amp;size=3&quot; // 第一页 }, &quot;prev&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/tacos?page=0&amp;size=3&quot; // 上一页 }, &quot;self&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/tacos?sort=createdAt,desc&amp;size=3&amp;page=1&quot; // 这一页 }, &quot;next&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/tacos?page=2&amp;size=3&quot; // 下一页 }, &quot;last&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/tacos?page=2&amp;size=3&quot; // 最后一页 }, &quot;profile&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/profile/tacos&quot; }, &quot;recents&quot;: { &quot;href&quot;: &quot;http://localhost:8080/api/tacos/recent&quot; } } ...} 添加自定义的端点当我们需要除了CRUE API以外的操作时，需要自定义端点. 如果用@RestController类解决，会有以下问题： 我们自己的控制器端点没有映射到Spring Data REST的基础路径下 在自己控制器所定义的端点中，返回资源时并不会自动包含超链接，与Spring Data REST返回的资源是不同的. 并且客户端很难从链接列表(主资源)中查找URL 新功能 可以直接从主资源路径下直接找到端点 客户端可以更好找到所有API 解决方法 新建控制类 添加类级别@RepositoryRestController 为类中所有方法的映射都添加(spring-data-rest- base-path：/路径 )的前缀 不能和@RestController共用 在方法中自定义路径以及指定返回类型（很重要） path：映射路径 produces：**”application/hal+json”** 写入响应体 给方法添加@ResponseBody 返回包装响应数据的ResponseEntity对象 123456789101112131415161718192021222324252627@RepositoryRestControllerpublic class RecentTacosController { ... @GetMapping(path=&quot;/tacos/abc/recent&quot;, produces=&quot;application/hal+json&quot;) public ResponseEntity&lt;CollectionModel&lt;TacoEntityModel&gt;&gt; recentTacos() { PageRequest page = PageRequest.of(0, 12, Sort.by(&quot;createdat&quot;).descending()); List&lt;Taco&gt; tacos = tacoRepo.findAll(page).getContent(); CollectionModel&lt;TacoEntityModel&gt; tacoResources = new TacoEntityModelAssembler().toCollectionModel(tacos); tacoEntityModels.add( WebMvcLinkBuilder .linkTo(WebMvcLinkBuilder.methodOn(DesignTacoController.class).recentTaco()) .withRel(&quot;abc123&quot;) ); return new ResponseEntity&lt;&gt;(tacoResources, HttpStatus.OK); }... //访问路径 /api/tacos/abc/recent} 为Spring Data 端点添加自定义的超链接通过声明资源处理器bean==》为Spring Data REST自动包含的链接添加继续添加链接 解决方法在上面的类继续添加 12345678910111213141516@Beanpublic RepresentationModelProcessor&lt;PagedModel&lt;EntityModel&lt;实体类&gt;&gt;&gt; tacoProcessor(EntityLinks links) { return new RepresentationModelProcessor&lt;PagedModel&lt;EntityModel&lt;实体类&gt;&gt;&gt;() { @Override public PagedModel&lt;EntityModel&lt;实体类&gt;&gt; process(PagedModel&lt;EntityModel&lt;实体类&gt;&gt; resource) { resource.add( links.linkFor(实体类.class) .slash(&quot;abc&quot;) .slash(&quot;recent&quot;) .withRel(&quot;recents&quot;)); //添加的超链接路径=基础路径+实体类的路径+/abc+/recent return resource; } };} 注意不要转Lamba，会有bug","link":"/Liust1918.githud.io/2022/12/03/Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/"},{"title":"Android入门","text":"Android Studio 1.Android开发环境搭建Android发展历程 基于Linux移动端 第一部Android手机是HTC制造 早期使用Eclipse开发APP Android Studio基于IDEA开发 搭建Android Studio开发环境 Android Studio:开发环境界面 SDK(Software Development Kit):软件开发工具包,将App源码编译成可执行的App应用 下载SDK Tools-&gt;SDK Manager 创建App项目 File-&gt;New-&gt;New Project 选择 Empty Activity 配置 Name:项目名称 Package name:包名 Save Location:项目保存地址 Language:编程语言 java Kotlin Minimun SDK:最低支持SDK版本 该版本的市场份额占多少 Use legacy android support libraries:启用旧的support支持吗(默认不要，用新的androidX库) 导入App项目/模块项目 File-&gt;Open(带绿色头) 模块 File-new-Import Module 编译App项目一般自动编译手动编译 编译整个项目:Build-&gt;Make Project 编译指定模块:Build-&gt;Make Module *** 清除模块:Build-&gt;Clean Project 重新整个项目编译:Build-&gt;Rebuild Project 运行App在模拟器上运行省略 在手机上运行 数据线连手机 打开手机的开发者选项目 启动USB调试 将手机设置为文件传输模式 允许计算机进行USB调试 修改java版本 File-&gt;Project Structure-&gt;左边Modules-&gt;Source Compatibility 2.Android App开发基础观察App的运行日志打印日志 Log.e:错误信息 Log.w:警告信息 Log.i:一般消息 Log.d:调试信息(打印变量) Log.v:冗余信息 代码实现1Log.d(&quot;MainActivity114514&quot;,&quot;我看到你了&quot;); 日志显示 点击Logcat 选择设备 测试包名 日志级别 日志包含字符串(如MainActivity114514) 选择只显示选中的应用日志(Show only selected application) 连接数据库 嵌入式数据库:SQLite 也可以直接服务器接口HTTP的方式 注意 SQLite不能被外部访问,只能和App代码相连 当使用服务器接口HTTP的时候,App代码和后端代码进行交互. 项目文件结构大的层次 项目Project 模块Module 一个项目多个模块 一般来说,运行的是模块，不是项目 具体文件 app manifests AndroidManifest.xml——App的运行配置文件 java com.example.myapplication——java源码 MainActivity com.example.myapplication(androidTest)——java测试代码 ExampleInstrimentedTest com.example.myapplication(test)——java测试代码 ExampleUnitTest java(generated) com.example.myapplication BuildConfig res——当前模块的资源文件 drawable——图形描述文件与图片文件 layout——存放App页面的布局文件 activity_main.xml mipmap——存放App的启动图标 values——常量定义文件 colors.xml——颜色常量 strings.xml——字符串常量 等 res(generated) Gradle Scripts——工程的编译配置文件 build.gradle(Project:***)——项目编译 build.gradle(Module:***)——模块编译 gradle.properties——命令行参数(不用管) gradle-wrapper.properties——Gradle工具的版本配置 progurard-rules.pro——java代码的混淆规则 gradle.properties——需要编译哪些模块 setting.gradle local.properties——项目的本地配置文件 编译配置文件项目(配置阿里云镜像)1234567891011121314151617181920212223// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript { repositories { //镜像 maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/gradle-plugin' } maven { url 'https://maven.aliyun.com/repository/public' } google() mavenCentral() } dependencies { //Gradle插件的版本号 classpath &quot;com.android.tools.build:gradle:7.0.2&quot; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }}task clean(type: Delete) { delete rootProject.buildDir} 模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849plugins { id 'com.android.application'}android { //指定编译用的SDK版本号.比如31表示使用Android 12.0编译 compileSdk 31 //指定编译工具的板块号.这里的头两位数字必须与compileSdkVersion保存一致,具体的版本号可在SDK安装目录的&quot;sdk\\build-tools&quot;下找到// buildToolsVersion &quot;30.0.2&quot; defaultConfig { //指定该模块的应用编号,也就是App的包名 applicationId &quot;com.example.myapplication&quot; //指定App适合运行的最小SDK版本号.比如19表示至少要在Android4.4上运行 minSdk 19 //指定目标设备的SDK版本号.表示App最希望在哪个版本的Android上运行 targetSdk 31 //指定App的应用版本号 versionCode 1 //指定App的应用版本名称 versionName &quot;1.0&quot; testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 }}//各种依赖dependencies { implementation 'androidx.appcompat:appcompat:1.2.0' implementation 'com.google.android.material:material:1.3.0' implementation 'androidx.constraintlayout:constraintlayout:2.0.4' testImplementation 'junit:junit:4.13.2' androidTestImplementation 'androidx.test.ext:junit:1.1.2' androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'} AndroidManifest.xml——运行配置文件 manifest标签 package:包名 application标签 allowBackup——是否允许备份 icon——手机屏幕上显示图标 roundIcon——圆角图标 supportsRtl——支付支持从右往左的文字排序顺序(例如阿拉伯文,波斯语..) theme——指定App的显示风格 ```xml 12345678910111213141516171819202122232425262728293031## 界面设计和代码逻辑### App前后端分离设计- **XML文件负责描述App界面(**例如:activity_main.xml)- **界面布局可复用**- **java代码适配多个界面布局**## XML文件负责应用界面设计### xml结构- **根节点** - **布局节点** - **控件节点**### 特点- **一个界面一个根节点,多个布局节点(也可没有布局节点)**- **根节点必备(布局节点不能用):** ```xml xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; 指定XML内部的命名空间 检查各个节点命名是否合法 简单TextView控件 android:id：控件id android:layout_width:控件布局宽度 wrap_content:刚好包住控件内容 match_parent:由父节点决定大小 android:layout_height:控件布局高度 wrap_content:刚好包住控件内容 match_parent:由父节点决定大小 android:text:控件的文本 例子12345678910111213141516 &lt;!--LinearLayout布局的根节点--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--LinearLayout布局的布局节点--&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--控件TextView--&gt; &lt;TextView android:id=&quot;@+id/tv_hello&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello 我的程序&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; java写代码逻辑把java文件和xml绑定创建java类 继承AppCompatActivity 重写onCreate方法 ```setContentView(R.layout.XML布局文件); 123456789101112```javapublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //引用xml布局文件 (res/layout/activity_main.xml) //也就是这个java文件对应这个xml布局 setContentView(R.layout.activity_main); }} 修改XML内容 ```javaTextView viewById = findViewById(R.id.XML文件中控件节点id);1232. ```java viewById.setText(&quot;内容&quot;); 123456789101112131415public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //引用xml布局文件 (res/layout/activity_main.xml) //也就是这个java文件对应这个xml布局 setContentView(R.layout.activity_main); //从上面布局文件中取出android:id=&quot;@+id/tv_hello&quot; 的TextView控件 TextView viewById = findViewById(R.id.tv_hello); //再设置其新的文字内容 viewById.setText(&quot;你好，傻逼,卧槽我不好说&quot;); }} APP的活动页面手动创建App页面创建XML文件 res/layout—&gt;New—&gt;XML—&gt;Layout XML File 创建java代码 创建java文件,继承AppCompatActivity 重写OnCreate ```javasetContentView(R.layout.XML页面); 123456789#### 注册页面配置- 前往AndroidManifest.xml文件- 在application标签下添加- ```xml &lt;activity android:name=&quot;.对应java文件&quot; /&gt; 快速生成页面源码 java源码文件—&gt;New—&gt;Activity—&gt;Empyt Activity 配置页面 Activity Name:页面的java类名 Layout Name：XML文件名 跳到另一个页面 在java文件 ```java// 活动页面跳转(A跳到B) startActivity(new Intent(A.this,B.class)); 1234- ```java // 活动页面跳转（本类-&gt;目标类） startActivity(new Intent(this,目标类.class)); 3.简单控件3.1文本显示(TextView)3.1.1文本内容修改XML1android:text=&quot;内容&quot; java代码控制 xml中TextView控件id 1android:id=&quot;@+id/id设置&quot; 获得控件对象 1TextView id = findViewById(R.id.控件id); 设置文本内容 1id.setText(&quot;文本显示内容&quot;); 引用全局String 找到res-&gt;values-&gt;strings.xml 设置全局字符串 123&lt;resources&gt; &lt;string name=&quot;标签&quot;&gt;全局内容&lt;/string&gt;&lt;/resources&gt; 在XML设置 1android:text=&quot;@string/标签&quot; 或者在java代码中引用 1R.string.标签 3.1.2文本大小三字体 px 手机屏幕的最小显示单位 显示屏有关 dp（dip） 与设备无关的显示单位 屏幕尺寸有关 sp 专门设置字体大小 可以通过手机系统设置调整字体大小(小,标准,大,超大) 设置标准,则sp=dp 设置小/大,sp会小大. 修改XML 直接修改文本显示控件 1android:textSize=&quot;30px&quot; java代码实现 XML设置控件Id 找到文本显示控件 1TextView viewById3 = findViewById(R.id.控件id); 调用控件的setTextSize()方法 12viewById.setTextSize(30);//默认使用sp，也就是现在是30sp 3.1.3文本颜色Android颜色编码 **透明度alpha和RGB三原色(红色red,绿色green,蓝色blue)**定义 0x代表十六进制数 八位十六进制数FFEEDDCC FF：透明度 FF：完全不透明 00：完全透明 EE：红色浓度 DD：绿色浓度 CC：蓝色浓度 RGB三原色数值 越大颜色越深越暗 越小颜色越浅越深 三个00：白色 三个FF：黑色 六位十六进程数EEDDCC 透明度 在XML文件==透明度FF 在代码==透明度00 EE：红色浓度 DD：绿色浓度 CC：蓝色浓度 修改xml（记得前缀加#） 在控件中 EEDDCC 1android:textColor=&quot;#00ff00&quot; FFEEDDCC 1android:textColor=&quot;#ff00ff00&quot; java代码实现(颜色前面都要0x) 获得控件对象 1TextView viewById1 = findViewById(R.id.myTextView_code_six); 调用setTextColor() ```javaviewById1.setTextColor(0x00ff00);//在java代码默认透明度:00123- ```java viewById2.setTextColor(0xff00ff00); 设置全局color变量（记得前缀加#） 找到color全局文件:res-&gt;values-&gt;colors.xml 设置全局颜色 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;标签&quot;&gt;#FFBB86FC&lt;/color&gt;&lt;/resources&gt; 修改XML 1android:textColor=&quot;@color/标签&quot; 或者java代码 1控件.setTextColor(R.color.标签); 3.1.4背景颜色/背景图片设置设置背景颜色 设置背景颜色 1android:background=&quot;@color/标签&quot; 设置背景图片 存放图片到res-&gt;drawable-&gt;图片 XML引用 1android:background=&quot;@drawable/不包含拓展名的图片名称&quot; java代码引用 1控件对象.setBackgroundResource(R.drawable.不包含拓展名的图片名称) 3.2视图基础3.2.1设置视图的宽高三大取值 match_parent:由上级视图决定.上级多大当前多大. wrap_content:刚好包住控件内容，不超过上级视图宽/高,超过会隐藏 dp单位:固定 设置XML android:layout_width:控件布局宽度 android:layout_height:控件布局高度 java代码修改 获得控件对象 对象getLayoutParams方法获得参数类型ViewGroup.LayoutParams的对象 调用属性值，修改控件的宽高 调用控件对象的setLayoutParams，填入布局参数. 12345678910111213141516171819202122public class MainActivity_Simple_Unit extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { ...TextView viewById3 = findViewById(R.id.tv_code); ViewGroup.LayoutParams layout = viewById3.getLayoutParams(); layout.width=dip2px(this,300); viewById3.setLayoutParams(layout); ... } //根据手机的分辨率从dp的单位转为px public static int dip2px(Context context, float dpValue) { //获取当前的手机的像素（1个dp对应几个px） float density = context.getResources().getDisplayMetrics().density; return (int)(dpValue* density +0.5f); }} 3.2.2设置视图的间距适用范围 视图 控件 布局 View,ViewGroup,控件,布局的继承关系 View 控件 ViewGroup 布局 间距设置是View中的属性,所以可以视图，控件，布局通用. 当前视图和外部视图的间距margin android:layout_margin 四个方向 android:layout_marginTop 顶 android:layout_marginBottom 底 android:layout_marginLeft 左 android:layout_marginRight 右 android:layout_marginHorizontal 左右 android:layout_marginVertical 上下 当前视图和内部视图的间距padding android:layout_padding 四个方向 android:layout_paddingTop 顶 android:layout_paddingBottom 底 android:layout_paddingLeft 左 android:layout_paddingRight 右 android:layout_paddingHorizontal 左右 android:layout_paddingVertical 上下 3.2.3设置视图的对齐方式当前视图往上级视图对齐1android:layout_gravity=&quot;对齐方向&quot; top bottom left right 叠加方法:某一方向|某一方向 例如:左下:left|bottom 视图内部对齐1android:gravity=&quot;对齐方向&quot; top bottom left right 叠加方法:某一方向|某一方向 例如:左下:left|bottom 3.3布局3.3.1线性布局LinearLayout上下/左右排控件 控制方向orientation1234&lt;LinearLayout android:orientation=&quot;方向&quot;&gt; &lt;!--控件--&gt; &lt;/LinearLayout&gt; 垂直排：vertical 水平排：horizontal（默认） 通过权重分割控件layout_weight在LinearLayout下,不同控件设置layout_weight. 比如两个控件都设置1，那么这两个控件会按垂直/水平方向分成1：1 1android:layout_weight=&quot;权重值&quot; 限制:如果按水平分，就把本控件android:layout_width设置成0dp. 同理,按垂直分，就把本控件android:layout_height设置成0dp. 3.3.2相对布局RelativeLayout子视图由其他视图决定. (如果不设置子视图,则默认显示在左上角) 相对位置的属性取值 相对位置说明 layout _ toLeftOf 当前视图在指定视图的左边 layout _ toRightOf 当前视图在指定视图的右边 layout _ above 当前视图在指定视图的上方 layout _ below 当前视图在指定视图的下方 layout _ alignLeft 当前视图与指定视图的左侧对齐 layout _ alignRight 当前视图与指定视图的右侧对齐 layout _ alignTop 当前视图与指定视图的顶部对齐 layout _ alignBotom 当前视图与指定视图的底部对齐 layout _ centerInParent 当前视图在上级视图中间 layout _ centerHorizontal 当前视图在上级视图的水平方向居中 layout _ centerVertical 当前视图在上级视图的垂直方向居中 layout _ alignParentLeft 当前视图与上级视图的左侧对齐 layout _ alignParentRight 当前视图与上级视图的右侧对齐 layout _ alignParentTop 当前视图与上级视图的顶部对齐 layout _ alignParentBotom 当前视图与上级视图的底部对齐 与上级视图直接指定本视图的父视图对齐 12345&lt;TextView ... android:layout_alignParentBottom=&quot;true&quot; ... /&gt; 指定视图指定其他视图id，和它对齐. 12345&lt;TextView ... android:layout_toLeftOf=&quot;@+id/其他视图标签&quot; ... /&gt; 3.3.3网格布局GridLayout多行多列布局 方向 从左到右， 从上到下, 塞满第一排后，塞第二排 设置行和列数 android:columnCount=”列数” android:rowCount=”行数” 3.3.4滚动视图ScrollView左右/上下滑出内容 垂直/水平滚动视图 ScrollView：垂直 HorizontalScrollView:水平 规则设置那个方向，另一个方向的就设置wrap_content (例如:滑动垂直,android:layout_width:wrap_content android:layout_height:match_parent) 滚动视图节点下面只能有一个子布局节点内容少不够满屏滚动视图没有满屏幕，但是又想它满. 12android:layout_height=&quot;match_parent&quot;android:fillViewport=&quot;true&quot; 3.4按钮控件3.4.1按钮控件ButtonButton继承与View类,所以所有控件和布局都可以适用 设置大写/不大写textAllCaps默认按钮中间内容全大写，并且居中 true:大写 false:不转为大写 激活方法onClick当用户点击按钮,就激活方法 android:onClick:”java代码的方法名” 可用状态setEnabled 不可用按钮 不允许点击 文字灰色 可用按钮 允许点击 文字正常黑色 修改xml android:setEnabled true:启用 false:弃用 java代码 控件.setEnable(true/false); 3.4.2建立点击/长按监听器一般开发不适用上面的直接指明方法 按钮对象注册统一点击监听器 在java代码中 本类继承接口View.OnclickListener 重写onClick方法 在主方法中,按钮控件对象.setOnClickListener(监听器类(继承接口OnClickListener的类)这里填this) 在onClick方法中,调用View.getid获得控件id. 与需要的控件id进行对比（R.id.控件id） 执行 12345678910111213141516171819202122232425262728293031323334//继承接口View.OnclickListenerpublic class MainActivity_Button extends AppCompatActivity implements View.OnClickListener{ private TextView btn_test; //重写onClick方法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main_button); TextView id = findViewById(R.id.btn_test); this.btn_test=id; //按钮控件对象.setOnClickListener(监听器类(继承接口OnClickListener的类)) btn_test.setOnClickListener(this); } @Override public void onClick(View view) { //调用View.getid获得控件id.只要一点击就可以获得 //与需要的控件id进行对比（R.id.控件id） if(view.getId()==R.id.btn_enable){ btn_test.setTextColor(Color.BLACK); btn_test.setEnabled(true); }else if(view.getId()==R.id.btn_test){ TextView viewById = findViewById(R.id.btn_result); String format = String.format(&quot;%s 你点击了按钮: %s&quot;,new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()),((Button)view).getText()); viewById.setText(format); } }} 长按钮监听当控件被按住**500毫秒(ms)**才会触发事件 基本流程和上面差不多,但是有几点不同 类要继承接口View.OnLongClickListener 重写onLongClick方法 控件监听设置setOnLongClickListener 3.5图像显示控件3.5.1图像视图ImageView显示图片存放图片到res-&gt;drawable 修改XML1android:src=&quot;@drawable/不带拓展名的图片名称&quot; java代码实现1ImageView控件对象.setImageResource(R.drawable.不含拓展名的图片名称) 图片缩放scaleTypeImageView默认图片 居中显示 fitCenter放缩 图片缩放类型 XML缩放类型 java代码ScaleType类型 说明 fitCenter FIT _ CENTER 保持宽高比例,缩放图片使其位于视图中间(只缩小) centerInside CENTER _ INSIDE 保持宽高比例,缩小图片使之位于视图中间(只缩小不放大) center CENTER 保持图片原尺寸,并使其位于视图中间(不放大不缩小) centerCrop CENTER _ CROP 缩放图片使其充满视图(超出部分会被裁剪),并位于视图中间 fitXY FIT _ XY 缩放图片使其正好填满视图(图片可能被拉伸变形) fitStart FIT _ START 保持宽高比例,缩放图片使其位于视图上方或左侧 fitEnd FIT _ END 保持宽高比例,缩放图片使其位于视图下方或右侧 XML实现1android:scaleType=&quot;XML放缩类型&quot; java代码实现1ImageView控件.setScaleType(ImageView.ScaleType.缩放类型) 3.5.2图像按钮ImageButtonImageButton和Button区别ImageButton继承ImageView，不是继承Button Button即可显示图片和文字,ImageButton不能 ImageButton图片按比例缩放,Button用fitXY方式无法按比例缩放 Button只能显示一张图片,ImageButton可显示前景和背景 ImageButton实现例子： 默认center缩放类型 (如果图片太大无法显示，就用fitCenter) 123456&lt;ImageButton android:id=&quot;@+id/image_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:src=&quot;@drawable/apple&quot; android:scaleType=&quot;fitCenter&quot;/&gt; 3.5.3Button同时展示文本与图像实现在图片按钮中不仅有文字还有图片，而且可控制文件在图片的位置 1234567&lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:drawableTop=&quot;@drawable/ic_about&quot; android:drawablePadding=&quot;5dp&quot; android:text=&quot;图标在上&quot; /&gt; 文字在图片的方向以及间距 drawableTop：文字在图片上方 drawableBottom：文字在图片下方 drawableLeft：文字左边的图片 drawableRight：文字右边的图片 drawablePadding：图片与文字的间距 Other提示框Toast.makeTex展示短暂的提示文字. 1Toast.makeText(当前页面实例(一般this),提示内容,停留时间).show(); 停留时间 Toast.LENGTH_SHORT:2秒后消失 Toast.LENGTH_LONG:3.5秒消失 4.四大组件之一活动Activity4.1活动页面4.1.1活动和页面的概念页面是静态的，活动是动态的,用户看到的页面是静态的,用户使用起来像活动. 所以一个页面是一个活动,下面的描述的打开一个页面其实本质上是启动一个活动,关闭页面本质上是关闭一个活动. 4.1.2Activity的启动和停止 startActivity（Intent对象）:一般用于跳转页面 finish():一般用于结束本页面 4.1.3Activity的生命周期 onCreate:创建活动 页面布局加载到内容. onStart:开启活动 页面显示在屏幕 onResume:恢复活动 能正常交互 onPause:暂停活动 无法与用户交互 onStop:停止活动 不显示页面在屏幕 onDestroy:销毁活动 从内存中清除 onRestart:重启活动 处于停止状态，重新启动,不走onCreate方法 onNewIntent:重用已有的活动实例 重用实例 4.1.4Activity的启动模式Android给每个活动页面分配进栈中, 一个活动页面遵循先进后出的规则. 每次创建活动页面的时候会选择一种出入栈的行为(启动模式)，默认为栈的先进后出规则. 配置文件设置表示本活动以哪个启动模式运行 修改AndroidManifest.xml文件 指定activity节点添加属性android:launchMode 1234&lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;standard&quot;&gt; lauchMode属性说明 代码设置表示后续打开的活动页面采用该启动标注. 调用Intent对象中的setFlags方法 12Intent intent = new Intent(this, MainActivityButtonB.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); 启动标注取值 应用:两个活动之间交替跳转两个页面相互跳，不会像出入栈那样. 避免无谓的重复返回，只会在活动A和活动B之间跳转 解决方法在活动A和活动B都设置标志FlAG_ACTIVITY_CLEAR_TOP 应用:登陆成功后不再返回登陆页面到登陆成功页面后，清空前面不应该回去(获取验证码,找回验证码等页面)的栈. 解决方法:登陆成功活动页面设置FlAG_ACTIVITY_CLEAR_TASK | FLAG_ACTIVITY_NEW_TASK (一个清空栈，一个新生产栈) 12345678@Override public void onClick(View view) { ... Intent intent = new Intent(this, MainActivitySuccessfulLogin.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); ... } } 4.2Intent在活动之间传递消息4.2.1Intent概念和组成概念Intent的意思是意图 作用负责android任意东西之间的相互通信 本次通信从哪里来，去到哪里，怎么走 发送方携带数据内容，接收方从意图Intent中解析数据 接收方接收意图Intent后，返回应答数据给前面的发送方. 组成 属性 方法 用途 Component setComponent 组件(来源和目标) Action setAction 动作(动作行为) Data setData Uri(动作要操作的数据路径) Category addCategory 类别(操作类别) Type setType 数据类型 Extras putExtras 拓展信息(装载的包裹信息) Flags setFlags 标志位(活动的启动标注) 4.2.2显式Intent和隐式Intent显式Intent(指定来源活动和目标活动-精准匹配) Intent构造方法 1Intent intent = new Intent(this, MainActivityIntentSuccessful.class); Intent对象中的setClass(来源,目标) 12Intent intent = new Intent();intent.setClass(this,MainActivityIntentSuccessful.class); Intent对象的setComponent(来源,目标) 123Intent intent = new Intent();ComponentName componentName = new ComponentName(this,MainActivityIntentSuccessful.class);intent.setComponent(componentName); 隐式Intent(匹配AndroidManifest中的活动-模块查询)隐式Intent不指明源活动和目标活动.（可以唤醒外部app） 只会去匹配AndroidManifest.xml中的每个活动中Intent-filter标签的category,action,data. 从某种程度上起到过滤作用. 12345678&lt;activity android:name=&quot;.MainActivityIntentSuccessful&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;MyTest&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 隐式Intent的Intent-filter属性Action(必须)常见动作 自定义动作 android:name=”自定义名” category android:name=”android.intent.category.DEFAULT” (必须) 12345678&lt;activity android:name=&quot;.MainActivityIntentSuccessful&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;MyTest&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; Category(可选,可设置多个)更加详细匹配 Data(可选)更加详细匹配 例子12345Intent intent = new Intent();intent.setAction(Intent.ACTION_DIAL);Uri parse = Uri.parse(&quot;tel:&quot; + &quot;123456&quot;);intent.setData(parse);startActivity(intent); 效果 点击后会跳转到拨打电话界面,并且已经输入123456. 4.2.3把数据发送到下一个活动Intent存放数据支持数据类型 基本数据类型 Serializable序列化结构 Bundle对象存放到IntentBundle像包裹一样存放在Intent 使用Map映射存放数据 putExtras(Bundle对象) 发送方 得到Intent对象 新建Bundle对象 将数据内容装入Bundle对象 调用Intent对象的putExtras()装入Bundle对象 将Intent对象调如startActivity中 123456Intent intent = new Intent(this, GetNextActivity.class);Bundle bundle = new Bundle();bundle.putString(&quot;time&quot;, new Date().toString());bundle.putString(&quot;content&quot;, &quot;测试&quot;);intent.putExtras(bundle);startActivity(intent); 接收方 直接调用getIntent()方法得到Intent对象 调用Intent对象中的getExtras()方法，得到Bundle对象 通过getXXX(key,value)得到值 1234Bundle extras = getIntent().getExtras();String time = extras.getString(&quot;time&quot;);String content = extras.getString(&quot;content&quot;);String input=String.format(&quot;收到请求消息:\\n请求时间为%s\\n请求内容为%s&quot;,time,content); 4.2.4数据发送到下个活动后返回数据到上一个活动这个活动页面把数据发到下个活动页面，然后返回内容给上一个页面. 发送方步骤一startActivityForResult 发送内容装入Bundle对象中，再把Bundle对象装入Intent对象中 将Intent对象装入startActivityForResult中 设置startActivityForResult(应答数据，标识每个跳转的唯一请求代码) 123456Intent intent = new Intent(this, SendNextAndReturnResultActivity.class);Bundle bundle = new Bundle();bundle.putString(&quot;time&quot;,new Date().toString());bundle.putString(&quot;content&quot;,&quot;测试&quot;);intent.putExtras(bundle);startActivityForResult(intent,0); 步骤四 重写onActivityResult方法 判断 requestCode:上面的标识每个跳转的唯一请求代码 resultCode:判断上个页面是否处理成功 Activity.RESULT_OK Activity.RESULT_CANCELED Intent:Intent对象不为空 从Intent中获得Bundle对象，再获得数据内容. 123456789101112131415161718/** * 从下一个页面携带参数返回到当前页面时触发 * @param requestCode * @param resultCode * @param data */@Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if(data!=null&amp;&amp;requestCode==0&amp;&amp;resultCode==Activity.RESULT_OK){ Bundle extras = data.getExtras(); String time = extras.getString(&quot;time&quot;); String content = extras.getString(&quot;content&quot;); String format = String.format(&quot;收到返回信息:\\n应答时间为%s\\n应答内容为%s&quot;, time, content); TextView textView =findViewById(R.id.MyText); textView.setText(format); }} 接收方步骤二 直接调用getIntent()方法得到Intent对象 调用Intent对象中的getExtras()方法，得到Bundle对象 通过getXXX(key,value)得到值 1234Bundle extras = getIntent().getExtras();String content = extras.getString(&quot;content&quot;);String time = extras.getString(&quot;time&quot;);String input = String.format(&quot;收到请求消息:\\n请求时间为%s\\n请求内容为%s&quot;, time, content); 步骤三setResult 创建Intent对象 创建Bundle对象 将数据内容装入Bundle对象 调用Intent对象的putExtras装入Bundle对象 调用setResult（应答代码(成功/失败)，Intent对象） 123456Intent intent = new Intent();Bundle bundle = new Bundle();bundle.putString(&quot;content&quot;,response);bundle.putString(&quot;time&quot;,new Date().toString());intent.putExtras(bundle);setResult(Activity.RESULT_OK,intent); 4.3除Intent之外添加消息4.3.1设置全局字符串 设置string.xml中key-value 代码调用:R.id.key xml调用:@string/key 4.3.2用元数据传递配置信息设置 在AndroidManifest.xml文件设置meta-data 设置meta-data的android:name以及android:value 123456&lt;activity android:name=&quot;.addActivity&quot; android:exported=&quot;true&quot; &gt;&lt;!-- &lt;meta-data android:name=&quot;weather&quot; android:value=&quot;晴天&quot;/&gt;--&gt; &lt;meta-data android:name=&quot;weather&quot; android:value=&quot;@string/weather&quot;/&gt; &lt;/activity&gt; 调用 获取当前应用的包管理器 调用包管理器的getActivityInfo方法获得当前活动的信息对象 调用getActivityInfo的metaData方法获得Bundle对象 123456789101112131415//用元数据显示字符串资源public void showStringResourceForMeta_data(){ try { //获取应用的包管理器 PackageManager packageManager = getPackageManager(); //从应用包管理器中获取当前的活动信息 ActivityInfo activityInfo = packageManager.getActivityInfo(getComponentName(), PackageManager.GET_META_DATA); //获取活动附件的元数据信息 Bundle metaData = activityInfo.metaData; String weather = metaData.getString(&quot;weather&quot;); textView.setText(&quot;来着元数据:今天的天气是&quot;+weather); } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); }} 4.3.3给应用页面注册快捷方式效果 创建shortcuts.xml配置资源文件shortcut标签 属性 说明 shortcutId 快捷方式的编号 enabled 是否启用 icon 快捷菜单左侧的图标 shortcutShortLabel 快捷菜单短名称 shortcutLongLabel 快捷菜单长名称(优先展示,放不下才显示短名称) intent标签点击菜单后跳转内容由Intent节点决定 属性 说明 cation 固定为android.intent.action.VIEW targetPackage 固定为当前App的包名 targetClass 活动页面类的完整路径 categories标签 属性 说明 name 固定android.shortcut.conversation 123456789101112131415&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;shortcut android:shortcutId=&quot;first&quot; android:enabled=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:shortcutShortLabel=&quot;@string/first_short&quot; android:shortcutLongLabel=&quot;@string/first_long&quot; &gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:targetPackage=&quot;com.example.type_4_chapter&quot; android:targetClass=&quot;com.example.type_4_chapter.addActivity&quot;/&gt; &lt;categories android:name=&quot;android.shortcut.conversation&quot;&gt;&lt;/categories&gt; &lt;/shortcut&gt;&lt;/shortcuts&gt; 在AndroidManifest.xml设置meta-data中的resource配置只能在主页的活动页面设置 到AndroidManifest.xml中设置meta-data name设置android.app.shortcuts resource设置成调用上面的xml文件 1234567&lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;standard&quot;&gt; ... &lt;meta-data android:name=&quot;android.app.shortcuts&quot; android:resource=&quot;@xml/shortcuts&quot;/&gt;&lt;/activity&gt; 5.中级控件5.1定制简单图形5.1.1图形基本概念Drawable类分类所有能显示的图片(图片，色块，画板，背景等) 图片文件以及图片保存目录包含图片的图片文件都保存在res/drawable中 描述性的XML文件 图片文件存放各种分辨率 drawable-ldpi:低分辨率(240x320) drawable-mdpi:中分辨率(320x480) drawable-hdpi:高分辨率(480x800) drawable-xhdpi:加高分辨率(720x1280) drawable-xxhdpi：超高分辨率(1080x1920) drawable-xxxhdpi：超超高分辨率(1440x2560) 工作方式当图片文件在drawable的同目录下，android会根据手机的分辨率分别适配对应文件夹的图片. 手机分辨率就高不就低，分辨率低了，android会强行拉伸图片分辨率，就会感觉图片很模糊. 图片引用方式 java代码方式:R.drawable.文件名 xml方式：@drawable/不会拓展名的图片文件. 5.1.2形状图形(Shape图片)以shape为根节点的XML文件，存在在drawable目录下. shape size（尺寸） stroke（描边） conrners（圆角） solid（填充） padding（间隔） gradient（渐变） shape（形状） shape：字符串类型,描述形状 形状类型 说明 rectangle 矩形.（默认） oval 椭圆.(corners节点失效) line 直线.（必须设置stroke节点） ring 圆环 size(尺寸)描述宽高尺寸(若无size，则与宿主视图一样大小) height:px类型，高度 width:px类型,宽度 stroke(描边)图形的描边规格 color：颜色类型，描边颜色 dashGap：px类型，每段虚线之间的间隔.为0则为实线 dashWidth：px类型，每段虚线的宽度.为0则为实线 width:px类型,描边的厚度 corners（圆角）图片的圆角大小 bottomLeftRadius：px类型,左下角圆角的半径 bottomRightRadius：px类型,右下圆角的半径 topLeftRadius:px类型,左上圆角的半径 topRightRadius：px类型,右上圆角的半径 radius：px类型，4个格圆角的半径 solid（填充）填充颜色 color：颜色类型，内部填充的颜色. padding（间隔）图片和周围边界的间隔（不设置就没有间隔） top：px类型 bottom：px类型 left：px类型 right：px类型 gradient（渐变）图片的颜色渐变 angle：整型,渐变的起始角度. 值为0时，是从9点钟方向开始渐变 以此类推逆时针(90对应6点钟,180对应3点钟,270对应0/12点钟) type：字符串类型，渐变类型 linear：线性渐变(默认) radial：放射渐变（起始颜色时圆心颜色） sweep：滚动渐变(一个线段以某个端点为圆心做360度旋转) centerX：浮点型，圆心渐变起点的X起点(0.5为中心) centerY：浮点型，圆心渐变起点的Y起点(0.5为中心) gradientRadius：整型，渐变的半径.(type=radial时才需要设置) centerColor：颜色类型，渐变的中间颜色 startColor：颜色类型，渐变的起始颜色 endColor：颜色类型，渐变的终止颜色. useLevel：布尔类型 true：无渐变色 false：为有渐变色 创建和使用方法 在drawable目录下创建Drawable resource file 修改根节点(Root element)为shape 生成XML文件 在使用的java文件中设置背景即可. 5.1.3九宫格图片解决问题 图片设置成背景后，如果图片尺寸太小，系统会自动拉伸造成模糊 设置文字从图片的某个位置输入. 九宫格文件本质上时通过 拉伸图片时，只拉伸内部区域，不拉伸边缘线条完成的. 创建九宫格文件九宫格创建 把XXX.png的图片文件加入drawable文件 右键图片,选择Create 9-Patch files 得到XXXX.9.png的九宫格文件 删除原来的XXX.png的图片 九宫格效果 4条黑线 顶部：在水平拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸 左边：在竖直拉伸的时候，保持其他位置不动，只在这个点的区域做无限的延伸 底部：在水平拉伸的时候，指定图片里的内容显示的区域 右边：在竖直拉伸的时候，指定图片里的内容显示的区域 5.1.4状态列表图形用途图片文件一般时静态的，我们需要用到动态图片. 本质根据触摸情况的不同，更换不同图片. 在XML文件中规定不同状态所呈现的图片列表. 使用方式 在drawable目录中，创建Drawable resource file 选择根节点(root element)为selector 设置不同item设置不同图片/颜色 item的属性以及设置图片/颜色例子item的属性 状态类型 说明 适用控件 state_pressed 是否按下 Button state_checked 是否勾选 CheckBox,RadioButton state_focused 是否获取焦点 EditText state_selected 是否选中 ** 没有 默认情况 ** 设置图片/颜色例子12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/shape_edit_focus&quot; /&gt; &lt;item android:drawable=&quot;@drawable/shape_edit_normal&quot;/&gt;&lt;/selector&gt; 默认情况,显示shape_edit_normal图片 按下的时候，显示shape_edit_focus图片 用状态列表图片的时候，只需要设置组件的background或者color就行了. 5.2选择按钮抽象按钮CompoundButton 应用CompoundButton是CheckBox.Radio,Switch的抽象类 CompoundButton属性下面继承的类都可以用一下的属性 XML文件属性 checked：勾选状态(默认未勾选)true是勾选，false是未勾选 button：左侧勾选图标的图形资源（默认系统图标） java代码的方法 setChecked：设置按钮的勾选状态 setButtonDrawable：设置左侧勾选图标的图形资源. setOnCheckedChangeListener：设置勾选状态变化的监听器 isChecked：判断按钮是否勾选 勾选状态监听器OnCheckedChangeListener 继承CompoundButton.OnCheckedChangeListener类- RadioGroup.OnCheckedChangeListener- CompoundButton.OnCheckedChangeListener 重写onCheckedChanged方法 让抽象类CompoundButton下面的实现类设置监听setOnCheckedChangeListener(this) 12345678910111213141516171819202122public class MyCheckBox extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_check_box); //获得CheckBox对象 CheckBox checkBox =findViewById(R.id.ch_system); //调用CheckBox对象的setOnCheckedChangeListener方法进行监视 checkBox.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) { if(compoundButton.getId()==R.id.ch_system){ String format = String.format(&quot;你%s了这个CheckBox&quot;, isChecked ? &quot;勾选&quot; : &quot;取消勾选&quot;); compoundButton.setText(format); } }} 复选框CheckBox效果 XML实现 CheckBox标签 checked:是否选择 123456&lt;CheckBox android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/ch_system&quot; android:checked=&quot;false&quot; android:text=&quot;这是系统的CheckBox&quot;/&gt; 开关按钮SwitchSwitch像个高级级别的CheckBox 效果 XML实现 Switch标签 textOn：设置右侧开启时的文本 textOff：设置左侧关闭时的文本 track：设置开关轨道的背景 thumb：设置开关标识的图标 1234567&lt;Switch android:id=&quot;@+id/toMySwitch&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;30dp&quot; android:textOn=&quot;开启textOn&quot; android:textOff=&quot;关闭textOff&quot; /&gt; 仿IOS的开关按钮借助状态列表图形,设置选中与未选中时候的开关图标. 效果 XML实现 将状态列表图片放background button的图标太小了,所以设置为空.不适用默认图标 1234567&lt;CheckBox android:id=&quot;@+id/toMyiOSOfSwitch&quot; android:layout_width=&quot;60dp&quot; android:layout_height=&quot;30dp&quot; android:background=&quot;@drawable/myios&quot; android:button=&quot;@null&quot; /&gt; 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot; android:drawable=&quot;@drawable/switch_on&quot;/&gt; &lt;item android:drawable=&quot;@drawable/switch_off&quot;/&gt;&lt;/selector&gt; 单选择按钮RadioButton效果 RadioGroup和线性布局的区别RadioGroupRadioGroup本质是个布局，同一组RadioButton需要放在同一个RadioGroup布局下. RadioGroup也可以挂其他组件. 区别 RadioGroup可以管理RadioButton,线性布局不行 默认orientation属性是垂直排序，线性布局默认是水平 XML实现 RadioGroup orientation RadioButton 123456789101112131415161718&lt;RadioGroup android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/MyRadioGroup&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RadioButton android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/rb_male&quot; android:layout_weight=&quot;1&quot; android:text=&quot;男&quot;/&gt; &lt;RadioButton android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/rb_female&quot; android:layout_weight=&quot;1&quot; android:text=&quot;女&quot;/&gt;&lt;/RadioGroup&gt; java代码与监视器java代码 check：选中指定资源编号的单选按钮 getCheckedRadioButtinId：获取已选中单选按钮的资源编号 setOnCheckedChangeListener：设置单选按钮勾选变化的监听器. 监视器OnCheckedChangeListener是监视RadioGroup,而不是RadioButton. 所以只有点击同一组的其他RadioButton，才会监听到被选中. 5.3文本输入编辑框EditText相当于输入框，继承TextView 属性 inputType：指定输入的文本类型.(可以用:”|”拼接各种类型) maxLength：文本最大长度 hint：提示文本内容 textColorHint：提示文本颜色 inputType输入类型 输入类型 说明 text 文本 textPassoword 文本密码 number 整型数 numberSigned 带符号的数字(允许”-“开头) numberDecimal 带小数点的数字 numberPassword 数字密码 datetime 时间日期格式（允许横线，斜杠，空格，冒号） date 日期格式(允许”-“和”/“) time 时间格式(允许”；”) XML代码123456&lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;textPassword&quot; android:maxLength=&quot;8&quot; android:text=&quot;请输入密码&quot;/&gt; 输入和未输入的颜色变化设置使用状态列表图形以及background 创建根节点selector的xml文件在drawable 一个图形设置默认 1&lt;item android:drawable=&quot;@drawable/shape_edit_normal&quot;/&gt; 一个图形设置获得焦点时刻(state_focused)就改变图片 1&lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/shape_edit_focus&quot; /&gt; 设置对应EditText标签下面的backgroud为@drawable/状态列表图形 1234&lt;EditText... android:hint=&quot;我的边框是圆角&quot; android:background=&quot;@drawable/edittext_selector&quot;/&gt; 焦点变更监听器OnFocusChangeListenerEditText无法设置minlength属性.我们可以通过焦点变更监听器实现. EditText点击触发事件说明 第一次点击：触发焦点变更事件(光标在不同编辑框切换就会触发) 第二次点击：触发点击事件 当切换焦点(也就是第一次点击)的时候，就检查EditText的长度是否符合. 使用方式 类实现View.OnFocusChangeListener 重写onFocusChange方法 给EditText组件添加setOnFocusChangeListener（this） 123456789101112131415161718192021222324252627282930//类实现View.OnFocusChangeListenerpublic class LoginFocusChange extends AppCompatActivity implements View.OnFocusChangeListener { private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login_focus_change); //给EditText组件添加setOnFocusChangeListener（this） EditText view = findViewById(R.id.MyPassword); view.setOnFocusChangeListener(this); editText = findViewById(R.id.MyPassword); } //重写onFocusChange方法 @Override public void onFocusChange(View view, boolean hasFocus) { if(view.getId()==R.id.MyPassword&amp;&amp;hasFocus){ String s = editText.getText().toString(); if (TextUtils.isEmpty(s) || s.length() &lt; 11) { //重回密码的光标 editText.requestFocus(); Toast.makeText(this,&quot;请输入11位手机号码&quot;,Toast.LENGTH_SHORT).show(); } } }} 文本变化监听器当用户输入位数达到后自动关闭键盘. 关闭软键盘输入法软键盘由系统服务INPUT_METHOD_SERVICE管理.(必须是EidtText类才能正常关闭软键盘) 1234public static void hideOneInputMethod(Activity activity, View view){ InputMethodManager manager = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(view.getWindowToken(),0);} 用文本变化监听器TextWatcher判断输入文字是否达到指定位文本监听器接口TextWatcher功能实时监控当前已输入的文本长度. 使用 类继承TextWatcher并实现 重写3个方法 beforeTextChanged：文本改变之前触发 onTextChanged：文本改变过程中触发 afterTextChanged：文本改变之后触发.(建议使用) 给EditText组件添加addTextChangedListener(继承TextWatcher类的实例) java代码 @Override public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) { } 1234562. ```java @Override public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) { } @Override public void afterTextChanged(Editable editable) { String s = editable.toString(); if((s.length()==11&amp;&amp;mMaxLength==11)||(s.length()==6&amp;&amp;mMaxLength==6)){ hideOneInputMethod(MyTextWatch.this,editText); } } 1234567891011121314151617181920212223## 5.4获取对话框的选择结果### 提醒对话框AlertDialog#### 功能和效果弹出确认,提示，选择等窗体功能![屏幕截图 2021-10-26 154202](/image/屏幕截图_2021-10-26_154202.jpg)#### 创建和生成以及显示1. **创建建造器AlertDialog.Builder对象** ```java AlertDialog.Builder builder = new AlertDialog.Builder(this); 设置属性 调用AlertDialog.Builder对象的create方法生成对话框实例 1AlertDialog alertDialog = builder.create(); 调用对话框实例的show方法展示对话框 1alertDialog.show(); 123456789101112131415161718192021222324public void showMyDialog() { //创建提醒对话框的建造器 AlertDialog.Builder builder = new AlertDialog.Builder(this); //设置对话框的标题文本 builder.setTitle(&quot;尊敬的用户&quot;); builder.setMessage(&quot;你真的要卸载我吗?&quot;); builder.setPositiveButton(&quot;残忍卸载&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { textView.setText(&quot;成功卸载&quot;); } }); builder.setNegativeButton(&quot;我再想想&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { textView.setText(&quot;放弃卸载&quot;); } }); //根据构造器构建提醒对话框对象 AlertDialog alertDialog = builder.create(); //显示提醒对话框 alertDialog.show();} 设置属性（在java代码中） setIcon：标题图标 setTitle：标题文本 setMessage：内容文本 setPostitiveButton：肯定按钮（需要重写内部方法） setNegativeButton：否定按钮（需要重写内部方法） setNeutralButton：中性按钮(需要重写内部方法) 日期对话框DatePickerDialog嵌入式日期选择器(不常用)DatePicker效果 XML代码(DatePicker)1234&lt;DatePicker android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 弹出式日期选择器(常用)DatePickerDialogDatePickerDialog相当于DatePicker装在AlertDialog 效果 弹出方式的java代码 在xml设置一个按钮 OnClick方法中创建DatePickerDialog实例 填入选择日期（可以通过Calendar实现） 调用DatePickerDialog对象中的show方法. 123456//创建日历的一个实例Calendar calendar = Calendar.getInstance();//构建一个日期对话框DatePickerDialog datePickerDialog = new DatePickerDialog(this, this, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));//显示日期对话框datePickerDialog.show(); 监听器OnDateSetListener(获取日期) 类继承DatePickerDialog.OnDateSetListener接口并实现 重写onDateSet方法 123456//一旦点击日期对话框上的确定按钮，就会触发监听器的onDateSet方法@Overridepublic void onDateSet(DatePicker datePicker, int year, int mothOfYear, int dayOfMonth) { String format = String.format(&quot;你选择的日期时%d年%d月%d日&quot;, year, mothOfYear, dayOfMonth); textView.setText(format);} 注意onDateSet方法中的月份参数是从0开始的时间对话框TimePuckerDialog嵌入式时间选择器TimePicker效果 XML代码123&lt;TimePicker android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 弹出式时间选择器TimePickerDialog效果 弹出方式的java代码 在XML中设置一个按钮 OnClick方法中创建TimePickerDialog实例 填入选择时间（可以通过Calendar实现） 调用TimePickerDialog对象中的show方法. 注意TimePickerDialog构造方法的最后一个参数：是否采用24小时制 true：0~23 false：12小时 1234567891011@Override public void onClick(View view) { if (view.getId() == R.id.showTimePickerDialog) { Calendar calendar = Calendar.getInstance(); TimePickerDialog timePickerDialog = new TimePickerDialog(this, this, calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), true); timePickerDialog.show(); } } 监听器OnTimeSetListener(获取小时和分钟) 类继承TimePickerDialog.OnTimeSetListener接口并实现 重写onTimeSet方法 12345@Overridepublic void onTimeSet(TimePicker timePicker, int hourOfDay, int minute) { String format = String.format(&quot;你选择的时间%d时%d分&quot;, hourOfDay, minute); textView.setText(format);} 6.数据存储6.1共享参数SharedPreferences6.1.1基本概念组成 轻量级存储工具 key-value存储 作用类似java的properties XML存储 保存地址 /data/data/应用包名/shared_prefs/文件名.xml 12345678&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;map&gt; &lt;string name=&quot;name&quot;&gt;吃个饭&lt;/string&gt; &lt;float name=&quot;weight&quot; value=&quot;85.0&quot; /&gt; &lt;boolean name=&quot;isMarry&quot; value=&quot;true&quot; /&gt; &lt;int name=&quot;age&quot; value=&quot;782&quot; /&gt; &lt;float name=&quot;height&quot; value=&quot;89.0&quot; /&gt;&lt;/map&gt; 如何在Android studio中找到 连接手机或者虚拟手机 看AndroidStudio右下角的DeviceFileExplorer 按地址找 SQLlite数据库同理 使用场合 独立简单数据 文本类型的数据 需要持久化存储的数据 例子:app的配置信息,用户行为信息,临时需要保存的片段 6.1.2写入和读取共享参数获得共享参数实例 getSharedPreferences 12SharedPreferences share = getSharedPreferences(&quot;share&quot;, MODE_PRIVATE);//SharedPreferences share = getSharedPreferences(&quot;文件名&quot;, 操作模式); 写入 使用共享参数实例中的edit()方法 获得Editor类,然后调用putXXX(key值, 输入值)方法写入内容 获得Editor类调用commit(),来提交修改 1234567//获得编辑器的对象android.content.SharedPreferences.Editor edit = share.edit();//写入数据//edit.putString(key值, 输入值);edit.putString(&quot;name&quot;, &quot;测试&quot;);//提交编辑器的修改edit.commit(); 读取 使用共享参数实例中的的各种getXXX(key值，默认值) 12//共享参数实例.getString(key值，默认值);String name = sharedPreferences.getString(&quot;name&quot;,&quot;&quot;); 6.2App的全局内存6.2.1Application的生命周期运行周期存在唯一一个Application对象在整个应用的运行周期. 适用存储数据 会频繁读取的信息 不方便由意图传递的数据 容易因频繁分配内容而导致内存泄漏的对象 配置Application全局内容 创建一个继承Application的类 123public class MainApplication extends Application {...} 在AndroidManifest.xml文件中给application节点添加name属性(android:name=”.MainApplication”) 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.type6chapter&quot;&gt; &lt;application android:name=&quot;.MainApplication&quot; ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 让name属性应用上面的类.（作为一个入口类） 在整个类重写方法 onCreate:在App启动时调用 onTerminate:没用的 **onConfigurationChanged:**在配置改变时调用. 为继承Application的类设置单例模式 设置该类的私有静态成员属性 在OnCreate方法中为上面的成员属性实例化 设置getInstance()返回该成员属性 12345678910111213141516//1.设置该类的私有静态成员属性private static MainApplication mainApplication;//2.在OnCreate方法中为上面的成员属性实例化@Overridepublic void onCreate() { super.onCreate(); //app一打开就生成全局变量MainApplication对象 mainApplication=this;}//3.设置getInstance()返回该成员属性public static MainApplication getInstance(){ return mainApplication; } 6.2.2全局变量写入 在全局变量类中设置私有成员变量 在OnCreate()方法中实例化变量 设置一个方法返回该变量 6.2.3全局变量读取 全局变量类.返回对象方法() 1例如:MainApplication.getInstance(); 使用全局变量类，调用里面的成员变量和成员方法 6.3数据库SQLite6.3.1使用Room框架Room是什么 谷歌公司开发 基于SQLite 通过注解技术简化数据库操作 第三方框架提供 添加依赖 在build.gradle中的dependenices节点添加 ```// Room componentsimplementation “androidx.room:room-runtime:2.2.5”annotationProcessor “androidx.room:room-compiler:2.2.5” 12345678910111213141516171819202122232425262728293031323334353637#### 使用Room(类似Hibernate操作)##### 配置实体类@Entity1. 给Pojo类添加类级别的**@Entity**2. 设置主键**@PrimaryKey** - autoGenerate：主键自增3. 设置主键**@NonNull**##### 设置持久类Dao层@Dao1. 创建接口2. 让接口继承**@Dao**3. 创建方法4. 给方法添加SQL注解 1. **@Query** - 可以添加具体sql语句 2. **@Update** - **onConflict**： 当重复记录要采取的策略 - OnConflictStrategy.REPLACE：替换 ```java @Insert(onConflict = OnConflictStrategy.REPLACE) void insertOneBook(BookInfo book); @Insert onConflict： 当重复记录要采取的策略 OnConflictStrategy.REPLACE：替换 12@Insert(onConflict = OnConflictStrategy.REPLACE)void insertOneBook(BookInfo book); @Delete 创建数据库类RoomDatabase 创建抽象类并且继承RoomDatabase类 给类添加类级别**@Database**注解 entites：数据库的实体类数组(也就是表) version：数据库版本号 exportSchema：false：是否导出数据库信息的json串(一般用false,不然要指定build.gradle指定json文件的保存路径) 一个返回数据库中某个表的持久化类(@Dao的类)的抽象方法 12345@Database(entities = {BookInfo.class,UserInfo.class},version = 1,exportSchema = false)public abstract class BookDatabase extends RoomDatabase { //获取数据库中某表的持久化对象 public abstract BookDao bookDao();} 在全局变量类中创建唯一实例 设置私有的成员变量的数据库对象 在OnCreat()方法实例化上面的那个数据库对象 设置getXXX()方法返回整个数据库对象 1234567891011121314151617181920212223//1.private BookDatabase bookDatabase;//2.@Overridepublic void onCreate() { super.onCreate(); ... //构建数据库的实例(单例模式) bookDatabase= Room.databaseBuilder(mainApplication, BookDatabase.class, &quot;BookInfo&quot; ).addMigrations() //允许潜移数据库(发生数据库变更时,Room默认删除原来数据库在创建一个新的数据库.如此一来原来的记录会丢失，所有要改变潜移方式以便保存原有记录) .allowMainThreadQueries() //允许在主线程中操作数据库(Room默认不能在主线程操作数据库) .build();} //3.获取数据库的实例 public BookDatabase getBookDatabase(){ return bookDatabase; } 具体引用 获得全局变量类MainApplication.getInstance() 获得数据库类.getBookDatabase() 获取持久类.bookDao() 调用持久类中的sql方法.getAllBook(); 1MainApplication.getInstance().getBookDatabase().bookDao().getAllBook(); 6.2.2原生用法(不推荐)SQLite注意 SQlite是嵌入式数据库 SQLite的sql语法与通用的sql语句不同 只用到数据定义和数据操纵 数据定义语言DDL 创建表格 sql不分大小写 不支持boolean类型(用整型处理) 删除表格 修改表结构 数据操纵语言DML 增删改查 数据库管理器SQLiteDatabase创建数据库openOrCreateDatabase1SQLiteDatabase sqLiteDatabase = openOrCreateDatabase(getFilesDir() + &quot;/test.db&quot;, Context.MODE_PRIVATE, null); 删除数据库deleteDatabase1deleteDatabase(getFilesDir()+&quot;/test.db&quot;); API使用 管理类(数据库层) openDatabase：打开指定路径的数据库 isOpen：判断数据库是否已打开 close：关闭数据库 getVersion：获取数据库的版本号 setVersion：设置数据库的版本号 事务类(事务操作) beginTransaction：开始事务. setTransactionSuccessful：设置事务的成功标注 endTransaction：结束前面的事务(如果前面没使用setTransactionSuccessful，就事务回调) 数据处理类 execSQL：执行SQL语句(删表，建表，改表结构) delete update insert query：返回结果集的游标 rawQuery：执行SQL语句，返回结构集的游标 数据库帮助器SQLiteOpenHelper防止数据库重复打开 创建持久层类并且继承SQLiteOpenHelper类 重写onCreate和onUpgrade方法 onCreate：第一次打开数据库创建表 onUpgrade：数据库版本升高时执行 获取单例对象 打开数据库读取/写入连接(读锁和写锁) 读取连接getReadableDatabase 1SQLiteDatabase a=SQLiteDatabase对象.getReadableDatabase(); 写入连接getWritableDatabase 1SQLiteDatabase a=SQLiteDatabase对象.getWritableDatabase(); 增删改查 增改:使用ContentValues类 ContentValues类似Map 键key只能是字符串 ```javaContentValues contentValues = new ContentValues();contentValues.put(“name”,userInfo.getName());//执行更新操作 返回更新记录数量//condition是条件mDB.update(TABLE_NAME,contentValues,condition,null);//result=mDB.insert(TABLE_NAME,””,contentValues); 12345678910111213141516171819202122232425262728293031 - 查:使用到**游标类Cursor**类 - query和queryQuery方法返回**Cursor类** - 游标遍历 1. 游标控制类(指定游标状态) - close：关闭游标 - isClosed：游标是否关闭 - isFirst：游标是否在开头 - isLast：游标是否在末尾 2. 游标移动类(游标到指定位置) - moveToFirst：到开头 - moveToLast：到末尾 - moveToNext：下一条记录 - moveToPrevious：上一条记录 - move：移动若干条记录 - moveToPosition：到指定位置的路径 3. 记录类(获取记录的数量，类型，取值) - getCount：获取结果记录的数量 - getType：获取指定字段的字段类型 - geInt： - getLong - getFloat - getString - 删6. 关闭数据库连接close ```java SQLiteDatabase对象.close(); 6.3存储卡文件6.3.1私有存储空间和公有存储空间基本概念 Android7.0将存储卡分为 私有存储 系统分配每个app默认的空间 无权限 app卸载就没 公共存储 要权限 即使在AndroidManifest.xml声明，系统也不给 获取私有空间getExternalFilesDir12//获得当前App私有存储路径String privateFilePath = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(); 获取公共空间Environment.getExternalStoragePublicDirectory12//获得系统公共存储路径String publicFilePath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString(); 6.3.2文本文件的读写把文本字符串变成byte数组写入流 读取FileInputStream1234567891011//读取指定的文件路径构建文件输入流对象public static String openText(String path) { String readStr=&quot;&quot;; ... FileInputStream fileInputStream = new FileInputStream(path); byte[] bytes = new byte[fileInputStream.available()]; fileInputStream.read(bytes); readStr=new String(bytes); ... return readStr;} 写入FileOutputStream12345678//把字符串保存到指定路径的文本文件public static void saveText(String path,String txt){ //根据指定的文件路径构建文件输出流对象 ... FileOutputStream fileOutputStream = new FileOutputStream(path); fileOutputStream.write(txt.getBytes()); ...} 6.3.3图片文件的读写以及使用基本概念Bitmap 使用位图数据Bitmap类型处理图像数据 从bitmap工厂方法的BitmapFactory中调用 decodeResource：从资源文件获取图片 1Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.图片名); decodeFile：指定路径 Android10开始不能使用 decodeStream：文件输入流获取 读取 获得位图类型Bitmap对象 ImageView三种使用 setImageResource：R.drawbale.去掉拓展名的图片名称 setImageBitMap：BitMap类型 setImageURI：Uri类型（Uri.parse（图片路径）） 写入 获取位图类型Bitmap对象 调用Bitmap对象中的compress方法获取文件输出流 123456789//保存图片到文件public static void saveImage(String path,Bitmap bitmap){ try (FileOutputStream fileOutputStream = new FileOutputStream(path)) { //调用Bitmap对象中的 compress方法 获取 文件输出流 bitmap.compress(Bitmap.CompressFormat.JPEG,80,fileOutputStream); }catch (Exception e){ e.printStackTrace(); }} Other图片的三级缓存机制(不用复习)运行内存——&gt;存储卡——&gt;网络下载 通过共享参数(运行内存)判断是否首次访问网络图片 如果首次访问网络图片，就从服务器下载图片 通过存储卡存储服务器下载的图片 向数据库写入图片相关操作，返回图片本地存储地址 更新共享参数(运行内存)中的首次访问标志 include标签的重用样式 写一个布局 在另一个布局用include引用上面那个布局 这样可以共用一些小布局 7.内容共享ContentProvider内容组件 内容提供器ContentProvider 内容解析器ContentResolver 内容观察者ContentObserver 7.1内容组件在应用之间共享数据7.1.1内容提供器ContentProvider封装内部数据的外部访问接口功能： ContentProvider作为中间接口，不之间保存数据， 而是通过SQLiteOpenHelper与SQLiteDatabase间接操作底层数据库. ContentProvider封装SQLite数据库帮助器的对外的接口. 具体使用编写数据库帮助器 创建类继承SQLiteOpenHelper 重写onCreate 创建单例模式(getInstance方法) 创建数据库名称的成员变量值 创建内容提供器的基础字段类整个类相当于告诉本App要什么权限，开放什么东西(Uri) 创建类继承BaseColumns 创建私人成员变量的权限字符串 12public static final String AUTHORITIES=&quot;com.example.type7chapter.provider.UserInfoProvider&quot;;//URI的授权串 创建私人成员变量的访问提供器的外部表名 1public static final String TABLE_NAME= UserDBHelper.TABLE_NAME; 创建私人成员变量的访问提供器的URI 1public static final Uri CONTENT_URI=Uri.parse(&quot;content://&quot;+AUTHORITIES+&quot;/user&quot;); 创建私人成员变量的各个字段名称 1234public static final String USER_NAME=&quot;name&quot;;public static final String USER_AGE=&quot;age&quot;;public static final String USER_HEIGHT=&quot;height&quot;;public static final String USER_WEIGHT=&quot;weight&quot;; 右键菜单创建内容提供器 New-&gt;Other-&gt;Content Provider 创建内容提供器 Class Name：内容提供器的类名称 URI Authorities：URI的授权串 创建后AnroidManifest.xml的变化 12345&lt;provider android:name=&quot;.UserInfoProvider&quot; android:authorities=&quot;com.example.type7chapter.provider.UserInfoProvider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt; 新生成的XXXXProvider类 该类继承ContentProvider类 重写onCreate,insert,delete,query,update,getType方法 onCreate：获取数据库帮助器实例 1userDB=UserDBHelper.getInstance(getContext(),1); 给Uri匹配器中添加指定的数据路径 12345678 //Uri匹配时的代号public static final int USER_INFO = 1;public static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH); static { //向Uri匹配器中添加指定的数据路径 URI_MATCHER.addURI(UserInfoContent.AUTHORITIES,&quot;/user&quot;,USER_INFO); } insert,delete,query： 判断Uri中的用户USER_INFO 打开数据库的写入/读取连接 操作数据库的insert/delete/query 关闭数据库 123456789101112131415161718@Overridepublic Uri insert(Uri uri, ContentValues values) { //匹配Uri中的用户USER_INFO if(URI_MATCHER.match(uri)==USER_INFO){ SQLiteDatabase db = userDB.getWritableDatabase(); long rowid = db.insert(UserInfoContent.TABLE_NAME, null, values); //判断插入是否成功 if(rowid&gt;0){ //如果插入成功，就利用新记录的行号生成新的地址 Uri newUri = ContentUris.withAppendedId(UserInfoContent.CONTENT_URI, rowid); //通知监听器，数据已经改变 getContext().getContentResolver().notifyChange(newUri,null); } //关闭SQLite数据库连接 db.close(); } return uri;} 服务端App的接口封装成功. 7.1.2内容解析器ContentResolver通过外部操作内部数据功能 内容解析器是客户端App操作服务端数据的工具 ContenResolver和ContentProvider重写方法以及参数都一样 具体使用 getContentResolver（）：可获得内容解析器的实例 insert方法： 1234567private void addUser(UserInfo user) { ContentValues contentValues = new ContentValues(); contentValues.put(&quot;name&quot;, user.getName()); ... //参数一:数据库路径 getContentResolver().insert(UserInfoContent.CONTENT_URI, contentValues);} delete方法： 12 //参数一:数据库路径 参数二:删除条件 getContentResolver().delete(UserInfoContent.CONTENT_URI, &quot;1=1&quot;, null); query方法以及参数（从左向右排）: uri：Uri类型,指定数据库路径 projection：字符串数组，要查询的字段名称列表 selection：字符串类型，查询条件 sortOrder：字符串，排序条件 12345private void showAllUser(){ ... Cursor cursor = getContentResolver().query(UserInfoContent.CONTENT_URI, null, null, null); ...} 7.2内容组件获取通讯信息7.2.1动态申请权限1.AndroidManifest.xml添加权限配置在Android某些版本后，用户某些权限还是必须界面手动开启权限 完整存储卡权限：Android7.0后 权限配置后系统也不给开启，要App运行时判断权限开关情况：Android6.0后 关闭公共空间沙盒：Android10.0（默认开启沙盒） 12//在application节点下android:requestLegacyExternalStorage=&quot;true&quot; 临时关闭公共空间沙盒：Android11 (默认开启沙盒) 12 //在application节点下android:preserveLegacyExternalStorage=&quot;true&quot; 添加案例12345678910111213141516171819&lt;!-- 存储卡读写 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- Android10新增权限MANAGE_EXTERNAL_STORAGE --&gt;&lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 联系人/通讯录。包括读联系人、写联系人 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot; /&gt;&lt;!-- 短信。包括发送短信、接收短信、读短信 --&gt;&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;&lt;!-- 通话记录。包括读通话记录、写通话记录 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CALL_LOG&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CALL_LOG&quot; /&gt;&lt;!-- 安装应用请求，Android8.0需要 --&gt;&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;&lt;!-- 获取媒体位置（Android10新增权限） --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_MEDIA_LOCATION&quot; /&gt; 2.检查App是否开启权限 调用ContextCompat的checkSelfPermission（获得实例，检查权限名称）方法 实例Activity 检查权限名称：Mainfest. 当返回值int类型等于PackageManager.PERMISSION_GRANTED就代表成功 检查版本（android小于7） 1Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M 1ContextCompat.checkSelfPermission(act,permission); 3.弹出用户是否开启权限的系统弹窗 调用ActivityCompat的requestPermissions（活动实例，待申请的权限名称数组，请求码） 1ActivityCompat.requestPermissions(act, permissions, requestCode); 重写onRequestPermissionsResult方法判断用户权限选择结果 requestCode：请求参数(参考上面) permissions：权限组 grantResults：每个权限的同意情况 1234567891011@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestCode==R.id.personNumber1%65536){ if(MyPermissionUtil.checkGrant(grantResults)){ ToastUtil.show(this,&quot;权限开启成功&quot;); }else{ ToastUtil.show(this,&quot;需要运行存储卡权限才能写入公共空间&quot;); } } } 7.2.2ContentResolver读写联系人联系人Contact的bean和Uri联系人bean conteactId：编号 name：姓名 phone：号码 email：邮箱 联系人提供器的Uri对象 ```javaUri raw_uri = Uri.parse(“content://com.android.contacts/raw_contacts”);123456- 获取联系人Id ```java ContentValues values = new ContentValues(); long contactId = ContentUris.parseId(resolver.insert(raw_uri, values)); 联系人数据的Uri对象 得到联系人数据Uri对象 插入name，phone，email的ContentValues对象 name： raw_contact_id 联系人Id mimetype vnd.android.cursor.item/name data2 联系人姓名 phone： raw_contact_id 联系人Id mimetype vnd.android.cursor.item/phone_v2 data1 电话号码 data2 1表示家庭，2表示工作 email： raw_contact_id 联系人Id mimetype vnd.android.cursor.item/email_v2 data1 邮件 data2 1表示家庭，2表示工作 调用ContentResolver的insert(联系人数据Uri对象，ContentValues对象) 具体使用 开启读取联系人的动态申请权限 创建联系人相关的pojo 添加联系人需要先查询到联系人id再插入phone，name，email 调用ContentResolver中的insert或者query方法. 123456789101112131415161718192021222324252627282930313233// 往手机通讯录添加一个联系人信息（包括姓名、电话号码、电子邮箱）public static void addContacts(ContentResolver resolver, Contact contact) { // 构建一个指向系统联系人提供器的Uri对象 Uri raw_uri = Uri.parse(&quot;content://com.android.contacts/raw_contacts&quot;); ContentValues values = new ContentValues(); // 创建新的配对 // 往 raw_contacts 添加联系人记录，并获取添加后的联系人编号 long contactId = ContentUris.parseId(resolver.insert(raw_uri, values)); // 构建一个指向系统联系人数据的Uri对象 Uri uri = Uri.parse(&quot;content://com.android.contacts/data&quot;); ContentValues name = new ContentValues(); // 创建新的配对 name.put(&quot;raw_contact_id&quot;, contactId); // 往配对添加联系人编号 // 往配对添加“姓名”的数据类型 name.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/name&quot;); name.put(&quot;data2&quot;, contact.name); // 往配对添加联系人的姓名 resolver.insert(uri, name); // 往提供器添加联系人的姓名记录 ContentValues phone = new ContentValues(); // 创建新的配对 phone.put(&quot;raw_contact_id&quot;, contactId); // 往配对添加联系人编号 // 往配对添加“电话号码”的数据类型 phone.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/phone_v2&quot;); phone.put(&quot;data1&quot;, contact.phone); // 往配对添加联系人的电话号码 phone.put(&quot;data2&quot;, &quot;2&quot;); // 联系类型。1表示家庭，2表示工作 resolver.insert(uri, phone); // 往提供器添加联系人的号码记录 ContentValues email = new ContentValues(); // 创建新的配对 email.put(&quot;raw_contact_id&quot;, contactId); // 往配对添加联系人编号 // 往配对添加“电子邮箱”的数据类型 email.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/email_v2&quot;); email.put(&quot;data1&quot;, contact.email); // 往配对添加联系人的电子邮箱 email.put(&quot;data2&quot;, &quot;2&quot;); // 联系类型。1表示家庭，2表示工作 resolver.insert(uri, email); // 往提供器添加联系人的邮箱记录} 7.2.3ContentObserver监听短信功能 ContentResolver是主动查询数据 事先给目标内容注册一个观察器，数据变化就触发Onchange事件 使用方式 创建类继承ContentObserver 可以导入Content对象，操作ContentResolver对象 重写onChange方法 具体操作(notifyChange：通知内容观察器发送了数据变化) 使用内容解析器注册这个类registerContentObserver（Uri对象，true，继承ContentObserve类的类） 12345678//短信得UrimSmsUri=Uri.parse(&quot;content://sms&quot;);//短信得字段mSmsColumn=new String[]{&quot;address&quot;,&quot;body&quot;,&quot;date&quot;};//继承ContentObserver类的类mObserver=new SmsGetObserver(mHandler,this);//给SmsGetObserver注册getContentResolver().registerContentObserver(mSmsUri,true,mObserver); 使用内容解析器注销这个类unregisterContentObserver(继承ContentObserve类的类) 1getContentResolver().unregisterContentObserver(mObserver); 其他系统URI 7.3引用之间共享文件7.3.1使用相册图片发送彩信短信只能文本，彩信可以图片和文本 从系统相册中选择图片 创建内容获取动作的意图Intent.ACTION_GET_CONTENT 1Intent albumIntent = new Intent(Intent.ACTION_GET_CONTENT); 设置内容为图像 1albumIntent.setType(&quot;image/*&quot;); 调用startActivityForResult（意图，跳转码）方法跳转到系统相册. 1startActivityForResult(albumIntent, CHOOSE_CODE); // 打开系统相册，并等待图片选择结果 重写onActivityResult方法 调用Intent的getData方法获得图片的Uri对象 123456789101112@Override protected void onActivityResult(int requestCode, int resultCode, Intent intent) { super.onActivityResult(requestCode, resultCode, intent); if (resultCode == RESULT_OK &amp;&amp; requestCode == CHOOSE_CODE) { // 从相册选择一张照片 if (intent.getData() != null) { // 数据非空，表示选中了某张照片 mUri = intent.getData(); // 获得选中照片的路径对象 iv_appendix.setImageURI(mUri); // 设置图像视图的路径对象 Log.d(TAG, } } } 发送彩信 创建一个发送意图Intent.ACTION_SEND 1Intent intent = new Intent(Intent.ACTION_SEND); // 创建一个发送动作的意图 -填入内容 startActivity(意图) 7.3.2借助FileProvider发送彩信（Mms）从相册中得到信息更多的图片文件 定义相册Uri，字段的对象变量 123456private Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; // 相册的Uri private String[] mImageColumn = new String[]{ // 媒体库的字段名称数组 MediaStore.Images.Media._ID, // 编号 MediaStore.Images.Media.TITLE, // 标题 MediaStore.Images.Media.SIZE, // 文件大小 MediaStore.Images.Media.DATA}; // 文件路径 调用ContentProvider对象查询媒体库的图片信息 1Cursor cursor = getContentResolver().query(mImageUri, mImageColumn, null, null, &quot;_size asc&quot;); 开放应用的文件访问(共享某个文件)不能直接访问 Android 7.0后不能用Uri.parse(path)来直接访问其他应用的文件 必须通过FileProvider来共享某个文件（A共享文件，b访问共享文件）. 重新配置FileProvider 在res创建xml文件夹，创建paths的xml文件.(开放的路径) 1234&lt;paths&gt; &lt;external-path path=&quot;Android/data/com.example.chapter07/&quot; name=&quot;files_root&quot; /&gt; &lt;external-path path=&quot;.&quot; name=&quot;external_storage_root&quot; /&gt;&lt;/paths&gt; 在AndroidManifest.xml下applcaition节点添加provider标签(声明当前应用的内容提供器组件) authorities；授权字符串 元数据的resource：指明文件提供器的路径资源 123456789&lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;授权字符串&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/paths的xml文件&quot; /&gt; &lt;/provider&gt; 通过FileProvider获取图片文件 调用FileProvider.getUriForFile(this，文件提供器的授权字符串，File类型的文件对象) 12uri = FileProvider.getUriForFile(this, &quot;com.example.chapter07.fileProvider&quot;, new File(path)); 7.3.3借助FileProvider安装应用开放安装应用权限 从Android 8.0要申请REQUEST_INSTALL_PACKAGES 1&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt; 启动动态权限 从媒体库中得到APK安装包 定义存储卡的Uri，字段的对象变量 1234567private Uri mFilesUri = MediaStore.Files.getContentUri(&quot;external&quot;); // 存储卡的Uri private String[] mFilesColumn = new String[]{ // 媒体库的字段名称数组 MediaStore.Files.FileColumns._ID, // 编号 MediaStore.Files.FileColumns.TITLE, // 标题 MediaStore.Files.FileColumns.SIZE, // 文件大小 MediaStore.Files.FileColumns.DATA, // 文件路径 MediaStore.Files.FileColumns.MIME_TYPE}; // 媒体类型 调用ContentProvider对象查找媒体库安装包列表（查找存储卡的apk文件） - 12Cursor cursor = getContentResolver().query(mFilesUri, mFilesColumn, &quot;mime_type='application/vnd.android.package-archive' or _data like '%.apk'&quot;, null, null); 启动系统自带的应用安装程序 通过**FileProvider.getUriForFile(this.授权字符串,file类型)**获取文件Uri对象 创建意图new Intent(Intent.ACTION_VIEW) 设置意图的setDataAndType（文件Uri对象，”com.example.chapter07.fileProvider”） startActivity（意图）启动系统自带的应用安装程序 8.高级控件8.1下拉列表以及适配器8.1.1下拉框SpinnerXML代码 Spinner spinnerMode：下拉框模式 dropdown：下拉模式 dialog：对话框模式 java代码 setPrompt：设置标题文字(对话框才显示，下拉模式不显示) setAdpater：设置列表项的数据适配器 setSelection：设置当前选中项(要先设置setAdpater) ArrayAdapter SimpleAdapter setOnItemSelectedListener：选择监听器 继承OnItemSelectedListener的类 重写onItemSelected方法(参数arg2为选择得到的下标，从0开始) 123456789class MySelectedListener implements OnItemSelectedListener { // 选择事件的处理方法，其中arg2代表选择项的序号 public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) { Toast.makeText(SpinnerDropdownActivity.this, &quot;您选择的是&quot; + starArray[arg2], Toast.LENGTH_LONG).show(); } // 未选择时的处理方法，通常无需关注 public void onNothingSelected(AdapterView&lt;?&gt; arg0) {} } 8.1.2数组适配器ArrayAdapter功能显示文本列表 使用步骤123// new ArrayAdapter&lt;String&gt;(this,列表项的XML文件, 文本内容数组);ArrayAdapter&lt;String&gt; starAdapter = new ArrayAdapter&lt;String&gt;(this, R.layout.item_select, starArray); 编写列表项的XML文件 调用new ArrayAdapter&lt;String&gt;(this,列表项的XML文件, 文本内容数组) 调用下拉控件对象的setAdapter（适配器对象） 8.1.3简单适配器SimpleAdapter功能显示文本与图片 使用方法 构建列表项的XML文件 调用new SimpleAdapter(this, Map数组,列表项的布局文件, Map数组中的key数组，布局文件子控件id数组); Map数组：key-value值 列表项的布局文件：每一个列表项的布局文件 Map数组中的key数组：对应下面的布局文件中子控件id 布局文件子控件id数组：上面一个数据对应一个控件id 12345 // 声明一个下拉列表的简单适配器，其中指定了图标与文本两组数据 SimpleAdapter starAdapter = new SimpleAdapter(this, list, R.layout.item_simple, new String[]{&quot;icon&quot;, &quot;name&quot;}, new int[]{R.id.iv_icon, R.id.tv_name});//icon的数据对应着item_simple布局文件中的子控件iv_icon 调用下拉控件对象的setAdapter（适配器对象） 8.1.4基本适配器功能让列表项的布局更加丰富. 使用方式 编写列表项的布局文件 创建数据适配类并且继承BaseAdapter 构造方法：转入数据和上下文Context getCount：列表项个数 getItem：列表项数据 getItemId：列表项编号 getView：通过上下文Context找到列表项的根布局，将数据添加到根布局下面的各个子控件 调用下拉控件对象的setAdapter（继承BaseAdpater的适配器对象） 8.2列表视图8.2.1列表视图ListView效果直接在页面显示全部列表信息 使用方式 在Xml文件中添加ListView标签 XMl新属性 java代码新设置 说明 divider setDivider 分隔线图形 dividerHeight setDividerHeight 分隔线高度 listSelector setListSelector 列表项的按压背景（状态图形格式） 在java代码填充数据 setAdpater 点击监听器 点击监听器 点击监听按钮：setOnItemSelectedListener（继承OnItemSelectedListener类） 长按点击监听按钮：setOnItemLongSelectedListener（继承OnItemSelectedLongListener类） 修改分隔线默认各项之间的默认展示灰色分隔线 XML修改 divider属性为@null时 dividerHeight的值不能大于0 不然最后一项会不见 java修改 先用setDivider方法 再用setDividerHeight方法 XML文件不存在顺序问题 如果倒转就会把图片高度当成分隔高度 去掉分隔线 Divider设置为null DividerHeight设置为0 修改按压背景默认点击/长按某项时显示默认的灰色水波背景 XML修改 listSelector：Drawable文件 java修改 setSelector（Rrawable文件） 去掉按压背景 设置一个透明颜色文件R.color.透明文件 在xml或者java代码修改 @null和设置为null都不行,一个会出现橙色背景，一个空指针 高度问题 XML文件，ListView后面还有同级控件时 设置ListView 高度:0dp 权重:1 如果设置”warp_content”，那么只会显示一项 抢占焦点问题针对的是列表项的根节点，不是listView 是什么当列表项中存在按钮/编辑框，点击列表会无法触发，因为起冲突了. 设置内部视图的焦点抢占方式 XML修改：descendantFocusability java修改：setDescendantFocusability 抢占属性 说明 代码 xml 子控件之前 ViewGroup.FOCUS_BEFORE_DESCENDANTS beforeDescendants 子控件之后 ViewGroup.FOCUS_AFTER_DESCENDANTS afterDescendants 不让子控件处理 ViewGroup.FOCUS_BLOCK_DESCENDANTS blocksDescendants 8.2.2网格视图GridView功能和基本属性功能分行分列显示表格信息 基本属性 setAdapter setOnItemClickListener setOnItemLongClickListener 网格属性新属性 XML java 说明 horizontalSpacing setHorizontalSpacing 网格项在水平方向的间距 vericalSpacing setVericalSpacing 网格项在垂直方向的间距 numColumns setNumColumns 列的数目 stretchMode setStretchMode 拉伸模式. columnWidth setColumnWidth 每列宽度(当拉伸模式是spacingWidth，spacingWidthUniform) 拉伸属性 XML JAVA 说明 none NO_STRETCH 不拉伸 columnWidth STRETCH_COLUMN_WIDTH 拉伸列宽 spacingWidth STRETCH_SPACING 列间空隙 spacingWidthUniform STRETCH_SPACING_UNIFORM 左右空隙 拉伸模式说明 不设置stretchMode：无分隔线 不拉伸NO_STRETCH：每行网格项紧挨，空隙全在右边 拉伸列宽STRETCH_COLUMN_WIDTH：每个网格变宽，分隔线变小 列间空隙STRETCH_SPACING：多出来的空隙在网格项中间 左右空隙STRETCH_SPACING_UNIFORM：空隙同时出现在网格项的左右两边 padding显示全部分隔线（setPadding）：内外边界都显示分隔线 1gv_planet.setPadding(dividerPad, dividerPad, dividerPad, dividerPad); 8.3翻页类视图8.3.1翻页视图ViewPager功能 左右滑动翻页 一个页面一个项 属性方法 setAdapter（继承PagerAdapter）：设置页面适配器 setCurrentItem：设置当前显示页面 addOnPageChangeListener（继承OnPageChangeListener/SimpleOnPageChangeListener接口的类）：页面变化监听器 页面适配器PagerAdapter首先创建类继承PagerAdapter，让后重写以下方法 构造方法：传入上下文Context以及数据，将数据装入ImageView并保存在list中 getCount：获得页面项个数 isViewFromObject： instantiateItem：实例化指定位置（传入下标）的页面（输入下标获得上面list已经实例化的ImageView）.并添加到容器中 destroyItem：从容器中销毁指定位置(下标)的页面 getPageTitle：获得指定页面的标题文本(后面翻页标签栏会用到) 页面变化监听器addOnPageChangeListener OnPageChangeListener接口 onPageScrollStateChanged：翻页状态改变 状态变化：正在滑动1-&gt;滑动完毕2-&gt;静止0 onPageScrolled：翻页过程中触发 onPageSelected：翻页结束后 position：翻到那一页 SimpleOnPageChangeListener接口（常用） onPageSelected：翻页结束后 position：翻到那一页 使用方式 在XML添加完整路径的ViewPager节点 创建翻页适配器并重写方法 通过构造方法传入上下文以及数据 将每个数据装入页面，并保存起来，方便下面通过下标获得ImageView来实例化页面 由instantiateItem方法实例化视图对象并添加到容器 12345// 实例化指定位置的页面，并将其添加到容器中 public Object instantiateItem(ViewGroup container, int position) { container.addView(mViewList.get(position)); return mViewList.get(position); } 给PageView调用setAdapter添加这个页面适配器 8.3.2翻页标签栏PagarTabStrip功能 在翻页视图上方显示页面标题 类似选项卡 文本下面有横线 点击左右选择卡即可切换页面 使用方式 在XML布局文件中ViewPage节点添加PagerTabStrip节点 翻页适配器重写getPageTitle方法 1234// 获得指定页面的标题文本 public CharSequence getPageTitle(int position) { return mGoodsList.get(position).name; } 改变标签栏的文本样式 必须使用java代码修改 获得翻页标签栏的布局视图对象 setTextSize setTextCode 不支持XML修改 8.3.3简单的启动引导页效果在首次启动中出现欢迎页面，并且向右翻几页才到应用主页面 核心页面项的XML布局和适配器 大概思路 页面项的XML文件 引导页的背景图(ImageView) 底部的一排原点(RaioGroup) 最后一页的入口按钮(Button) 启动引导页的适配器 在构造方法，将传入数据装入页面项，再把页面项存储起来 让当前的原点显示 最后一页的按钮 8.4碎片Fragment碎片功能 占据页面的一小块区域 拥有自己的生命周期 添加后之后不影响宿主页面的其他区域，删掉也不影响 每个碎片对应XML布局文件 8.4.1碎片的静态注册定义和作用 直接在XML文件直接写fragment节点 可被其他布局文件/活动页面引用 具体使用 编写碎片的XML页面布局 编写碎片类继承Fragment类以及入口方法onCreateView方法 其他活动页面引用 直接添加Fragement节点 指定id属性(必须写) 指定name属性(必须完整碎片类的路径) 12345&lt;fragment android:id=&quot;@+id/fragment_static&quot; android:name=&quot;com.example.chapter08.fragment.StaticFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; /&gt; 碎片的静态注册生命周期基本生命周期onCreate，onStart，OnResume，onPause，onStop，ondDestroy 额外生命周期 onAttach：与活动页面结合 onCreateView：创建碎片视图 onActivityCreated：活动页面创建完毕后调用 onDestroyView：回收碎片视图 onDetach：活动页面分离 8.4.2碎片的动态注册定义 代码执行时才动态添加碎片.(基本给翻页视图使用) 无论当前位于那个页面，系统都只会加载当前页及相邻的左右页. 使用方式 创建碎片适配器继承FragmentPagerAdapter类 构造方法：传入碎片管理器和数据 getCount：获取碎片个数 getItem：指定位置的碎片Fragment 给动态碎片类输入参数和页面下标 getPageTitle：指定碎片页的标题文本 创建动态碎片类继承Fragment类 通过newInstance方法接收数据装成Bundle onCreateView方法接收Bundle将数据装入视图中. 在活动页面中，给ViewPager添加碎片翻页适配器 9.广播组件Broadcast定义广播(Broadcast)是Android四大组件之一（组件之间进行通信） 广播和活动之间的区别 活动一对一通信，广播一对多 发送方:只要发送广播就行 接收方:过滤符合条件的广播，工作就一定收到广播，不工作就收不到广播 广播三步骤 发送广播 定义广播接收器 开关广播接收器 广播三方法 sendBroadcast：发送广播 registerReceiver：注册广播的接收器（一般写在onStart/onResume中） unregisterReceiver：注销广播的接收器（onStop/onPause方法） 9.1发送和接收应用自身的广播9.1.1标准广播9.1.2有序广播9.1.3静态广播9.2监听和处理设备发出的系统广播9.3监听因屏幕变更导致App界面改变的状态事件","link":"/Liust1918.githud.io/2022/12/04/Android%E5%85%A5%E9%97%A8/"},{"title":"java设计模式","text":"设计模式 类的关系 关联关系 一个类的对象是另一个类的属性 单向关联(一个类的对象是另一类的属性) 123456public class A { private B b;}public class B {} 双向关联(对象相互是对方的属性) 123456public class A { private B b;}public class B { private A a;} 自关联(自己类就是自己的属性) 123public class C { private C c;} 聚合关系(一个部分一个整体，部分脱离了整体也可独立存在) 12345678910public class E { private D d; public void setD(D d) { this.d = d; } public E(D d) { this.d = d; }}//不能从代码形式上判断聚合/组合而从语义上判断 组合关系(类之间的部分和整体关系,但是是共生关系) 123456public class D { private E e; public D() { e=new E(); }} 依赖关系(使用关系==&gt;某个类的方法使用另一个类的对象作为参数) 123456public class F { public F(E e) { e.Run(); }}//通常是调用另一个类的静态方法/局部变量 泛化关系(类的继承) 接口与实现关系(接口的实现) 面向对象设计类的概念 继承(类继承extends,接口implements) 多态(父类整个方法不实现,由子类继承并实现方法,得到不同的结果) 重写（父类方法实现，子类继承父类并且重写上面那个方法） 重载(类中有重名的方法，但是参数(传入值s)不一样) 面向对象设计的目标实现支持可维护性得到复用. 设计原则 单一职责原则:一个对象只包含单一的职责,并且被封装在一个类中 开闭原则:对拓展开发,对修改关闭.(不给改,但是给拓展) 里氏代换： 将父类对象替换成子类对象,不会报错和异常,但是反过来不行. (所以如果能够使用基类对象,那么一定能够使用其子类对象) 分析: 子类必须实现父类的抽象方法,但是不能重写/覆盖父类的其他方法. 子类可以增加自己特有方法 当子类覆盖或实现父类的方法时,方法的形参要比父类方法的输入参数(可以理解为传入参数类型)要宽松，反之不行. 当子类的方法实现父类的抽象方法时,方法的返回值比父类严格,反之不行. 依赖倒装:针对接口编程,不要针对实现编程 接口隔离:一个接口太多就应该分割成很多各小接口,并且符合上面的单一职责原则 合成复用:用组合/聚合关系来获得其他类的功能，少用继承. 迪米特法则： 定义(了解):不要和陌生人说话，只和朋友通信 朋友: 对象本身(this) 当前对象的成员对象 当前对象所创建的对象 参数传入的对象 如果对象成员是一个集合，里面的对象都是 总结:就是不允许出现 a .b().c()这样的对象调用,只能a .b() 设计模式简介什么是设计模式: 遇到什么问题 怎么解决问题 效果怎么样 设计模式分类 创建型模式：创建对象 结构型模式: 处理类/对象的组合 行为型模式：描述对类/对象怎样交互和怎样分配职责(把一个方法变成一个类) GoF设计模式创建型模式类模式 工厂方法模式 对象模式 抽象工厂模式 原型模式 单例模式 结构型模式类模式 (类)适配器模式 对象模式 (对象)适配器模式 桥接模式 组合模式 装饰模式 外观模式 代理模式 行为型模式类模式 模板方法模式 对象模式 命令模式 迭代器模式 观察者模式 状态模式 策略模式 创建型模式工厂模式把对象实例化交给一个工厂类中,用户直接调用工厂类就行了. 简单工厂模式一个抽象的物品类，具体物品对象就继承他并实现其中的方法,然后有一个工厂类负责返回实例化的物品对象. 使用环境 工厂类负责创建的对象少,且不添加新功能 客户只需传入参数给工厂类,对创建对象不用知道 优点 实现对象创建和使用的分离 客户端只需要知道具体产品的参数就行了 引入配置文件,在不修改客户端代码的同时更换和增加新的具体产品类 缺点 一旦工厂类挂了,全部一起挂 增加类的个数后,会增加系统的负责度和理解难度 拓展困难,一旦有新产品添加就要修改工厂类(违反开闭原则) 工厂模式在简单工厂模式的基础上,不再是一个工厂类包一切,而是一个产品一个工厂类,所以工厂类继承一个抽象工厂总类. 优点 在工厂方法模式中,工厂方法用来创建客户所需要的产品,同时还向客户端隐藏了哪种具体产品类将被实例化. 创建对象完全封装在工厂类 符合开闭原则 缺点 系统中类的个数将成对增加 增加了系统的抽象性和理解难度. 抽象工厂模式分为两个维度: 产品:单纯产品 产品族:同一个工厂生产的,位于不同产品等级结构中的一组产品 分法：a个工厂其中有一个b个产品,b个产品其中一个有a个方法. 产品和产品族分为两个维度,一个是真产品,一个是生产产品的工厂,产品可以抽象为一个抽象类,每个不同工厂生产不同的产品,这些产品类继承这个抽象产品类.由于有不同工厂,不同工厂都继承一个抽象工厂总类,这个抽象工厂总类,就负责抽象返回不同产品的抽象类.具体工厂类就返回自己工厂生产相应的产品类. (要确定改变的一个维度为产品族(具体工厂),不改变的另一个维度为新产品(就是产品)). 适用环境 工厂太多,减少类,分类工厂,但是符合开闭原则倾斜性(增加产品族=符合开闭原则,增加产品=不符合开闭原则) 一个维度不变,另一个维度可变. 优点 隔离了具体类的生产，客户并不需要知道什么被创建 保证客户端一直用同一个产品族的对象 缺点 当新增产品的时候,需要修改产品族的代码,违反开闭原则. 建造者模式用来创建一个包含多个组成部分的复杂对象. 首先先创建一个多属性的对象作为你的对象(或者可以理解为怎么组合套餐),然后定义一个抽象建造者类,在类中直接实例化一个前面的复杂对象,然后编写抽象方法让子类直接重写方法来修改前面复杂对象的属性,在加入一个返回这个复杂对象的方法,在子类中，由于父类是抽象建造者，其复杂对象是protected,因此直接在子类重写方法并给上面父类的复杂对象设置.再设置一个指导类用来注入相应子类,并调用抽象方法以及返回这个复杂对象. 适用环境 产品对象有复杂内部结构 产品对象中的属性有顺序 隔离复杂对象的创建和使用 创建过程封装再指导类 优点 对象与对象的创建过程解耦，相同的创建过程创建不同的产品对象. 方便替换建造者/具体建造者,符合开闭原则 控制产品的创建过程 缺点 产品的差异性很大. 产品的内部变化太复杂. 原型模式克隆出多个与原型对象一模一样的对象. 分类： 浅克隆:普通成员对象和原来一样,但是引用类型的成员对象不会被克隆,依然指向旧对象. 深克隆:无论普通还是引用类型都会被复制. 实现方式 浅克隆(Cloneable) 被克隆对象需要继承Cloneable接口,然后重写clone方法,方法中调用父类clone方法并返回克隆对象. 深克隆(序列化) 被克隆对象以及内部的引用的对象都必须实现Serializable接口,被克隆对象通过写入对象流中，再从流中读出来克隆对象. 123456789public Object deepClone() throws IOException, ClassNotFoundException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(this); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream); return ois.readObject();} 适用模式 创建对象成本大 系统要保存对象的状态,状态变化很小 需要避免使用分层次的工厂类来创建分层次的对象. 优点 提高创建新实例的创建效率 简化创建结构 深克隆可以保存对象的状态 缺点 每个类都需要配克隆类,当对已有类进行操作,会违背开闭原则 深克隆代码复杂. 原型模式拓展带原型管理器的原型模式首先创建抽象的原型模式类并且这个类继承Cloneable，其中包含克隆方法已经其他方法,继承他的子类重写克隆方法以及其他方法.然后创建一个原型模式管理类，里面定义一个hash表,然后设置可以向hash表输入key-value值的方法,不过这里的value是上面抽象原型模式的子类的实例化,再设置一个按key导出hash表里面实例化对象并克隆的以及返回克隆对象的方法. 相似对象的复杂复杂所得到的对象与原型对象并不是完全相同,它们的某些属性值存在异同,通过原型模式获得相同对象后可以再对其属性进行修改,从而获取所需对象. 单例模式保存某个类只能有一个实例,并且这个类自行实例化并提供这个实例 要点： 这个类只能有一个实例 这个类自行创建 自行提供这个实例 也可理解 单例类的构造方法私有 提供一个自身的静态私有成员变量 提供一个公有的静态工厂方法. 分类 饿汉式(解决并发问题,但是占用内容资源,效率低) 123456private static Singleton singleton=new Singleton();private Singleton() {}public static Singleton getInstance(){ return singleton;} 懒汉式(存在并发问题,只能串行,效率高,内存资源少) 12345678910 private static Singleton singleton=null; private Singleton() { }// 线程不安全 public static Singleton getInstance(){ if(singleton==null){ singleton=new Singleton(); } return singleton; } 上锁的懒汉式(解决懒汉式的缺点) 123456789private static SySingleton singleton=null;private SySingleton() {}synchronized public static SySingleton getInstance(){ if(singleton==null){ singleton=new SySingleton(); } return singleton;} 多例模式（加个集合类保存以及计算器限制第几个） 1234567891011121314151617private static ArrayList&lt;Doubleton&gt; list = new ArrayList();private static int numbers=1;private Doubleton(){}public synchronized static Doubleton getInstance(int i){ if(i&gt;=0&amp;&amp;i&lt;numbers){ return list.get(i); } return null;}public static void setInstance(int i){ list.clear(); numbers=i; for(int a=0;a&lt;i;a++){ list.add(new Doubleton()); }} 适用 自需要一个实例对象, 只允许一个公共访问点. 优点 提供唯一实例的受控访问 节约资源 多例模式 缺点 缺少抽象层,难拓展 单列职责过重 由于自动垃圾回收机制,可能导致共享的单例对象的状态丢失. 结构型模式适配器模式分类： 类适配器(继承) 创建目标接口，以及被适配者类，目标需要被适配者的方法,于是创建一个适配器类,适配器类中继承目标接口以及继承被适配者类,并且重写目标接口的方法,方法里面调用父类被适配者的方法. 对象适配器(关联) 创建目标接口,以及被适配者类,目标需要被适配者的方法，但是这里不用继承,用关联关系,直接把被适配器类放入适配器类中当属性,并且适配者类继承目标接口，并且重写目标接口方法,在方法中调用成员变量中被适配者类中的方法.当然通过构造方法注入被适配者类. 适用环境 系统需要适用一些现有的类,而在这些类的接口不符合系统的需要,甚至没有这些类的源代码 创建一个可以重复使用的类(例如JDBC的连接). 优点 目标类和适配器类解耦 增加了类的透明性和复用性 灵活性和拓展性都很好 类适配器优缺点优点 适配器类是适配者类的子类，所以可以在适配器类中置换一些适配者方法 缺点对于java，C#面向对象的语言 一次最多适配一个适配者类 目标抽象类只能为接口 适配者类不能为最终类 对象适配器优缺点优点 可以适配多个不同的适配者类到同一个适配器类中 缺点 实现过程复杂 桥接模式将抽象部分与实现部分分离.A(接口)搭桥(聚合关系)到B(抽象类),B(抽象类)搭桥(聚合关系)到C(抽象类)…. (A,B,C….n个维度) 首先先取某一个维度作为接口，并且子类继承实现,然后再创建另一个维度的抽象类,抽象类中将前面的接口作为聚合关系加入.并且设置protected，接着再创建一个抽象方法,用来给这个维度的子类实现相应方法,并且在这个方法可以调用父类中成员变量来使用接口的方法.然后再客户端类中实例化第二个维度的抽象类，然后实例化第一个接口，然后注入前面实例化的抽象类中,并调用第一个类中的方法. 实现多个维度:可以继续加入抽象类，这个抽象类是和上一个抽象类成聚合关系,后面的内容与上面第一个抽象类差不多. 适用环境 抽象化和具体化之间更加灵活,避免在两个层次之间建立静态的继承关系. 抽象和实现部分独立拓展且互不影响 一个类存在两个(或多个)独立变化的维度 不希望使用继承/多继承导致系统类的个数急剧增加 优点 分离抽象接口和实现部分 取代多继承方案,极大减少子类的个数 提供拓展性,符合开闭原则 缺点 增加系统的理解与设计难度 很难正确识别出系统中两个独立变化的维度 组合模式组合模式==&gt;可以类比成树形结构图. 树形结构图分为结构抽象类，包含动作方法,然后分为叶子类以及容器类，和文件系统差不多，一个文件夹中有文件和文件夹，文件夹中还有文件……,它们都属于结构抽象类的子类.实现结构抽象类的方法,一般有operation这个方法,如果抽象类只有这个方法,那么就叫安全组合模式(也就是叶子类和容器类不全部实现),如果有add,remove,get还有operation方法那就是透明组合模式(叶子类和容器类全部实现).其中operation方法都是遍历容器类中的集合类，在客户端类中只需调用最顶的树. 适用模式 能够分离出叶子对象和容器对象(DOM去操作一个由组合模式搭起来的树型结构) 有整体和部分的层次结构 优点 定义分层次的差异，忽略层次差异 客户端可以一致性地使用组合结构或其中当个对象,简化客户端代码 新增叶子和容器类，符合开闭原则， 可以一直递归下去形成复杂的树状结构 缺点 很难对容器中的构件类型进行限制.(限制不了某个叶子/容器类的注入) 分类 透明组合模式 抽象组件Component声明了所有管理成员对象的方法.叶子类和容器类都能实现 缺点:不够安全 安全组合模式 抽象组件Component中没有声明任何管理成员对象的方法,但是容器类实现了管理成员对象的方法. 缺点:不够透明. 装饰模式可以在不改变一个对象的情况下新增额外行为. 一个类的对象嵌入另一个新对象中，由另一个对象来决定是否调用嵌入对象的行为并拓展新的行为,这个新的对象就叫装饰类,装饰类和被装饰类必须实现相同的构件接口. 首先先创建一个构件接口，只有operation方法,而后被装饰类和装饰类继承这个接口并且实现方法,被装饰类也就是原来的对象,直接实现方法就行.但是装饰类就要和这个构件接口的类形成聚合关系,然后重写的operation的方法是用来调用这个成员变量中的operation方法.然后创建一些具体装饰类,这些类都继承上面的装饰类,接着重写构造方法和operation方法,以及新添加的功能,在operation方法中调用新添加的功能方法. 透明装饰类客户端程序不声明具体装饰类和具体构件类,全部都声明抽象构件接口. (可以反复多次装饰,但是不能使用具体装饰类中的方法) 半透明装饰类客户端程序允许用户声明具体装饰类和具体构件类，这样可以调用具体装饰类中新增的方法. (不可以反复装饰) 适用模式 在不影响其他对象的情况下,以动态/透明的方式给单个对象添加职责 不能用继承/继承不利于系统维护和拓展时 优点 拓展对象的功能,装饰模式比继承更加灵活,不会导致类的个数快速增加 通过一种动态的方式来拓展一个对象的功能 多次装饰 用户可以根据需要增加新的具体构件类和具体装饰类,符合开闭原则 缺点 会产生很多小对象,影响性能 难排错 外观模式用户只需要直接与外观类交互，用户与子系统之间的复杂关系由外观角色来实现,降低系统的耦合度.但是外观了不会产生任何活动. 子系统的类都以关联形式连接外观类,客户端直接调用外观类. 适用模式 一系列复杂的子系统提供一个简单入口 客户端与多个子系统之间存在很大的依赖性 可以定义系统中每一层的入口,降低耦合度 优点 减少客户端要处理的对象数目 子系统与客户端之间松耦合关系 一个子系统的修改对其他子系统没有任何影响 缺点 不能很好限制客户端直接适用子系统类 如果设计不当,增加新的子系统可能需要修改外观类的源代码，违背开闭原则. 代理模式通过引入一个新的对象来实现真实对象的操作,新的对象时真实对象的替身,客户端只需访问那个新的对象就行，那个新的对象是代理类.代理模式虽然和外观模式差不多但是代理模式是当代理的同时要干活,和装饰模式又一样，装饰模式是对对象的争强，而代理模式是对对象的限制或者控制. 首先创建一个抽象主题类，让真实对象和代理对象都实现这个抽象类(含有一定的方法),将代理对象与真实对象形成组合关联关系,然后代理对象调用成员变量中的方法,并且添加一点限制来控制这些方法. 适用环境 远程代理 虚拟代理 缓冲代理 保护代理 智能引用 优点 协调调用者和被调用者,降低耦合度 增加和更换代理类无限修改源代码,只需要新增一个类继承抽象类,符合开闭原则 缺点 可能会变慢(保护代理) 可能会很复杂(远程代理) 强制代理通过真实对象找代理对象 动态代理代理类不再固定,而是动态生成. 行为型模式不仅仅关注类和对象本身,还关注它们之间的相互作用和职责划分. 类行为型模式(继承关系) 通过多态方式分配父类与子类的职责. 对象行为模式(关联关系) 通过对象关联等关系等方式分配两个/多个类的职责. 职责链模式避免请求发送者与接收者耦合在一起,让多个对象都有可能接收请求,并且沿着这条链传递请求,直到有对象处理它. 类似于链的关系，先创建一个抽象类，这个抽象类中有一个protected的自身抽象类的属性,相当于自关联,这个成员变量相当于指针指向下一家,当然还有个构造方法用来注入值，然后在设置一个抽象方法中参数用来给传送链上的数据.链上各个类继承这个抽象类,然后重写方法,并且设置if-else处理请求，如果不满足就调用父类中的成员变量抽象类的抽象方法并且传入参数,用来寻找下一家.在客户端中,先用抽象类声明，在用链上的类来实现，在用抽象类中构造方法注入下一家，来达到链的作用. 适用环境 有多个对象可以处理同一个请求. 向多个对象中的一个提交一个请求 可动态指定一组对象处理请求. 优点 降低系统的耦合度 简化对象连接 给对象职责的分配带来更多灵活性 增加一个新的具体请求处理者时无限改原来代码 缺点 不保证请求一定被处理 性能受一定影响 设计不当,会产生死循环. 迭代器模式根据单一职责原则，迭代器模式有两个东西,一个基本功能是存储数据,另一个是遍历数据.创建一个聚合类用来存储数据，再创建一个迭代器类来遍历聚合类的数据，两个都是抽象类，在聚合抽象类中有一个方法是返回迭代器类，迭代器负责那是迭代方法. 适用环境 访问聚合对象但是不暴露内部内容 为一个聚合对象提供多种遍历方式 为遍历不同的聚合结构提供一个统一的接口 优点 不同的方式遍历一个聚合对象 简化聚合类 由于抽象类的关系，新增聚合类和迭代器类都很方便,符合开闭原则. 缺点 类的个数成对增加 抽象迭代器设计难度大 命令模式把一个请求封装成一个对象. 命令模式可以对发送者和接收者完全耦合,发生者与接收者之间没有直接引用关系,发送请求的对象只需要指定如何发送请求,而不必指定如何完成请求. 先创建一个接收者类，然后创建一个抽象命令类,然后创建具体命令类都继承抽象命令类,重写方法，并且与接收者类关联，然后再方法中调用其中一个方法，以此类推，一个请求一个对象,然后创建一个控制类,与每个命令对象组合关系,然后一个命令对象一个方法，最后客户端直接调用控制类，并调用里面的方法. 适用环境 将请求调用者和请求接收者解耦 需要不同时间指定请求,将请求排队和执行请求 支持命令的撤销(Undo)操作和恢复(Redo)操作 一组操作在一起形成宏命令 优点 降低耦合度 新命令很容易添加,符合开闭原则 可设计一个命令队列/宏命令(组合命令) 可设计撤销和恢复 缺点 具体命令类太多 命令模式对象间的一种一对多的关系,当一个对象状态(被观察者)发送改变,其依赖对象(观察者)都会得到通知. 首先创建一个被观察抽象类,类中有一个protected集合类作为成员变量负责装观察者类,并且有方法负责对其增加或删除,再有一个抽象方法个给子类实现对象变化后，遍历上面的结合类，并调用其中的观察者类的方法.再创建一个观察者抽象类,只包含接到反映后做出的动作(方法).子类再实现.最后客户端实现被观察者类和观察者类，将观察者类装入被观察者类中，再调用被观察者中的那个遍历(抽象)方法. 适用环境 抽象模式有两个方面,一个方面依赖另一个方面 一个对象的改变将导致一个或多个其他对象发送改变 需要创建一个触发链 优点 表示层和数据逻辑层的分类 被观察者和观察者之间建立一个抽象的耦合 支持广播通信 符合开闭原则 缺点 观察者通知会花费很多时间 可能存在循环依赖问题 观察者不知道所观察的目标对象怎么发送变化. 状态模式一个对象的行为取决于一个/多个动态变化的属性,这个属性也叫状态.在不同状态下行为页不一样. 首先先创建一个这个对象类,然后创建一个抽象状态类,在对象类中,有它对应的属性以及抽象状态类作为成员变量,当然给它设置get/set方法,以及在构造方法中给予初始值,以及实例化后面抽象状态类子类中的第一个状态类,抽象状态类必须存在一个protected的对象类用来传递状态和数值，以及很重要的用来判断状态的抽象方法，这个抽象方法可以通过对象类的数值来判断，方法中用if-else语句判断,如果满足条件就设置这个抽象类中的成员变量中的对象类中的抽象状态类的值为抽象类其他子类,实现状态转换,在抽象状态类的子类中,有构造方法以及那个重写的判断状态的方法,还有其他变化方法,在构造方法中，参数是抽象状态类,用来传值，并且把参数类中的值给/设置本类中父类抽象类中的值.在其他变化方法中，当判断值改变后要调用状态改变的那个抽象方法,来判断状态是否需要转换. (状态转换方法可以放在对象类中也可也放在抽象状态类中) 适用环境 对象大的行为依赖它的状态(某个属性值),状态的改变将导致行为的变化. 代码中保护大量与对象状态有光的条件语句. 优点 封装了状态的转换规则，对状态转换代码进行集中管理 将所有与某个状态有关的行为放在一个类 允许状态转换逻辑与状态对象合成一体,而不是提供一个巨大的条件语句快. 多个环境对象共享一个状态对象,减少系统中对象的个数 缺点 增加类和对象的个数 设计不当容易造成程序结构和代码混乱 对开闭原则的支持不太友好. 策略模式实现某个目标的途径不止一条. 定义一系列算法,将每个算法封装起来,然后让它们可以相互替换. 创建一个环境类，一个策略抽象类，策略抽象类就定义一个抽象方法，让具体策略类来重写，并且注入到环境类，环境了再调用那个抽象方法. 适用环境 动态选择算法 避免适用难以维护的多重条件选择语句 用户不知道相关算法,提供算法的保密性与安全性. 优点 完美支持开闭原则 提供管理相关的算法族的办法 可以替代继承关系的办法 避免多次条件的选择语句 提供算法复用机制 缺点 客户端必须知道所有的策略类 会产生很多具体策略类 无法同时使用多个策略类. 模板方法模式分为两个 模板方法：一个有顺序流程 基本方法:这个流程里面的每个步骤 抽象方法:在这个步骤有不同做法(在不同继承的类重写不同的方法) 具体方法:在这个步骤都是这个固定做法 构造方法:这个方法做还是不做 isXXX或者hasXXX类型方法：方法返回boolean 空方法：直接不写方法里面的内容(也就是不做)，如果想做就在继承的子类中重写方法 适用类型 一次性实现一个算法的不变部分,并将可变的行为留给子类实现 公共父类,避免代码重复 通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的方向控制. 优点 子类实现详细的处理算法时并不会改变算法中步骤的执行次序 公共行为放在类中，通过其子类来实现不同的行为 可实现反向控制结构,通过子类覆盖父类的构造方法来决定某一特定步骤是否需要执行 符合开闭原则和单一职责原则 缺点 父类的可变基本方法太多,导致类的个数增加","link":"/Liust1918.githud.io/2022/12/04/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"逆波兰表达式求值","text":"150. 逆波兰表达式求值 - 问题描述（这部分可以直接复制）根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 - 解题思路逆波兰表达式是什么以1+2为例 前缀表达式:波兰表达式 +12 中缀表达式: 1+2 后缀表达式:逆波兰表达式 12+ 为什么选择栈为什么选择栈，而不选择队列，我先从双方特性看 栈: 先进后出 后进先出 队列： 先进先出 后进后出 逆波兰表达式 是先找到符号，然后把符号前面两个数字进行操作，如果有嵌套的话，还要再用. 以12+3*为例（ (1+2)*3） 如果用队列，那么1+2得到3后就不能往回乘了 如果用栈,就可以把1+2得到3再重新装回栈，后面再遇到符号就可以进行操作了. 所以这题其实就在考你会不会用栈- 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）12345678910111213141516171819202122232425262728293031323334private int MyCompareTo(int right,int left,String token){ switch (token){ case &quot;+&quot;: return left+right; case &quot;-&quot;: return left-right; case &quot;*&quot;: return left*right; case &quot;/&quot;: return left/right; default: return Integer.valueOf(token); }}public int evalRPN(String[] tokens) { //用现成的栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); //对数组进行循环 for (String token : tokens) { //判断是不是+-*/符号 if (&quot;+-/*&quot;.contains(token)) { //主要栈先进后出的特性，第一个出来是右边的数 //这里进行运算并重新入栈 stack.push(MyCompareTo(stack.pop(), stack.pop(), token)); } else { //不是符号 是数字就入栈 stack.push(Integer.valueOf(token)); } } //最后输出结果 return stack.pop();} - 时间及空间复杂度分析复杂度为o(n) - 讨论与总结 对栈有更好的理解 对栈的实践更加深","link":"/Liust1918.githud.io/2022/12/04/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"title":"买卖股票的最佳时机IV","text":"188.买卖股票的最佳时机 IV - 问题描述（这部分可以直接复制）给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 - 解题思路先搞清买入和持有股票 买入:一开始现金是0，你一买就是负数-prices[i] 持有:可以是这一天买入,也可以是昨天买入(今天保持昨天的状态) 1.确定dp数组和下标含义如果做过买卖股票的最佳时机 III的话，你会发现买入和卖出的时候两天为一组，除了第一列是0,例如 第0次操作 第1次操作(买入) 第2次操作(卖出) 第3次操作(买入) 第4次操作(卖出) 0 -3 0 -3 0 0 -3 0 -3 0 0 -3 2 -3 2 0 0 2 2 2 0 0 2 2 2 0 0 3 2 5 0 0 3 2 5 0 0 4 2 6 由此我们可以分为3种操作 没有操作 买入操作2*k+1 卖出操作2*k 由此得出 123dp[i][0]=0dp[i][2*k+1]的意思是第i天买入股票/持有(昨天买的)股票的所需的现金dp[i][2*k]的意思是第i天卖出股票/不卖出(保持昨天卖的情况)股票所得的现金 2.确定递推公式 买入: 昨天买入股票需要的现金 1dp[row-1][col] 昨天卖了，得到的钱买今天股票后所需要的现金 1dp[row-1][col-1]-prices[row] 卖出: 昨天卖出得到的钱 1dp[row-1][col+1] 昨天买入需要现金扣掉今天卖出股票所得的钱 1dp[row-1][col]+prices[row] 3.初始化dp数组如果做过买卖股票的最佳时机 III的话，你会发现一开始只要买入的天初始化就行了，题目也描述了不能今天买，今天卖,所以一开始卖出的那天是不用管的. 转化一下就是，奇数下标2*k+1需要赋值prices[0] 4.确定递归顺序 天数直接从上到下,从0到到i-1天 由买卖股票的最佳时机 III,可知道，一般是买入卖出这两天为一组,也就是从奇数下标开始,并且遍历奇数下标.来处理数据. 5.举例推导dp数组0 -3 0 -3 0 | 30 -3 0 -3 0 | 30 -3 2 -3 2 | 50 0 2 2 2 | 00 0 2 2 2 | 00 0 3 2 5 | 30 0 3 2 5 | 10 0 4 2 6 | 4 - 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static int maxProfit(int k, int[] prices) { //先判断空 if(prices.length==0){ return 0; } //记录预估数组的长度 int len = prices.length; /* 1.创建dp的二维数组 dp[i][]的意思是第i天 dp[i][2*k+1]的意思是第i天买入股票/持有(昨天买的)股票的所需的现金 dp[i][2*k]的意思是第i天卖出股票/不卖出(保持昨天卖的情况)股票所得的现金 */ int[][] dp=new int[len][2*k+1]; /* 3.初始化数组 一开始2*k+1（奇数）一定是买入的,所以会赋值-prices[0] 由于题目规定不允许当天买当天卖,所以2*k(偶数)是不赋值,默认为0 */ for(int row=1;row&lt;k*2;row+=2){ dp[0][row]=-prices[0]; } /* 4.遍历顺序 首先是遍历天数i，从上到下 然后遍历买入和卖出的那两操作 也就是从左到右,从1开始，奇数下标处理数据 */ for(int row=1;row&lt;len;row++){ for(int col=1;col&lt;k*2;col+=2){ /* 2.遍历方式 在2*k+1的奇数买入股票, 比较 前一天买入的负数价格dp[row-1][col] 前一天卖出股票后得到的现金再去买今天的股票dp[row-1][col-1]-prices[row] 在2*k的偶数天卖出股票 比较 前一天卖出的股票所得的现金dp[row-1][col+1] 前一天买入股票所需的现金,在今天卖出所得的现金dp[row-1][col]+prices[row] */ dp[row][col]=Math.max(dp[row-1][col],dp[row-1][col-1]-prices[row]); dp[row][col+1]=Math.max(dp[row-1][col+1],dp[row-1][col]+prices[row]); } } //打印dp数组,用于检查错误 for(int a=0;a&lt;len;a++){ for(int b=0;b&lt; dp[0].length;b++){ System.out.print(dp[a][b]+&quot;\\t &quot;); } System.out.print(&quot;| &quot;+prices[a]); System.out.println(); } //输出最后一天所得的最大现金数 return dp[len-1][2*k];} - 时间及空间复杂度分析 时间复杂度：O(n^2) 空间复杂度：O(n^2) - 讨论与总结做动态规划的题目一般需要五个步骤 确定dp数组和下标的含有 确定递推公式 初始化dp数组 确定递归顺序 举例推导dp数组 当然有时候需要仔细读懂题目的规则，不然容易陷入条件太多死循环.","link":"/Liust1918.githud.io/2022/12/04/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"},{"title":"网络延迟时间","text":"743. 网络延迟时间 - 问题描述（这部分可以直接复制）有 n 个网络节点，标记为 1 到 n。 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 - 解题思路大体思路使用Dijkstra算法,Dijkstra算法求非负权图上单源最短路径，然后在最短的基础上，计算比它大一点，然后源点到目标点的所有路径，求一个最大值，然后输出.当然Dijkstra在这里本质上贪心和广度优先搜索. 当然由于要选择最大的路径，所以需要规定走过的点不走. 论证算法的正确性设置起点是是根节点,然后比较下一个子节点和下一个子节点与起点权重之和的最小值.获取小的那个.然后再设置这个子节点为根节点,以此类推.从局部最优解获得全局最优解. 最出全局权重最小的路径.当然这里要全列出来，求最大路径. 1子节点[j] = Math.min(子节点[j], 二维数组形式的树[根节点][j] + 子节点[根节点]); - 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static int networkDelayTime(int[][] times, int n, int k) { // 初始化二维数组 int[][] matrix = new int[n][n]; for(int i=0; i&lt;n; ++i){ Arrays.fill(matrix[i], -1); } for(int[] t : times){ int x=t[0]-1; int y=t[1]-1; System.out.println(x+&quot; &quot;+y); matrix[t[0] - 1][t[1] - 1] = t[2]; } boolean[] vis = new boolean[n]; int[] time = new int[n]; // 初始化时间为无穷大，此处用INF代表无穷大 final int INF = Integer.MAX_VALUE / 2; Arrays.fill(time, INF); int begin = k - 1; time[begin] = 0; // Dijkstra算法计算最短时间（最短路径） for(int i=0; i&lt;n; ++i){ // vis[i]为true代表点i曾经作为过起点 vis[begin] = true; // 计算从出发点到其余点的最小距离 for(int j=0; j&lt;n; ++j){ if(j == begin || matrix[begin][j] == -1){ continue; } time[j] = Math.min(time[j], matrix[begin][j] + time[begin]); } // 找到时间最小且未被访问的顶点 int min = Integer.MAX_VALUE; for(int j=0; j&lt;n; ++j){ if(j != begin &amp;&amp; !vis[j] &amp;&amp; time[j] &lt; min){ min = time[j]; begin = j; } } } int ans = -1; for(int i=0; i&lt;n; ++i){ if(!vis[i] || time[i] == INF){ // 有节点没有被访问到或者时间为无穷大 return -1; } ans = Math.max(ans, time[i]); } return ans;} - 时间及空间复杂度分析 时间复杂度：O(n^2+m) 空间复杂度:O(n^2) - 讨论与总结Dijkstra算法可以求非负权图上单源最短路径. Dijkstra算法本质上有点类似于贪心算法和广度优先搜索的结合. 广度优先搜素的相关代码并不是太熟练.","link":"/Liust1918.githud.io/2022/12/04/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/"},{"title":"所有路径可能","text":"797.所有路径可能 - 问题描述（这部分可以直接复制）给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） 二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。 译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。 - 解题思路当此时的下标或者点为数组的长度，则将此时临时集合添加到结果集合中. 如果没用超过，就继续递归 大概思路是 当我进入第一层数组，遍历数组中的值，按照值跳到对应层数的数组中. 然后如此递归，像一颗树一样.当执行完或者return；的时候，就回到上一个方法体. 将临时集合中最后一个数剔除，然后继续执行for循环. 最后将得到的结果集输出. 伪代码 回溯函数模板返回值以及参数 1void myAllPathsSourceTarget(int[][] graph,int startIndex) 回溯函数终止条件 1startIndex==graph.length-1 回溯搜索的遍历过程 123456for(int i=0;i&lt;graph[startIndex].length;i++){ int nextIndex=graph[startIndex][i]; path.add(nextIndex); myAllPathsSourceTarget(graph, nextIndex); path.removeLast(); } - 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）12345678910111213141516171819202122232425262728293031323334353637383940//主方法public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) { //给开头第一次进入的点添加进临时集合 path.add(0); //开始递归函数 设置从点0开始 myAllPathsSourceTarget(graph,0); //返回最后结果集合 return result;}//结果集List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();//临时集合(保存临时数据,符合条件后加入到结果集中)LinkedList&lt;Integer&gt; path=new LinkedList&lt;&gt;();//传入二维数组，以及开始点public void myAllPathsSourceTarget(int[][] graph,int startIndex){ //停止条件 //当传入点和数组的长度-1相等(也就是找到最后一个点时候) if (startIndex==graph.length-1) { //将此时的临时数组添加到结果集合中 result.add(new ArrayList&lt;&gt;(path)); //跳出方法 return; } //横向遍历 //遍历这startIndex层中可以去的点 //例如第0层[1,2] 意味着0-1 0-2 for(int i=0;i&lt;graph[startIndex].length;i++){ //通过下标获得点的值 int nextIndex=graph[startIndex][i]; //添加点的值 path.add(nextIndex); //继续递归 myAllPathsSourceTarget(graph, nextIndex); //回溯，撤销处理结果 path.removeLast(); }} - 时间及空间复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) - 讨论与总结 回溯和递归是相辅相成的。 回溯法的效率，回溯法其实就是暴力查找，并不是什么高效的算法。 组合是不强调元素顺序的，排列是强调元素顺序。","link":"/Liust1918.githud.io/2022/12/04/%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%8F%AF%E8%83%BD/"},{"title":"救生艇","text":"881. 救生艇 - 问题描述（这部分可以直接复制） 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。 返回载到每一个人所需的最小船数。(保证每个人都能被船载)。 - 解题思路可以直接这样想,首先题目规定保证每个人都能被船载，也就是说人的体重都是比限制要小或者相同的.那么我们就不能考虑大于的情况.然后按照简单常识来考虑，最小次数一般就是最重和最轻那个组合在一起，然后一起运输，这样是最省次数的,当然如果最重那个刚好和限制相同或者两者相加比限制要大,那么我们就一个人运输一次.整个过程大概这样. 将问题分解为若干个子问题每次我们都只考虑船上是载1个人还是2个人.也就是选择出最重和最轻的那两个,还是选择最重那一个. 找出适合的贪心策略我们要先找出一艘船里面两个人，要最重和最轻.在此之前,我们需要个数组排序，从小到大进行排序.然后我们先不用考虑整个数组如何.我们直接考虑两端的人直接就是一个小问题，然后再向内无限缩小. 求解每一个子问题的最优解先获取两个的重量，先相加，再与限制进行比较. 比限制要大，就让最大也就是最右边的先上船. 比限制要小，就两个都上船. 将局部最优解堆叠成全局最优解每次载到一个以上的人就统计一次.最后输出总统计. - 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package Greedy.LeetCode881;import java.util.Arrays;/** * @author liuyulong * @create 2021-10-17 13:55 * @create 2021-十月 星期日 * @project Algorithms */public class T2021_10_17 { public static void main(String[] args) {// int[] people = {1, 2}; int[] people = {3,2,2,1};// int[] people = {3,5,3,4}; int limit=3;// int limit=5; int i = numRescueBoats(people, limit); System.out.println(i); } public static int numRescueBoats(int[] people, int limit) { //给体重排序(从小到大) Arrays.sort(people); //开始点 int start=0; //结束点 int end=people.length-1; //统计量 int result=0; //从两端开始先内循环 while (start&lt;=end){ //比较是载两个人(最轻和最重)还是载一个人(最重),也就是两个人比较限制. if(people[start]+people[end]&lt;=limit){ //向内下一个最轻 start++; } //因为无论一个还是两个人都上了船,都上了一次船 result++; //重已经被先送走了(无论是两个人还是一个人，最终那个一定会被带走) //所以会放在if语句外 end--; } //输出总统计量 return result; }} - 时间及空间复杂度分析 时间复杂度：O(n log n) 空间复杂度：O(log n) - 讨论与总结对于贪心算法,其实没有多少套路. 一般从常识出发，然后看看有没有反例，如果有反例，就用动态规划. 贪心算法本质上就是局部最优解推出全局最优解. 对于这道题目我一开没有考虑可以最轻和最重的组合，只考虑最重的问题.有点类似于LeetCode.455的分发饼干问题.导致错了一次.","link":"/Liust1918.githud.io/2022/12/04/%E6%95%91%E7%94%9F%E8%89%87/"},{"title":"解数独","text":"37.解数独 - 问题描述（这部分可以直接复制）编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 提示： board.length == 9board[i].length == 9board[i][j] 是一位数字或者 ‘.’题目数据 保证 输入数独仅有一个解 - 解题思路二维递归 对列递归，因为要列不重复 对行递归，因为要行不重复 对3x3表也布恩那个重复 三步回溯 递归函数以及参数 这一步与之前设置为空不同，这里设置为boolean返回值，反正只要找到符合的点返回true就行了. 递归终止条件 由于上面的只要有空就填入，最后一定会填完.只要填完的时候返回true，就可以达成终止条件的效果. 递归单层搜索逻辑 在一个空里面，选择从1到9填，一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性.不行再回溯设置成空. - 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution { public void solveSudoku(char[][] board) { solveSudokuHelper(board); } private boolean solveSudokuHelper(char[][] board){ //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列， // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」 for (int i = 0; i &lt; 9; i++){ // 遍历行 for (int j = 0; j &lt; 9; j++){ // 遍历列 if (board[i][j] != '.'){ // 跳过原始数字 continue; } for (char k = '1'; k &lt;= '9'; k++){ // (i, j) 这个位置放k是否合适 if (isValidSudoku(i, j, k, board)){ board[i][j] = k; if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回 return true; } board[i][j] = '.'; } } // 9个数都试完了，都不行，那么就返回false return false; // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！ // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」 } } // 遍历完没有返回false，说明找到了合适棋盘位置了 return true; } /** * 判断棋盘是否合法有如下三个维度: * 同行是否重复 * 同列是否重复 * 9宫格里是否重复 */ private boolean isValidSudoku(int row, int col, char val, char[][] board){ // 同行是否重复 for (int i = 0; i &lt; 9; i++){ if (board[row][i] == val){ return false; } } // 同列是否重复 for (int j = 0; j &lt; 9; j++){ if (board[j][col] == val){ return false; } } // 9宫格里是否重复 int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &lt; startRow + 3; i++){ for (int j = startCol; j &lt; startCol + 3; j++){ if (board[i][j] == val){ return false; } } } return true; }} - 时间及空间复杂度分析 时间复杂度：O(n) 空间复杂度:O(n) - 讨论与总结与之前的回溯三步不一样，这里多了一维的递归，要二维递归，而且返回值不再是常认为的空，而是boolean.","link":"/Liust1918.githud.io/2022/12/04/%E8%A7%A3%E6%95%B0%E7%8B%AC/"},{"title":"打开转盘锁","text":"752.打开转盘锁 - 问题描述（这部分可以直接复制）你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。 - 解题思路双BFS首先转轮可以向上也可以向下转，也就是可以从0到1，也可以从0到9，如果用单BFS，会导致遍历的层次增加，所有要有两边一起BFS，这样可以达到不超时的效果.当遇到不符合的时候，就切断，层次遍历的时候首先判断是否和目标相同，再遍历下一层并且查找有没有禁止的，把未禁止的进入到在队列里面. - 算法描述（可以使用代码加注释、伪代码、纯文字描述均可）123456789101112131415161718192021222324252627282930313233343536public static int openLock(String[] deadends, String target) { //全部转换为整型计算 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(String str: deadends){ set.add(Integer.parseInt(str)); } if(set.contains(0)) return -1;//如果初始元素就是禁止的，返回-1 int tar = Integer.parseInt(target); if(tar == 0) return 0;//目标元素为初始元素 int res = 0; boolean[] visit = new boolean[10000];//记录访问标志的数组 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(0); while(!list.isEmpty()){//只要没找到目标元素或所有元素未遍历完 int size = list.size(); for(int k = 0; k &lt; size; ++k){//层次遍历 int cur = list.poll(); if(cur == tar) return res;//找到目标元素返回 for(int i = 1; i &lt;= 1000; i *= 10){//添加当前元素可达的下一元素 int next = cur/i%10 == 9 ? (cur - 9 * i) : cur + i;//在一个位上加1后构成的数字 if(!visit[next]){ visit[next] = true; if(!set.contains(next)) list.offer(next); } int pre = cur/i%10 == 0 ? (cur + 9 * i) : cur - i;//在一个位上减1后构成的数字 if(!visit[pre]){ visit[pre] = true; if(!set.contains(pre)) list.offer(pre); } } } ++res;//第几次添加元素 } return -1;} - 时间及空间复杂度分析 时间复杂度:O(n) 空间复杂度:O(n) - 讨论与总结 复习到BFS算法 学习到BFS的拓展的双BFS","link":"/Liust1918.githud.io/2022/12/04/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"},{"title":"最小K个数","text":"面试题 17.14. 最小K个数 问题描述设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。 示例： 输入： arr = [1,3,5,7,2,4,6,8], k = 4输出： [1,2,3,4] 解题思路我们知道堆其实就是一个完全二叉树 对于这个问题 选择大顶堆 如果用小顶堆进行维护会很麻烦 如果用大顶堆的说，把大的放进去没有意义，毕竟题目是选择最小，把小的放进去才有意义，反正最大就是根节点，下面都是比它小的，那么我们设置这个二叉树只有k个节点，然后一路替换根节点再维护整个大顶堆，最后比较完后，整个二叉树就是k个节点的最小值.并且不要求顺序，反正筛出来就行. 采用自下而上的维护方式 针对根节点来说，如果我们采用大顶堆，根节点以下都是比根节点小的数.如果我们从非叶子节点（节点数/2-1）开始比较(叶子节点的子树都是空),从最后一个非叶节节点开始，子树都是比根节点小的，那么一层一层的，都是比下面的大，这样可以保证比根节点都是比下面的大. 首先构建个数为k的大顶堆我只要k个数，那么先放入k个数，然后维护成大顶堆. 由于根节点比下面所有子树都大，所有找比这个根节点小的，替换掉他. length-k个数进行维护这个大顶堆加入的数比这个根节点还小，那么替换根节点，再和下面的子树比较，比他大的继续替换，最后成一个新的大顶堆，然后一路这样，把比根节点还小的加入进去,最后就会得到一个全是最小数的二叉树 针对的都是根节点算法描述12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package test;import java.util.Arrays;/** * @author liuyulong * @create 2021-09-12 16:49 * @create 2021-九月 星期日 * @project Algorithms *///k位最小数(堆排序实现)public class Main { public static void main(String[] args) { int[] arr ={1,3,5,7,2,4,6,8}; int k = 4; int[] ints = smallestK(arr, k); Arrays.stream(ints).forEach(System.out::println); } public static int[] smallestK(int[] arr, int k) { //如果k超过原数组或者直接根 就返回空数组 if(arr.length&lt;k||k==0){ return new int[0]; } int[] ints = new int[k]; //构建个数为k的数组 for(int a=0;a&lt;k;a++){ ints[a]=arr[a]; } //对非叶子节点进行维护，将个数为K的数组维护成大顶堆 //叶子节点没有子 //自下而上进行维护 for(int i=k/2-1;i&gt;=0;i--){ initSort(i,ints,k); } //上面已经把个数为k的数组维护成大顶堆 //然后再length-k个数与根节点比较， //比根节点大的就没必要放进去了 //把比根节点的小的放进去 //把根节点抹去，放入小的 //然后维护大顶堆 //最后这个个数为k的数组，也就是整个大顶堆 //就是k个最小数 for(int i=k;i&lt; arr.length;i++){ //找比根节点小的 if(arr[i]&lt;ints[0]){ //把根节点替换成小的 ints[0]=arr[i]; //维护大顶堆 initSort(0,ints,k); } } return ints; } /** * 要针对根节点进行维护 * @param RootIndex * @param ints * @param length */ private static void initSort(int RootIndex,int[] ints,int length){ //保存根节点 int temp=ints[RootIndex]; //对根节点的左子树进行判断，看是不是比根节点大，如果大于，就替换. for(int index=RootIndex*2+1;index&lt;length;index=index*2+1){ //原本是在左子树,但是看看右子树有没有，并且右子树比左子树大吗 //如果大于就把index 像指向右子树(原本指向左子树) if(index+1&lt;length &amp;&amp; ints[index]&lt;ints[index+1]){ index++; } //判断根节点与左/右子树 谁大 //谁大谁在根节点 if(ints[index]&gt;temp){ //子树比根节点大,把子树的值放到根节点 ints[RootIndex]=ints[index]; //如果根节点左子树确实比根大，但是可能也会比左子树的左子树大以及后续，所以 //一个思路 //先不把根节点和比它大的子树换下去，而是把左子数换成根节点，然后一路再与上面保存temp比较，直到找到比原来根节点小的. RootIndex=index; }else { //如果根节点最大，就不换了 break; } } //比较到最后(直到找到比原来根节点小的) 再把原来的根节点换到那里 ints[RootIndex]=temp; }} 时间及空间复杂度分析 维护大顶堆:log(k) 对length-k个数进行维护:n-k 总共:O(log(k)*(n-k)) 讨论与总结 对堆的基本概念有一般了解 对堆排序的尝试","link":"/Liust1918.githud.io/2022/12/04/%E6%9C%80%E5%B0%8FK%E4%B8%AA%E6%95%B0/"},{"title":"最大二叉树","text":"最大二叉树 问题描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 解题思路这里题没给栈，就去想递归. 若两棵树都为null，就返回0 若两棵树不为null，就+1 判断左树大还是有树大 进行套 算法描述思路产物1234567 if(root==null) return 0; else if(root.left==null&amp;&amp;root.right==null) return 1; elsereturn 1+(maxDepth(root.left) &gt;maxDepth(root.right)?maxDepth(root.left):maxDepth(root.right)); 结果结果是对的，但是时间超了 继续改进原来可以用Math包 1234if(root==null) return 0; elsereturn 1+(Math.max(maxDepth(root.left),maxDepth(root.right))); 时间及空间复杂度分析时间复杂度O(Log2n)&lt;时间复杂度&lt;O(n) 空间复杂度O(N) 讨论与总结 在Leetcode使用是可以用Math包的 加深对二叉树的概念 二叉树遍历方法加深印象","link":"/Liust1918.githud.io/2022/12/04/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"SSM","text":"SSM 整合Mybatis-plus和SpringMVC添加嵌入式servlet容器jetty在pom.xml中添加插件 1234567891011121314151617181920212223&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.4.43.v20210629&lt;/version&gt; &lt;configuration&gt; &lt;!-- 加载webapp文件下的html css js --&gt; &lt;webAppSourceDirectory&gt;src/main/webapp&lt;/webAppSourceDirectory&gt; &lt;httpConnector&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/httpConnector&gt; &lt;!-- 解决热更新问题--&gt; &lt;webApp&gt; &lt;_initParams&gt; &lt;org.eclipse.jetty.servlet.Default.useFileMappedBuffer&gt;false&lt;/org.eclipse.jetty.servlet.Default.useFileMappedBuffer&gt; &lt;/_initParams&gt; &lt;/webApp&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 添加SpringMVC配置引入依赖123456&lt;!-- springMvc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.8&lt;/version&gt;&lt;/dependency&gt; 添加webapp，WEB-INF，web.xml文件配置结构 创建webapp文件 创建WEB-INF文件：存放各种静态文件 创建web.xml 配置DispatcherServlet：对系统中所有请求进行拦截，Servlet自动加载applicationContext.xml文件,并且在Web容器加载的时候优先加载 解决中文乱码问题：characterEncodingFilter 在resource创建applicationContext.xml文件 启动组件扫描：context:component-scan 启动SpringMVC的注解：mvc:annotation-driven 响应文本输出使用UTF-8 不执行静态文件启动(提供执行效率)：mvc：default-servlet-handler ![屏幕截图 2022-01-14 154545](D:\\TyporaOfimage\\屏幕截图 2022-01-14 154545.png) web.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动等级 0最大--&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 拦截请求范围--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置文件整体含义: DispatcherServlet对系统中所有请求进行拦截 Servlet自动加载applicationContext.xml文件 并且在Web容器加载的时候，优先加载. --&gt; &lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; applicationContext.xml文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.xxxx.ssm&quot;/&gt; &lt;!-- 启动Spring MVC的注解模式--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;!-- 响应输出的文本被浏览器作为html进行解析，使用字符集utf-8--&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 对静态文件(html，css,js)不扫描 提高执行效率--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; 添加序列化JSON依赖在pom.xml添加依赖12345678910111213141516&lt;!-- spring的json输出--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt; 添加模板引擎Freemark添加依赖123456789101112&lt;!-- 模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring支持模板引擎依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.3.8&lt;/version&gt;&lt;/dependency&gt; 在applicationContext.xml添加配置配置结构 FreeMarker视图解析：FreeMarkerViewResolver 输出客户端设置UTF-8：contentType 指定模板文件后缀：suffix FreeMarker配置：FreeMarkerConfigurer 视图保持路径：templateLoaderPath 设置视图和数据渲染字符集为UTF-8：freemarkerSettings -&gt;defaultEncoding 1234567891011121314151617181920&lt;!-- 在IOC容器初始化时通知SpringMVC默认使用Freemarker进行数据展示--&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;!-- 渲染完成的结果向客户端输出的时候设置UTF-8字符集--&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;&gt;&lt;/property&gt; &lt;!-- 指定Freemarker模板文件拓展名--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- freemarker配置文件--&gt;&lt;bean id=&quot;freeMarkerConfigurer&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;!-- 模板引擎文件保存路径--&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt; &lt;!-- 其他模板引擎设置--&gt; &lt;property name=&quot;freemarkerSettings&quot; &gt; &lt;props&gt; &lt;!-- 设置Freemarker脚本和数据渲染时使用的字符集--&gt; &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 创建模板存放文件 在webapp/WEB-INF下创建ftl文件 添加Druid连接池添加依赖123456789101112131415161718&lt;!-- 减少JDBC的操作--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Druid连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Mysql JDBC驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; 在applicationContext.xml中配置 配置DruidDataSource：数据源使用Druid连接池 数据库驱动：driverClassName 数据库连接：url 数据库名：username 数据库密码:password 最大连接数：可以连接的最大数量 初始化连接数量：一开始创建的连接数量 空闲连接数量：当使用了一个连接，就会多生成一个连接保证空闲连接数量，但是不能超过最大连接数量 连接最大等待时间：时间单位ms 测试连接有效性时机 分配连接时：false 连接空闲时：true 连接归还时：false 测试连接有效性的SQL语句：一般用select 1 监控过滤：filters SQL及Web监控：stat 预防SQL注入攻击：wall 日志输出：slf4j 监控连接配置：connectionProperties 开启合并相同SQL：druid.stat.mergeSql=true 慢SQL查询：druid.stat.slowSqlMillis=XXX（单位为ms） 超过xxxms就记录为慢sql 123456789101112131415161718192021222324252627282930313233343536&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- 定义数据库--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;abc123456&quot;/&gt; &lt;!-- 初始化连接池的时候默认创建5个连接--&gt; &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt; &lt;!-- 最大连接数量--&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt; &lt;!-- 数据库空闲连接数最少5个--&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt; &lt;!-- 数据库连接最大等待时间60秒--&gt; &lt;!-- 60000毫秒--&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;/&gt; &lt;!-- 是否在分配连接时测试连接有效性--&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot;/&gt; &lt;!-- 是否在连接空闲状态时测试连接有效性--&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否在连接归还连接时测试连接有效性--&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot;/&gt; &lt;!-- 测试有效性的SQL语句--&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT 1&quot;/&gt; &lt;!-- 监控相关配置 stat SQL及Web监控 wall 预防SQL注入攻击 slf4j 日志输出 --&gt; &lt;property name=&quot;filters&quot; value=&quot;stat,wall,slf4j&quot;/&gt; &lt;!-- 开启合并相同SQL 慢SQL查询:设置执行超过500ms的SQL语句记录为慢SQL --&gt; &lt;property name=&quot;connectionProperties&quot; value=&quot;druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500&quot;/&gt;&lt;/bean&gt; 在web.xml中配置监控 Druid过滤WebStatFilter 将静态内容过滤*.js,.jpg,.css,*.ico 监控入口：/druid/* DruidServlet配置：StatViewServlet 监控入口用户名:loginUsername 监控入口密码：loginPassword 监控路径：/druid/* 123456789101112131415161718192021222324252627282930&lt;!-- Druid连接池监控界面--&gt;&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusion&lt;/param-name&gt; &lt;param-value&gt;*.js,*.jpg,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;DruidServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;loginUsername&lt;/param-name&gt; &lt;param-value&gt;admin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;loginPassword&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 作用和使用什么是连接池 是指创建和管理数据库连接的缓冲池技术，数据库连接被提前创建好等待任何线程的使用。这样可以让SQL执行的更快，并且提供数据连接的效率和方便管理，数据库的连接每次创建都很耗费资源. Druid是什么 阿里巴巴开发 数据库连接池 结合C3PO,DBCP,PROXOOL等DB池的优点 加入日志监控 监控DB池连接 SQL执行情况 使用 输入地址+“/druid” 输入账号和密码登录 查看各种监控 添加Mybatis-plus引入依赖 (v3.1.0必须去掉mybatis和mybatis-spring) 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 在applicationContext.xml配置 开启sqlSessionFactory连接工厂:MybatisSqlSessionFactoryBean 上面的数据源:dataSource mybatis的配置文件位置：configLocation mapper的xml文件位置：mapperLocations 配置Mapper接口类扫描：MapperScannerConfigurer 12345678910111213141516&lt;!-- 定义sqlSessionFactory连接工厂--&gt;&lt;!-- MybatisSqlSessionFactoryBean对Mybatis-Spring整合插件进行了重写和拓展，提供自动生成SQL的功能--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 扫描mapper接口--&gt; &lt;!-- Spring为Mybatis一个新开发方式“Mapper接口” 这个配置用于扫描com.xxxx.ssm包下所有有效的Mapper接口类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.xxxx.ssm&quot;/&gt; &lt;/bean&gt; 配置mybatis-config.xml 开启驼峰命名法：mapUnderscoreToCamelCase 添加分页插件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor&quot;&gt; &lt;property name=&quot;@page&quot; value=&quot;com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 在开启声明式事务在applicationContext.xml配置 开启事务管理器：DataSourceTransactionManager 配置数据源 开启注解形式的声明式事务：tx:annotation-driven 12345678&lt;!-- 开启声明式事务--&gt;&lt;!-- 事务管理器TransactionManager提供声明式事务的支持，在程序成功提交，运行时异常回滚--&gt;&lt;bean id=&quot;TransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--开启注解形式的声明式事务--&gt;&lt;tx:annotation-driven transaction-manager=&quot;TransactionManager&quot;/&gt; 使用整合后的SSM使用Mybatis-plus进行数据操作一般套路 创建对应Entity类 创建对应实体类的Mapper接口 创建对应Mapper接口的xml文件 在Controller中注入并调用 创建Entity类 设置属性为私有变量 设置注解 类级别：@TableName(“对应数据库表名”) 方法级别： @TableId（type=IdType.AUTO）：标记主键 type：主键生成策略 @TableField（”数据库字段”）:指定数据库字段与实体类对应关系 Get和Set方法 创建对应Mapper接口 创建接口类 继承BaseMapper&lt;对应实体类&gt; 1234//BaseMapper定义了CURD的方法声明，在运行时会自动根据实体的注解生成对应的SQL语句public interface GoodsDetailMapper extends BaseMapper&lt;GoodsDetail&gt; {} 创建Mapper.xml文件 复制mapper模板 namespace指向对应Mapper接口 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace指向接口--&gt;&lt;mapper namespace=&quot;com.xxxx.ssm.Mapper.GoodsDetailMapper&quot;&gt;&lt;/mapper&gt; 普通查询/插入/修改/删除基础BaseMapper的接口，包含一些基础的操作： selectXXX：输入参数来查询 deleteXXX：输入对象来删除，最好先查出来 updateXX：输入对象来修改，最好先查出来 insert：输入对象来插入数据 查询构造器QueryWrapper在上面的查询/插入/修改/删除的操作中，我们可以继续添加一些条件，就好比sql语句中where后面的各种条件判断语句. 创建对应实体类的查询构造器类 1QueryWrapper&lt;GoodsDetail&gt; qw= new QueryWrapper&lt;&gt;(); 调用对象的方法来满足对应条件 eq(“字段名”，数据) between…. like… 更多可以看文档https://baomidou.com/pages/10c804/#abstractwrapper ```javaqw.eq(“goods_id”, 739);qw.between(“gd_order”, 100, 501); 12345- 查询构造器对象作为参数添加到上面的查询/插入/修改/删除方法 ```java List&lt;GoodsDetail&gt; goodsDetails = goodsDetailMapper.selectList(qw); 完整 1234QueryWrapper&lt;GoodsDetail&gt; qw= new QueryWrapper&lt;&gt;();qw.eq(&quot;goods_id&quot;, 739);qw.between(&quot;gd_order&quot;, 100, 501);List&lt;GoodsDetail&gt; goodsDetails = goodsDetailMapper.selectList(qw); 分页查询多查询数据进行分页 创建IPage对象并添加页数，每一页大小 1IPage page = new Page(页数,每一页的大小); 该对象作为参数添加selectPage（IPage对象，查询构造器对象） 1IPage&lt;GoodsDetail&gt; page1 = goodsDetailMapper.selectPage(page, qw); 完整 123456 QueryWrapper&lt;GoodsDetail&gt; qw = new QueryWrapper&lt;&gt;(); qw.eq(&quot;gd_order&quot;, 100);// 分页对象(页号，单位页大小) IPage page=new Page(p,r);// 适合单表分页查询 IPage&lt;GoodsDetail&gt; page1 = goodsDetailMapper.selectPage(page, qw); 自定义查询当上面的语句已经不满足业务需求了，就可以使用了. 我们在Mapper接口添加方法，在对应mapper.xml添加sql,再实践在调用mapper接口引用对应方法. 在Mapper接口类中添加方法 添加参数：Map对象 添加注解：**@Param**（”p”）-用于传递多个参数，后面sql从Map中调用参数，如p.参数 分页参数：IPage对象 12345678/** * 自定义SQL分页查询 * * @param page 第一个对象固定为分页对象 * @param param 第二个参数Map向SQL传递多参数，但需要使用@Param(&quot;sql中的前置名&quot;)定义前置 * @return 返回分页结果 */public IPage&lt;Map&gt; selectMap(IPage page, @Param(&quot;p&quot;) Map param); 在对应的mapper.xml文件添加标签 添加select，insert等标签 id：添加接口中的方法名 parameterType：参数类型(一般多参数就是Java.util.Map) resultType：返回结构(带顺序的HashMap：java.util.LinkedHashMap) 12345678910&lt;!-- 在使用mybatis-plus分页插件时候，必须在引用参数时增加#{前缀.xxx}--&gt; &lt;select id=&quot;selectMap&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.LinkedHashMap&quot;&gt; select d.*,g.title from t_goods_detail d,t_goods g where d.goods_id = g.goods_id and d.gd_order= #{p.order} and d.goods_id=#{p.goodsId} &lt;/select&gt; 调用接口使用 查询一对多collection通过一个对象查到相关联的多个对象 在A对象添加私有变量对象B的集合类 B对象中添加通过id搜索对象的方法 在Mapper接口添加方法 在mapper.xml添加sql A对象对应接口添加方法 A对象对应的mapper.xml文件添加sql 查询A对象的sql设置resultMap resultMap（id必须对应） 提取type的一个对象 id标签： property：对象字段名 column：数据库字段名 collection标签： column:数据库字段名 select：指定查询sql(对象B的通过id查询语句指向) property：A对象的对象B集合类字段名 对象B的查询语句12345&lt;select id=&quot;findOne&quot; parameterType=&quot;int&quot; resultType=&quot;com.xxxx.ssm.Pojo.GoodsDetail&quot;&gt; select * from t_goods_detail where goods_id=#{value};&lt;/select&gt; 对象A的查询语句12345678&lt;resultMap id=&quot;getGoodsDetail&quot; type=&quot;com.xxxx.ssm.Pojo.Goods&quot;&gt; &lt;id property=&quot;goodsId&quot; column=&quot;goods_id&quot;&gt;&lt;/id&gt; &lt;collection property=&quot;goodsDetails&quot; select=&quot;com.xxxx.ssm.Mapper.GoodsDetailMapper.findOne&quot; column=&quot;goods_id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;findOneToTwo&quot; resultMap=&quot;getGoodsDetail&quot;&gt; select * from t_goods&lt;/select&gt; 执行过程 执行对象A的查询对象sql 执行结果映射resultMap 将type对象取出，将数据库中主键字段名映射到该对象属性名 执行collection 先选择该type的数据库字段column的值，填充到select语句中 通过select语句查到值，回填到property，也就是回填到A对象中的对象B集合类 取出下一个type，重复执行操作 查询多对一association逐步和一对多查询差不多，但是存在区别： 对象A中的属性不再是对象B的集合类，而是对象B的属性 collection标签换成association标签. 使用SpringMVC返回和接收数据装入bean容器 控制层：@Controller 事务层：@Service 持久层：@Reposiroty 其他组件：@Component 控制URL 类级别：@RequestMapping 方法级别：@GetMapping和@PostMapping 使用模板引擎 创建ModelAndView对象，并且填入跳转页面参数 给对象添加数据addObject（”key”,数据） 返回ModelAndView对象 使用JSON序列化记得添加jackson才可以序列化输出，二选一 类级别：@RestController 方法级别：@ResponseBody 操作声明式事务@Transactional一般在事务层的使用 使用@Transactional当方法执行成功时自动提交,抛出RuntimeException及其子类时自动回滚 设置rollbackFor = Exception.class通过指定的类来进行回滚(防止抛出的异常不是RuntimeException及其子类) 方法级别 类级别：默认类下的方法都是添加事务管理 12345678910111213// 指定Exception及其子类的异常抛出就执行事务回滚 @Transactional(rollbackFor = Exception.class) public void initGoods(){ for (int i = 11; i &lt;=10 ; i++) { if(i==13){ throw new RuntimeException(&quot;错误&quot;); } Goods goods = new Goods(); goods.setTitle(&quot;批量导入测试&quot; + i); ... int insert = goodsMapper.insert(goods); } } 不使用@Transactional当设置类级别的@Transctional时候，类中方法不是所有都要事务不使用事务,方法注解优先级比类注解高 1234@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true) public Goods findById(Integer integer){ return goodsMapper.findById(integer); } 开启Mybatis的二级缓存作用范围 一级缓存（默认开启）：SqlSession会话 二级缓存：Mapper’s Namespace JVM内存&gt;Mapper&gt;Sqlssion 1：n：m 二级缓存运行规则 开启二级缓存后，默认所有查询操作均使用缓存 写操作的commit提交，会把对应Mapper的namespace强制清空 在对应mapper.xml中任意sql标签 配置useCache=false可以不用缓存 配置flushCache=true可以强制清空缓存 开启二级缓存 在mybatis-config.xml的setting启动二级缓存 12&lt;!-- 开启二级缓存--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在相应mapper.xml中配置缓存cache flushInterval :多久自动清空缓存(ms) size ：缓存存储上限(1个集合算1个对象算一个) readOnly ： true ：返回只读缓存（快） false ：每次取出的是缓存对象的”副本”（安全） eviction：当缓存刷新的时候，使用的清楚策略 LRU：最近最少使用 FIFO：先进先出 SOFT：软引用(移除基于垃圾回收器状态和软引用规则的对象) WEAK：弱应用(更积极地移除基于垃圾收集器状态和弱引用规则的对象) 123456789101112131415161718&lt;!--namespace指向接口--&gt;&lt;mapper namespace=&quot;com.xxxx.ssm.Mapper.GoodsDetailMapper&quot;&gt; &lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;600000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; &lt;select id=&quot;findOne&quot; parameterType=&quot;int&quot; resultType=&quot;com.xxxx.ssm.Pojo.GoodsDetail&quot; useCache=&quot;false&quot;&gt; select * from t_goods_detail where goods_id=#{value}; &lt;/select&gt; &lt;select id=&quot;findOne&quot; parameterType=&quot;int&quot; resultType=&quot;com.xxxx.ssm.Pojo.GoodsDetail&quot; flushCache=&quot;true&quot;&gt; select * from t_goods_detail where goods_id=#{value}; &lt;/select&gt; &lt;/mapper&gt; 单元测试Junit引入依赖 junit spring-test javax.servlet：提供servlet容器 scope：test 1234567891011121314151617181920212223&lt;!-- Junit单元测试框架--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- Spring-Test是Spring与Junit提供的整合包 通过这个组件可以在Junit测试时自动对IOC容器进行初始化--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.8&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 提供servlet容器--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;!-- 只有scope=test 代表只在单元测试时才会加载这个依赖--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 操作单元测试自动创建单元测试类 在事务类，点击fn+alt+insert选择插入Test ![屏幕截图 2022-01-17 104528](D:\\TyporaOfimage\\屏幕截图 2022-01-17 104528.png) 点击要测试的方法 自动生成对应类 添加对应注解给测试用例类添加注解 SpringJUnit4ClassRunner.class是Spring-Test提供的整合类 自动加载applicationContext.xml并初始化IOC容器 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:applicationContext.xml&quot;}) 给测试用例添加注解123456// @Test代表下面的方法是可以单独执行的单元测试方法 @Test public void testFindById() { Goods byId = goodsMapper.findById(900); System.out.println(byId.getTitle()); } 事务管理测试用例给测试用例添加**@Transactional**，默认在测试用例成功后，为了不污染数据，会自动进行事务回滚 可以使用**@Rollback（false）**关闭这个事务回滚 123456@Test @Transactional @Rollback(false) public void initGoods() { goodsService.initGoods(); } 断言测试不添加断言，只能证明程序运行能成功或失败，无法证明程序运行后得出的结果是否符合. 运行结果判断 绿色对勾：程序运行成功 红色叹号：程序运行失败 黄色叉号：程序运行逻辑错误 使用断言 assertXXX(信息，条件condition) 如果条件不满足，就会输出信息 例子： 12345678 @Test public void findById() { Goods goods = goodsService.findById(900);// 提供断言Assert，对程序产生的结果进行判断// 如果condition不符合，则返回前面的msg，并且显示黄色叉号 assertTrue(&quot;未找到Goods对象&quot;,goods!=null); } 测试之前之后的操作在测试用例类或者测试用例之前会进行一些插入数据/开启连接 或者在执行测试用例类或者测试用例之后会进行一些消除数据/断开连接 @BeforClass和@AfterClass @BeforeClass在初始化测试用例类之前执行 @AfterClass在测试用例类执行之后执行 两种必须添加static，在类中各自只执行一次 123456789@BeforeClasspublic static void doClassBefore(){ System.out.println(&quot;向数据库插入数据&quot;);}@AfterClasspublic static void doClassAfter(){ System.out.println(&quot;消除数据库中的数据&quot;);} @Before和@After @Before在测试用例(方法)执行之前执行 @After在测试用例(方法)执行之后执行 不需要添加static，每个方法之前和之后执行一次 123456789@Beforepublic void doBefore(){ System.out.println(&quot;连接数据库&quot;);}@Afterpublic void doAfter(){ System.out.println(&quot;关闭数据库连接&quot;);} 文件上传和文件静态映射前端html页面设置 method设置为post enctype：表单编码类型multipart/form-data input的type中设置file 12345&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/upload&quot;&gt; &lt;input name=&quot;username&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;idcard&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 后端接收设置依赖引入12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 设置上传文件配置在applicationContext.xml上配置 123456789&lt;!-- multipartResolver这个id名不能改,不然会报错No multipart config for servlet--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;!-- 单个上传请求(可能包含多个文件)的最大长度,单位为字节--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;1048576&quot;/&gt;&lt;!-- 单个文件最大上传尺寸 单位为字节--&gt; &lt;property name=&quot;maxUploadSizePerFile&quot; value=&quot;102400&quot;/&gt;&lt;!-- 默认字符集为UFT-8--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; 参数接收并且修改文件名(一般直接复制) 参数设置MultipartFile对象 获得文件名 获得后缀 12345678910111213 @PostMapping(&quot;/upload&quot;) @ResponseBody public String upload(String username, @RequestParam(&quot;idcard&quot;) MultipartFile file) throws IOException { System.out.println(file.getOriginalFilename()); String path=&quot;d:/upload&quot;; String filename = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date()); String substring = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;)); System.out.println(&quot;文件上传后的名字:&quot;+path+&quot;/&quot;+filename+substring);// 文件另存为transferTo file.transferTo(new File(path+&quot;/&quot;+filename+substring)); return &quot;success&quot;; } 静态文件映射点击（http://localhost:8080/img/**.img）连接可以直接访问图片或者文件，其他静态文件. 在applicationContext.xml配置： mapping=”url访问路径” location=”实际访问路径” 12&lt;!-- 资源静态映射 访问/img/** 就去到对应路径--&gt; &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;file:/d:/upload/&quot;/&gt; 拦截器Interceptor基本用途用途SpringMVC拦截器对特定URL请求进行前置/后置过滤 权限验证，表单检验，日志输出等 底层Interceptor是基于SpringAOP面向切面编程实现 区别 Interceptor是Spring提供的 Filter是J2EE的标准 使用方式添加依赖提供相关依赖 12345678910111213&lt;!-- 提供servlet容器--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;!-- 只有scope=test 代表只在单元测试时才会加载这个依赖--&gt;&lt;!-- compile拦截器设置的范围--&gt;&lt;!-- complie 只在编译时加载这个依赖，运行时不加载 runtime 只在运行时加载这个依赖，编译时不加载 provided 则是编译与运行时都加载，默认设置--&gt; 实现HandlerInterceptor接口 创建相关类 继承HandlerInterceptor接口 重写三个方法 preHandle：前置校验，在运行目标方法前执行 postHandle：后置校验，在目标方法运行后（return后）执行 afterCompletion：完成(数据和页面结合后)后校验，在产生渲染结果后执行. 注意:true和false决定后面请求是否继续执行 12345678910111213141516171819202122232425public class SecurityInterceptor implements HandlerInterceptor { @Override public boolean preHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL() + &quot;前置处理&quot;); String token = request.getHeader(&quot;token&quot;); if(token==null){ response.sendError(403,&quot;Token Not Found&quot;); return false; }// 这里返回true和false决定后面请求是否继续执行// 加入设置为false,那么连controller层都进不去 return true; } @Override public void postHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL() + &quot;前置完成&quot;); } @Override public void afterCompletion(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL() + &quot;已渲染输出&quot;); }} application配置过滤地址 mvc:interceptors：配置多个拦截器 mvc:interceptor：配置单个拦截器，当某个URL遇到多个拦截器时，就会按照配置顺序依次执行(如果前面preHandle没有通过，则会全部中断) mvc:mapping：拦截地址，/**代表拦截所有地址，可以拦截多个url mvc:exclude-mapping：排除地址，当满足某个url请求，就不执行下面的类 bean：如果满足mapping的拦截地址，就会执行这个类（继承HandlerInterceptor的类） 1234567891011121314151617&lt;!-- 配置多个拦截器--&gt; &lt;mvc:interceptors&gt;&lt;!-- 配置单个拦截器--&gt; &lt;mvc:interceptor&gt;&lt;!-- mapping拦截地址,/**拦截所有地址,可以多个mvc:mapping拦截多个url--&gt; &lt;mvc:mapping path=&quot;/a&quot;/&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;!-- exclude-mapping排除地址,一般排除静态资源,可配置多个排除--&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt;&lt;!-- 当满足拦截地址，就会执行这个拦截类--&gt; &lt;bean class=&quot;com.xxxx.ssm.Intercepter.SecurityInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;!-- 某个URL遇到多个拦截器时，会按照配置顺序依次执行 但是如果前面preHandle没有通过，则会全部中断--&gt; &lt;/mvc:interceptors&gt;","link":"/Liust1918.githud.io/2022/12/04/SSM/"},{"title":"SSM重新学习","text":"SSM重新学习 Maven目的编译和打包项目,依赖管理 pom.xml（Poject Object Model） 中央仓库搜索依赖https://search.maven.org/ 包组织 groupId：组织id artifactId：项目id version：项目版本 构建生命周期直接mvn package来完成 compile 和test IOC(Inversion Of Control)控制反转基本概念我要租房，以前都是我直接找房东，找不同的房子就找不同的房东。但是现在出现了一个房屋中介，这个中介帮我们直接联系房东和管理房东的房子，我只要问房屋中介我要什么样的房子就行了.中介自动帮我找到对应房子的房东. 目的降低程序之间的直接耦合 IOC和DI（Dependency Injection） IOC是设计理念（宏观目标） 通过IOC容器来创建和管理Bean对象，用注入来操作Bean对象 DI是具体实现（微观目标） 在java中利用”反射(Reflection)”来注入（Injection） Spring 5IOC的具体实现 核心技术反射 设计模式 工厂模式 代理模式 支持![屏幕截图 2022-01-05 140503](D:\\TyporaOfimage\\屏幕截图 2022-01-05 140503.png) 数据交互 传统数据库mysql，Oracl：Spring Data Repositories Nosql，分布式数据库：Spring Data Reactive Repositories Web框架 Spring MVC：Spirng 4以前 Spring WebFlux：新的MVC框架，基于NIO，更适合分布式和并发 安全框架 Spring Security:基本安全框架 Spring Security Reactive：基于反应式编程的安全框架 Web框架底层实现 Servlet API：Spring MVC的底层实现 Reactive Stream Adapters：Spring WebFlux的底层实现 Wen容器 Servlet Containers：tomcat，jetty Netty Containers：类Netty容器 Spring 4 传统支持更完整 Spring 5 对于高并发分布式更好 Spring三种配置方式XML配置 创建application.xml文件 操作bean 创建bean（bean id class） 1&lt;bean id=&quot;edao&quot; class=&quot;类路径&quot;/&gt; 注入bean（property name ref） 1234 &lt;bean id=&quot;hrService&quot; class=&quot;com.xxxx.Service.HrService&quot;&gt;&lt;!-- 向bean中注入其他bean属性--&gt; &lt;property name=&quot;iEmpDAO&quot; ref=&quot;edao&quot;/&gt; &lt;/bean&gt; 在AppplicationContext中调用getBean使用 12345// 获取Spring上下文ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);// getBean(&quot;bean的id&quot;,接口/实体类.class)AHrService aHrService = context.getBean(&quot;aHrService&quot;, AHrService.class); 注解配置注解类型 创建bean @Repository (“name”) @Service（”name”） @Controller （”name”） @Component (“name”) 注入bean @Resource(name=”名字”)：先按bean名字搜索，在按bean类型搜索 @Autowired：按bean类型搜索，在按bean名字搜索 @Qualifier：知道bean名字 开启注解扫描Component-scan 在application.xml中添加 ```xml&lt;context:component-scan base-package=”扫描包的路径”/&gt; 12345678910111213141516171819202122232425262728293031323334## javaConfig配置用java代码代替xml的配置类#### 注解类型- @**Configuration**：标记配置类- @**Bean**：创建方法为bean - 方法名为id - 方法返回值为class - 注入属性方式：new个对象，调用set方法注入本配置类的方法(用this.方法)```java@Configurationpublic class SpringConfig { // id为createA class为A类 @Bean public A createA(){ return new A(); } @Bean public B createB() { B b = new B(); b.setA(this.createA()); return b; }} Spring的单例和多例单例和多例 默认IOC容器对象是单例 并发环境下，单例对象自动多线程执行 创建时机不同 单例：容器初始化创建 多例：getBean时创建 通过Scope属性设置多例 类型 singleton：单例(默认) prototype：多例 request：Web请求中单例 session：Web会话中单例 使用场景状态：对象有无私有变量（或者这个对象说存不存储东西） 无状态适合单例 有状态适合多例 code实践 xml：直接bean后面加Scope Annotaion：直接组件类上面加@Scope javaConfig：直接方法上面加@Scope Spring AOPSpring的插件 目的在不修改源码的情况下对原程序行为进行拓展. 实际Aspect切面类在项目中很少直接使用,绝大多数情况下会使用基于AOP基本上的拓展产品例如: Spring MVC Interceptor拦截器 @Transactional 声明式事务 @Cachable 声明式缓存 基本概念在软件模块运行之前插入权限切面，运行之后日志切面.不用的时候可以取出. 切面Aspect：切面类 连接点JoinPoint：切面类和原来程序的接入点 通知Advice：切面要完成的工作（也翻译叫增强） 实践code @Before 前置通知 @After 后置通知 @AfterReturning 返回后通知（和上面互斥） @AfterThrowing 异常通知 (和上面互斥) @Around 环绕通知 ProceedingJoinPoint proced()方法：执行目标方法，会抛出异常，也会返回对象 execution() 返回值 包名.xx.xx.xx.类名.方法名(参数列表) .. 多级列表 * 任意 MVC基本概念是一种架构/设计理论，不是设计模式（3类23个） View：视图 Model：数据模型 Controller：控制器 目的视图和数据解耦 嵌入式Web容器Jettyjetty和Tomcat 是开源的servlet容器和tomcat一样 Jetty容器实例化成对象，在嵌入到程序中 tomcat需要外部配置，并把war包加入 和tomcat比的好处 开发环境好，灵活轻便（开发用jetty，生产用tomcat） 方便项目转移 开发套路 创建webapp目录，创建/web-inf/web.xml 引入jetty-maven-plugin插件依赖 用插件中的Jetty：run启用嵌入式web应用 修改为输出war包 解决热部署 1234567891011121314151617181920212223 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.4.43.v20210629&lt;/version&gt; &lt;configuration&gt;&lt;!-- 加载webapp文件下的html css js --&gt; &lt;webAppSourceDirectory&gt;src/main/webapp&lt;/webAppSourceDirectory&gt; &lt;httpConnector&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/httpConnector&gt;&lt;!-- 解决热更新问题--&gt; &lt;webApp&gt; &lt;_initParams&gt; &lt;org.eclipse.jetty.servlet.Default.useFileMappedBuffer&gt;false&lt;/org.eclipse.jetty.servlet.Default.useFileMappedBuffer&gt; &lt;/_initParams&gt; &lt;/webApp&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ![屏幕截图 2022-01-06 223815](D:\\TyporaOfimage\\屏幕截图 2022-01-06 223815.png) Spring MVCSpring MVC是轻量级Web MVC框架,替代servlet 使用制造 接收客户端/浏览器请求 处理请求 产生响应 底层:基于Spirng IOC容器管理 搭建套路 加入Spring-webmvc依赖 web.xml配置核心组件DispatcherServlet 对web请求进行拦截 将请求转发给Controller对象 配置applicationContext的MVC标记 123456&lt;!-- 组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.xxxx&quot;/&gt;&lt;!-- 启动Spring MVC的注解模式--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 对静态文件(html，css,js)不扫描 提高执行效率--&gt; &lt;mvc:default-servlet-handler/&gt; web.xml文件 1234567891011121314151617181920212223242526272829303132 &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 启动等级--&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;!-- 拦截请求范围--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 配置文件整体含义: DispatcherServlet对系统中所有请求进行拦截 Servlet自动加载applicationContext.xml文件 并且在Web容器加载的时候，优先加载.--&gt;&lt;/web-app&gt; 请求数据和响应数据请求数据GET和POST请求 GET将请求内容存储在URL中 POST将请求内容存储在请求体(from data)中 URL绑定 类级别 @RequestMapping(“路径”) 方法级别 @GetMapping(“路径”) @PostMapping(“路径”) 请求方式 参数接收 @RequestParam(“key值”) Java Bean接收(对象接收) 路径变量接收（Restful开发风格） 在XXXMapping路径添加变量{变量名} 参数列表添加**@PathVariable** 1234567891011121314151617181920@PostMapping(&quot;/toRequest&quot;)public ModelAndView toRequest(@RequestParam(&quot;text&quot;) String text) { ModelAndView modelAndView = new ModelAndView(&quot;/RequestPage&quot;); modelAndView.addObject(&quot;text&quot;, text); return modelAndView;}@PostMapping(&quot;/toJavaBean&quot;)public ModelAndView toJavaBean(User user){ ModelAndView modelAndView = new ModelAndView(&quot;/RequestPage&quot;); modelAndView.addObject(&quot;user&quot;, user); return modelAndView;}@GetMapping(&quot;/toRestful/{text}&quot;)public ModelAndView toRestful(@PathVariable(&quot;text&quot;)String text){ ModelAndView modelAndView = new ModelAndView(&quot;/RequestPage&quot;); modelAndView.addObject(&quot;text&quot;, text); return modelAndView;} 响应数据响应方式 @ResponseBody：产生响应文本（在方法中使用），也就是返回字符串 返回JSON字符串：引入jackson ModelAndView：利用模板引擎渲染输出 生产ModelAndView对象，添加跳转页面 调用addObject（key，响应内容） 1234567891011121314@GetMapping(&quot;/json&quot;)@ResponseBodypublic User getJosn(){ User ifUser = ifService.getIfUser(1000L); return ifUser;}@GetMapping(&quot;/test&quot;) public ModelAndView getTest(){ ModelAndView modelAndView = new ModelAndView(&quot;/test&quot;); modelAndView.addObject(&quot;mytest&quot;, &quot;测试&quot;); return modelAndView; } json依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt; 模板引擎目标 通过 模板+数据 通过模板引擎 得到结果 将模板和数据进行解耦 主流使用 JSP(Java Server Page)——J2EE组件 Freemarker——用的人多 Beetl thymealeaf——Spring Boot推荐 Freemarker引入依赖和配置依赖 spring-context-support freemarker 1234567891011 &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt;&lt;!-- --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.3.8&lt;/version&gt; &lt;/dependency&gt; applicationContext配置 配置FreeMarkerViewResolver和FreeMarkerConfigurer 在web-inf/ftl目录添加freemarker模板（拓展名为.ftl文件） 1234567891011121314151617181920&lt;!-- 在IOC容器初始化时通知SpringMVC默认使用Freemarker进行数据展示--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;&lt;!-- 渲染完成的结果向客户端输出的时候设置UTF-8字符集--&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;&gt;&lt;/property&gt;&lt;!-- 指定Freemarker模板文件拓展名--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- freemarker配置文件--&gt; &lt;bean id=&quot;freeMarkerConfigurer&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;&lt;!-- 模板引擎文件保存路径--&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;&lt;!-- 其他模板引擎设置--&gt; &lt;property name=&quot;freemarkerSettings&quot; &gt; &lt;props&gt;&lt;!-- 设置Freemarker脚本和数据渲染时使用的字符集--&gt; &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 基本语法三个取值语法 ${变量} ${变量!默认值} ${变量？强制转换类型/函数} 123&lt;p&gt;${user.password}&lt;/p&gt;&lt;p&gt;${user.price!&quot;(数据为空时)测试默认值&quot;}&lt;/p&gt;&lt;p&gt;${user.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/p&gt; 调剂判断 &lt;#if 条件判断 &gt;包围 &lt;#elseif 条件判断&gt; &lt;#else&gt; 调剂判断 括号 变量？？：判断对象为空的方式 1234567&lt;#if ifuser.price?? &gt; &lt;p&gt;用户余额等于1000&lt;/p&gt; &lt;#elseif (ifuser.price&gt;1000)&gt; &lt;p&gt;用户余额:${ifuser.price}&lt;/p&gt; &lt;#else&gt; &lt;p&gt;用户余额不足1000&lt;/p&gt;&lt;/#if&gt; 循环 &lt;ul&gt;或者&lt;ol&gt; &lt;#list 集合变量 as 单个变量&gt;包围 &lt;li&gt; 12345678910&lt;ul&gt; &lt;#list users as u&gt; &lt;li&gt;${u_index + 1}&lt;/li&gt; &lt;li&gt;${u.username}&lt;/li&gt; &lt;li&gt;${u.password}&lt;/li&gt; &lt;li&gt;${u.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/li&gt; &lt;li&gt;${u.price}&lt;/li&gt; &lt;hr&gt; &lt;/#list&gt;&lt;/ul&gt; include子页面实现页首和页尾 &lt;#include “其他ftl页面”&gt; 123456&lt;#include &quot;OtherPage/header.ftl&quot;&gt;&lt;p&gt;${user.username}&lt;/p&gt;&lt;p&gt;${user.password}&lt;/p&gt;&lt;p&gt;${user.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/p&gt;&lt;p&gt;${user.price}&lt;/p&gt;&lt;#include &quot;OtherPage/floot.ftl&quot;&gt; 内置函数 作用 函数名 大小写转换 lower_case/upper_case 首字母大写 cap_first 查找字符串索引 index_of 返回字符串长度 length 四舍五入/下取整/上取整 round/floor/ceiling 得到集合元素总数 size 获取第一个/最后一个元素 first/last 按某个属性对集合排序 sort_by 日期数据处理Pojo对象处理 DateTimeFormat(pattern=”日期格式”) JsonFormat(pattern=”日期格式”，timezone=”时区”) 12345// 传入数据进行转换 @DateTimeFormat(pattern = &quot;yyyyMMdd&quot;)// 发出数据 @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;) private Date date; freemark处理 ${变量？string（”日期格式“）} 1&lt;li&gt;${u.date?string(&quot;yyyy年MM月dd日&quot;)}&lt;/li&gt; Mybatis引入依赖 mysql连接 mybatis junit单元测试 logback日志显示(显示sql) pageHelper分页插件 jsqlparser分页插件依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; Mybatis配置文件和配置 创建mybatis-config.xml文件 配置环境（方便开发和生产环境切换） 设置默认环境 设置环境 设置事务管理器的提交和回滚：JDBC 设置数据源的连接池POOLED 设置基本mysql的基本属性 开启驼峰命名法 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt;&lt;!-- 开启驼峰命名法转换 官网有--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;/plugins&gt; &lt;!-- 设置环境 默认环境(方便不同数据库环境使用)--&gt; &lt;environments default=&quot;dev&quot;&gt;&lt;!-- 设置开发dev环境--&gt; &lt;environment id=&quot;dev&quot;&gt;&lt;!-- 事务管理器——进行事务提交和回滚--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;&lt;!-- 数据源 POOLED连接池来连接数据库--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;数据库账号&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;数据库密码&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 注意：由于涉及到转译问题，&amp;要写成&amp;amp; 使用Mybatis创建Pojo类 私有属性要和数据库的字段名保持驼峰命名法 GET和SET方法 在resource创建对应的mapper类 mapper标签 设置命名空间namespace 在mybatis的配置文件进行映射 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--映射器--&gt;&lt;!--命名空间namespace--&gt;&lt;mapper namespace=&quot;goods&quot;&gt; &lt;/mapper&gt; 123&lt;mappers&gt; &lt;mapper resource=&quot;mappers/goods.xml&quot;/&gt; &lt;/mappers&gt; 进行Jetty单元测试 读取mybatis配置文件 获得sqlSessionFactroy 获得sqlSession对象：调用sqlSessionFacroty的openSession方法 1234567891011121314151617181920static SqlSessionFactory sqlSessionFactory = null;// BeforeClass用于在Junit启用测试用例前执行一次全局初始化工作，来创建sqlSessionFactory对象 @BeforeClass public static void init() throws IOException { // 读取mybatis配置文件,初始化mybatis对象 Reader resourceAsReader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;); // 创建对应Session对象 sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader); } // 测试会话工厂(核心类)// 作用:帮助创建数据库连接// 获取对应的Session会话对象 @Test public void testSessionFactory() throws IOException { SqlSession sqlSession = sqlSessionFactory.openSession();//打开会话 Connection connection = sqlSession.getConnection();//获得原始数据库连接 System.out.println(connection); } 查操作 在mapper中添加select 添加sql语句 调用sqlSession对象中的方法 selectList（”命名空间.mapper的id”）：获取多个对象 selectOne（”命名空间.mapper的id”）：获得单个对象 获得参数 关闭sqlSession 123456789101112131415161718192021 @Test public void testFindAll() { SqlSession sqlSession=null; try {// openSession创建一个新的sqlSession对象，SqlSession提供了增删改查的方法调用 sqlSession = sqlSessionFactory.openSession();// goods为mapper的命名空间，里面的findAll方法// 通过命名空间来区别不同的findAll方法 PageHelper.startPage(2, 10); List&lt;Goods&gt; goods = sqlSession.selectList(&quot;goods.findAll&quot;); goods.stream().forEach(goods1 -&gt; { System.out.println(goods1.getGoodsId()+&quot; - &quot;+goods1.getTitle()); }); }catch (Exception e){ }finally { if (sqlSession != null) {// 将这个Connection归还给连接池 供其他Session使用 sqlSession.close(); } } } 1234&lt;select id=&quot;findAll&quot; resultType=&quot;com.xxxx.SpringMVC.Mybatis.Pojo.Goods&quot;&gt; select * from t_goods&lt;/select&gt; 插操作 在mapper添加insert 添加sql语句 使用selectKey返回sql生产的key值（在高并发环境下防止id混乱） 1234&lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id字段&quot; order=&quot;AFTER&quot;&gt; -- 当前连接中最后产生的id号 select last_insert_id() &lt;/selectKey&gt; 调用sqlSession的insert方法 单个参数：sqlSession.insert(“命名空间.mapper的id”，插入对象) 多个参数Map：sqlSession.insert(“命名空间.mapper的id”，插入Map对象) 事务提交/回滚commit 关闭sqlSession 12345678910111213141516171819202122232425262728293031 @Test public void testInsert() { SqlSession sqlSession=null; try { sqlSession = sqlSessionFactory.openSession(); Goods goods = new Goods(); goods.setTitle(&quot;测试商品&quot;); goods.setSubTitle(&quot;测试子标题&quot;); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); int result = sqlSession.insert(&quot;goods.insert&quot;, goods); System.out.println(result); System.out.println(goods.getGoodsId());// 写操作千万别忘记提交或回滚事务 sqlSession.commit(); }catch (Exception e){ e.printStackTrace(); if(sqlSession!=null){// 回滚 sqlSession.rollback(); } }finally { if (sqlSession != null) {// 将这个Connection归还给连接池 供其他Session使用 sqlSession.close(); } } } 12345678910&lt;insert id=&quot;insert&quot; parameterType=&quot;com.xxxx.SpringMVC.Mybatis.Pojo.Goods&quot;&gt; INSERT INTO `babytun`.`t_goods`(`title`, `sub_title`, `original_cost`, `current_price`, `discount`, `is_free_delivery`, `category_id`) VALUES (#{title}, #{subTitle}, #{originalCost}, #{currentPrice}, #{discount}, #{isFreeDelivery}, #{categoryId}); -- 插入数据后马上执行下面的查询key的操作(在高并发环境下防止id混乱) &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;goodsId&quot; order=&quot;AFTER&quot;&gt; -- 当前连接中最后产生的id号 select last_insert_id() &lt;/selectKey&gt;&lt;/insert&gt; 改操作 先通过id查出来 添加mapper的select 添加select的sql语句 调用sqlSession的selectOne（”命名空间.mapper的id”，id参数） 获得参数对象并修改 再改 添加mapper的update 添加update的sql语句 调用sqlSession的update（”命名空间.mapper的id“，修改后的参数对象） 事务提交和管理commit 关闭sqlSession 12345678910111213141516171819202122232425 @Test public void testUpdate() { SqlSession sqlSession=null; try { sqlSession = sqlSessionFactory.openSession(); Goods goods=sqlSession.selectOne(&quot;goods.findById&quot;,2677); goods.setTitle(&quot;更新后的商品标题&quot;); int result = sqlSession.update(&quot;goods.update&quot;, goods); System.out.println(result);// 写操作千万别忘记提交或回滚事务 sqlSession.commit(); }catch (Exception e){ e.printStackTrace(); if(sqlSession!=null){// 回滚 sqlSession.rollback(); } }finally { if (sqlSession != null) {// 将这个Connection归还给连接池 供其他Session使用 sqlSession.close(); } } } 1234567891011121314151617181920&lt;!-- 获取数据--&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;java.lang.Integer&quot; resultType=&quot;com.xxxx.SpringMVC.Mybatis.Pojo.Goods&quot;&gt; -- select * from t_goods where goods_id = #{value};&lt;/select&gt;&lt;update id=&quot;update&quot; parameterType=&quot;com.xxxx.SpringMVC.Mybatis.Pojo.Goods&quot;&gt; UPDATE `babytun`.`t_goods` SET `title` = #{title}, `sub_title` = #{subTitle}, `original_cost` = #{originalCost}, `current_price` = #{currentPrice}, `discount` = #{discount}, `is_free_delivery` = #{isFreeDelivery}, `category_id` = #{categoryId} WHERE `goods_id` = #{goodsId};&lt;/update&gt; 删操作 添加mapper的delete 添加sql语句 调用sqlSession的delete（”命名空间.mapper的id”，id参数） 获得结果参数 事务提交和管理commit 关闭sqlSession 12345678910111213141516171819202122 @Test public void testDelete() { SqlSession sqlSession=null; try { sqlSession = sqlSessionFactory.openSession(); int delete = sqlSession.delete(&quot;goods.delete&quot;, 2677); System.out.println(delete);// 写操作千万别忘记提交或回滚事务 sqlSession.commit(); }catch (Exception e){ e.printStackTrace(); if(sqlSession!=null){// 回滚 sqlSession.rollback(); } }finally { if (sqlSession != null) {// 将这个Connection归还给连接池 供其他Session使用 sqlSession.close(); } } } 12345&lt;delete id=&quot;delete&quot; parameterType=&quot;Integer&quot;&gt; delete from t_goods where goods_id = #{value}&lt;/delete&gt; 输入参数和输出参数，多参数 parameterType：输入参数类型(完整包名，基本类型:_类型，基本类型包装类：类型) resultType：输出参数类型(完整包名，基本类型:_类型，基本类型包装类：类型) Map输入多参数 设置parameterType为java.util.Map 输入HashMap对象 HashMap对象.put(“添加参数名”，添加参数) 123456&lt;select id=&quot;findByPriceRange&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;com.xxxx.SpringMVC.Mybatis.Pojo.Goods&quot;&gt; select * from t_goods where current_price between #{min} and #{max} order by current_price limit 0,#{limt}&lt;/select&gt; 123456sqlSession = sqlSessionFactory.openSession();Map map = new HashMap&lt;&gt;();map.put(&quot;min&quot;, 100);map.put(&quot;max&quot;, 500);map.put(&quot;limt&quot;, 10);List&lt;Goods&gt; goods = sqlSession.selectList(&quot;goods.findByPriceRange&quot;, map); #{}和${}区别 #{}:预编译sql语句 ${}:替换sql语句 一般用#{}，少使用${},一般使用${}可以当作添加sql，但是不能开放给前端.（小心sql注入） 动态sql if 123&lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; choose,when,otherwise 1234567891011&lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; foreach item：单个对象 index：下标 collection：集合 open：拼接sql最开头添加 separator：分隔符号 close：拼接sql最后添加 1234&lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;ID in (&quot; separator=&quot;,&quot; close=&quot;)&quot; nullable=&quot;true&quot;&gt; #{item} &lt;/foreach&gt; 消除and影响有时候满足条件后的sql语句会包含前置的sql语句 “AND” 这个，消去方法: where 1=1 用where标签包围 123456789101112&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; AND state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 或者 12345678910&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG where 1=1 &lt;if test=&quot;state != null&quot;&gt; AND state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; 分页插件PageHelper配置文件 在mybatis的配置文件添加插件 设置数据库类型helperDialect 分页合理化reasonable：点击超过页数限制的页数就去最大页数（小于第0页同理） 123456789 &lt;plugins&gt;&lt;!-- 对sql拦截以及设置--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt;&lt;!-- 分页合理化(超过最大页数就去最大页)--&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 在sqlSession.XXXXX之前添加 PageHelper.startPage(第几页, 每一页的size); 背后执行sql 先查询行总数 实践sql限制LIMIT 1SELECT count(0) FROM t_goods //效率高 1Preparing: select * from t_goods LIMIT ?, ? 例子123456789101112131415161718192021 @Test public void testFindAll() { SqlSession sqlSession=null; try {// openSession创建一个新的sqlSession对象，SqlSession提供了增删改查的方法调用 sqlSession = sqlSessionFactory.openSession();// goods为mapper的命名空间，里面的findAll方法// 通过命名空间来区别不同的findAll方法 PageHelper.startPage(2, 10); List&lt;Goods&gt; goods = sqlSession.selectList(&quot;goods.findAll&quot;); goods.stream().forEach(goods1 -&gt; { System.out.println(goods1.getGoodsId()+&quot; - &quot;+goods1.getTitle()); }); }catch (Exception e){ }finally { if (sqlSession != null) {// 将这个Connection归还给连接池 供其他Session使用 sqlSession.close(); } } }","link":"/Liust1918.githud.io/2022/12/04/SSM%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/"},{"title":"Mysql必知必会书","text":"Mysql必知必会 了解sql什么是数据库.数据库(database)保存有组织的数据的容器. 表(table)某种特定类型数据的结构化清单 每一个数据库不能有同名表，不同数据库可以有同名表. 模式(schema)描述关于数据库和表的布局及特性的信息. 列(column)表中的一个字段.所有表都是由一个或多个列组成的. 数据类型(datatype)列中所容许的数据的类型. 作用: 限制可存储在列中的数据种类——防止在数值字段中录入字符值. 帮助正确排序 优化磁盘使用 行(row)表中的一个记录. 主键(primary key)一列(或一组列),列中值可以唯一区分. 限制(单列主键): 任意两行的值都不相同. 列不为NULL值. (多个列作为主键)主键所有列的组合要唯一. 主键的最好习惯: 不更新主键列的值 不重用主键列的值. 不在主键列中使用可能会更改的值. 外键什么是SQLSQL——结构化查询语言(Structured Query Language) 设计sql的目的——提供一种从数据库中读写数据的简单有效的方法. Mysql简介什么是mysqlMysql是一种DBMS 优点: 成本低，开源 性能快 可信赖,大公司也用 简单,软件容易安装和使用. 客户端—服务器软件DBMS类型 基于共享文件系统的DBMS.(Microsoft Access和FileMaker)——只能用于桌面用途. 基于客户端—服务器 客户端—服务器服务器部分负责所有数据访问和处理的一个软件 处理从客户端的请求中增删改查的命令. 客户端发出请求/更改. 使用数据库选择数据库 use 数据库名(crashcourse) 使用这个命令不输出结果. 必须先使用USE来打开数据库,才可以读取其中的数据. (了解)查询数据库和表使用show来显示内部表中的信息.查所有数据库: show databases; 查所有表: show tables; 查询列: show columns from 表名; DESCRIBE 表名; 对每个字段返回一行,行中包含字段名,数据类型,是否允许NULL，键信息以及其他信息. 其他查询: show status; 显示服务器状态信息. show create database; show create table; 显示创建特定数据库/表的Mysql语句. show grants; 显示用户的安全权限. show Errors; show warnings; 显示服务器错误/警告消息. 检索数据SELECT语句注意结束SQL语句结束sql语句养成写（；）的习惯 SQL语句与大小写sql语句不区分大小写 养成好习惯: sql关键字大写 标识符(如数据库名,表名,列名)要小写(方便阅读) PS: Mysql4.1之前的版本——标识符默认区分大小写 Mysql4.1.1之后——标识符不区分大小写 使用空格将SQL语句分为多行方便阅读和测试. 检索单个列 SELECT 列A FROM 表; 返回未排序的列所有的行 检索多个列 SELECT 列A，列B，列C FROM 表; 使用逗号（，）让列相隔 检索所有列(*) SELECT * FROM 表; 通配符（*） 不建议用: 检索多余的列 降低检索和应用程序的性能(哪怕把所有列名写出也比这个快) 检索不同的行(DISTINCT) SELECT DISTINCT 列A，列B vend_id FROM 表; 关键字：DISTINCT 不能部分使用DISTINCT，DISTINCT是对所有列有效，不是对前置列. 单独的distinct只能放在开头，否则报错，语法错误，与其他函数使用时候，没有位置限制. 限制结果(LIMIT) SELECT prod_name FROM products LIMIT 4; SELECT prod_name FROM products LIMIT m行数; SELECT prod_name FROM products LIMIT 3,4; SELECT prod_name FROM products LIMIT n行下标 , m行数; SELECT prod_name FROM products LIMIT 4 OFFSET 3; SELECT prod_name FROM products LIMIT m行数 OFFSET n行下标; 意义：从行下标n开始，输出m行. 特殊情况: 行0问题:行下标是从0开始，所有行下标1的时候是第二行. 行数不够:剩下有多少输出多少. 使用完全限定的表名(表.列/库.表) SELECT products.prod_name FROM testlearing.products; SELECT 表.行 FROM 库.表; 排序检索数据排序数据（ORDER BY）不明确顺序会受数据进行修改/删除的影响. 子句（clause）:一个子句=一个关键词+提供的数据组成 例如:Select语句的FROM子句. SELECT 列A FROM 表 ORDER BY 列A; 对列A进行排列 按多个列排序 SELECT prod_id , prod_price , prod_name FROM products ORDER BY prod_price , prod_name; SELECT 列A, 列B, 列C FROM 表 ORDER BY 列A , 列B; 排序原理:列A先排序，如果列A中有相同值，就在列B排序。 相反的，如果列A中值全都是唯一的，列B就不排序。 指定排序方向（DESC）排序方向（两种理解）: 从上向下排序 第一行从0开始 排序类别 升序(从A到Z) ——默认 倒序(从Z到A)——DESC 例： SELECT prod_id , prod_price , prod_name FROM products ORDER BY prod_price DESC; SELECT 列A, 列B, 列C FROM 表 ORDER BY 列A DESC; SELECT prod_id , prod_price , prod_name FROM products ORDER BY prod_price DESC , prod_name; SELECT 列A, 列B, 列C FROM 表 ORDER BY 列A DESC，列B; 特殊用法寻找最大/小值：MAX： SELECT prod_price FROM products ORDER BY prod_price DESC LIMIT 1; MIN： SELECT prod_price FROM products ORDER BY prod_price LIMIT 1; 过滤数据使用WHERE子句 SELECT prod_name ,prod_price FROM products WHERE prod_price= 2.50; SQL过滤与应用过滤最好用SQL过滤，也就是在服务端进行sql过滤处理完后再发回客户端 可以节约网络宽带. WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 检查单个值（=，&lt;，&lt;=） SELECT prod_name , prod_price FROM products WHERE prod_name=’Fuses’; SELECT prod_name ,prod_price FROM products WHERE prod_price &lt; 10; PS:字符串与值比较要用引号 不匹配检查(&lt;&gt;,!=) SELECT vend_id ,prod_name FROM products WHERE vend_id &lt;&gt; 1003; SELECT vend_id ,prod_name FROM products WHERE vend_id != 1003; 范围值检查 SELECT prod_name, prod_price FROM products WHERE prod_price BETWEEN 5 AND 10; 空值查询 SELECT cust_id FROM customers WHERE cust_email IS NULL; NULL与不匹配问题：不匹配是过滤不了null，也就是如果是null的值，是不会返回. PS:所以,在过滤数据时,一定要验证返回数据中确实给出了被过滤列具有NULL的行. 数据过滤组合子句操作符(operator)联结/改变WHERE子句中的子句的关键字. AND操作符 SELECT prod_id , prod_price ,prod_name FROM products WHERE vend_id =1003 AND prod_price &lt;=10; OR操作符 SELECT prod_name ,prod_price FROM products WHERE vend_id =1002 OR vend_id =1003; 计算次序AND的优先级会比OR高,也就是先满足AND相连的过滤条件在到OR（不建议使用） SELECT prod_name ,prod_price FROM products WHERE vend_id=1002 OR vend_id=1003 AND prod_price &gt;=10; 先: vend_id=1003 AND prod_price &gt;=10 后: vend_id=1002 使用括号解决： SELECT prod_name ,prod_price FROM products WHERE (vend_id=1002 OR vend_id=1003) AND prod_price &gt;=10; 先: (vend_id=1002 OR vend_id=1003) 后： AND prod_price &gt;=10 IN操作符过滤IN括号中的东西——原理类似组合很多个OR操作符 SELECT prod_name ,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name; 使用IN的优点： 用IN取代太长的OR，更加清晰直观 计算次序更容易管理 IN操作符比OR操作符更快 最大优点可以用IN包含其他SELECT语句. NOT操作符MySQL支持使用NOT取反 IN BETWEEN EXISTS SELECT prod_name ,prod_price FROM products WHERE vend_id NOT IN (1002 , 1003) ORDER BY prod_name; 使用通配符进行过滤LIKE操作符(模糊查询)通配符用来匹配值的一部分的特殊字符(如:%,_) 搜索模式由字面值,通配符或两者组合构成的搜索条件.(如:” ‘jet% ‘ “ ) 百分号(%)通配符 SELECT prod_id , prod_name FROM products WHERE prod_name LIKE ‘Jet%’; 区分大小写%的范围:0个，1个或多个字符. 注意( ‘ ‘ )中的空格不然会影响搜索 注意NULLLIKE ‘%’问题:可以搜索全部行，但是搜索不了NULL. 下划线(_)通配符 SELECT prod_id , prod_name FROM products WHERE prod_name LIKE ‘_ ton anvil’; _的范围:只能一个，一个不能多一个不能少. 使用通配符的技巧 不要过度使用通配符.其他操作符能实现就用 除非必要，否者不要把通配符放在搜索模式的开始，这样会降低性能. 注意通配符位置. 用正则表达式进行搜索使用MySQL正则表达式mysql正则表达式只是很多正则表达式的很小一部分. 字符 作用 a|b|c 用或运算 […] 匹配所包含的任意一个字符 [^…..] 不匹配所包含的任意一个字符 [a-z] 字母或者数字的范围 元字符 作用 * 0个或多个匹配 + 1个或多个匹配(等于{1, }) ? 0个或1个匹配(等于{0,1}) {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围(m不超过255) 定位符 作用 ^ 文本开始 $ 文本结束 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 . 匹配除 “\\n” 之外的任何单个字符 基本字符匹配 SELECT prod_name FROM products WHERE prod_name REGEXP ‘1000’; LIKE与REGEXP区别 LIKE是匹配整个串的 REGEXP匹配的子串 REGEXP也可通过定位符来达到匹配整个串的效果. REGEXP不区分大小写 默认不区分大小写 也可用BINARY来区分大小写 如: WHERE prod_name REGEXP BINARY ‘ JetPack .000 ‘ ; OR匹配一般用法 SELECT prod_name FROM products WHERE prod_name REGEXP ‘1000|2000’; 错误用法: SELECT prod_name FROM products WHERE prod_name REGEXP ‘1|2|3 ton’; 这样只能匹配1 或2 或 3ton.这样就错了 匹配几个字符之一 SELECT prod_name FROM products WHERE prod_name REGEXP ‘ [123] ton’; 运行方式:[123]意思等同与1|2|3，从[]中抽取其中一个字符进行匹配. 否定用法： SELECT prod_name FROM products WHERE prod_name REGEXP ‘ [ ^123] ton’; [ ^123]意思是不匹配1或2或3 匹配范围 SELECT prod_name FROM products WHERE prod_name REGEXP ‘[1-5] ton’; [1-5]这样的范围表示也可用[a-z]，具体可以随意填写**(0-255范围)** 匹配特殊字符 SELECT vend_name FROM vendors WHERE vend_name REGEXP ‘\\.’; 用于匹配特殊字符。 与多数正则表达式区别 多数正则表达式用\\ Mysql则用\\\\ 一般元字符 元字符 说明 \\\\. 输出点. \\\\ \\\\[] 输出[] \\\\\\ 输出反斜杠\\ \\\\f 换页 \\\\n 换行 \\\\r 回车 \\\\t 制表 \\\\v 纵向制表 匹配字符类一般不用 匹配多个实例 SELECT prod_name FROM products WHERE prod_name REGEXP ‘\\([0-9] sticks?\\)’; 一般匹配整个地方要多个或者有没有字符，用来对匹配的数目进行更强控制. 详细用法: REGEXP ‘ab*’ 代表可以匹配0个或者多个b。如：a ab abbbbbbbbbbbbbb 同理: REGEXP ‘ab+’ 如: ab abbbbbbbbbbb 又同理: REGEXP ‘ab?’ 如:a ab 定位符 SELECT prod_name FROM products WHERE prod_name REGEXP ‘^[0-9\\.]’; 让REGEXP与LIKE效果一样LIKE和REGEXP不同在于LIKE匹配整个串,REGEXP匹配子串. 用定位符^放开始,$放结束就行了 ^双重用法 []外——指定串的开始处 []内——否定该集合 创建计算字段计算字段作用:从数据库中检索出转换,计算或格式化过的数据. 字段(field)与列的意思一样. 拼接字段(Concat()) SELECT concat(vend_name,’ (‘ ,vend_country ,’) ‘) FROM vendors ORDER BY vend_name; 拼接(concatenate)将值联结到一起构成单个值. SELECT Concat(RTrim(vend_name) , ‘ (‘ ,RTrim(vend_country),’ )’ ) AS vend_title FROM vendors; 使用别名(AS)别名可以把原来容易混淆或者误解的名字给改了. 执行算术计算算术操作：列A 操作符 列B …… AS 新列 MySQL算术操作符 操作符 说明 + 加 - 减 * 乘 / 除 使用数据处理函数函数分类 文本函数:处理文本串(如删除/填充，转换值为大写/小写) 数值函数:在数值数据上进行算术操作(如返回绝对值，代数运算) 日期和时间函数:处理日期和时间值并从这些值中提取特定 文本处理函数 函数 说明 Left( 列 , n ) Rigth ( 列 , n) 返回从左/右开始到n的字符串 LTrim ( 列 ) RTrim( 列 ) 返回去掉左/右空格的字符串 Lower( 列 ) Upper( 列 ) 返回全大写/小写的字符串 Locate(substr,str) Locate(substr,str，n) 找出串中第一次出现的子串 SubString(str,n) SubString(str,n,len) 分割串 Length(str) 串长 Position(substr IN str) 子串在串中第一次出现的位置 ps:str=待查找的串 substr=待查找的子串 len=子串长度 SELECT vend_name , left(vend_name,2) AS vend_name_upper FROM vendors; 日期和时间处理函数一般用函数改： 函数 说明 AddDate() 增加一个日期(天,周等) AddTime() 增加一个日期(时,分等) CurDate() 返回当前日期 CurTime() 返回当前时间 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 查: 函数 说明 Date() 返回日期时间的日期部分 Day() 返回日期时间的天数部分 DayOfWeek() 返回日期时间的星期部分 Month() 返回日期时间的月份部分 Year() 返回日期时间的年份部分 Time() 返回日期时间的时间部分 Hour() 返回日期时间的小时部分 Minute() 返回日期时间的分部分 Second() 返回日期时间的秒部分 Now() 返回当前日期和时间 MySQL使用的日期格式必须是:yyyy-mm-dd SELECT cust_id, order_num FROM orders WHERE order_date= ‘2005-09-01’; 两种日期比较 如果要的是日期,请使用Date() 如果要的是时间,请使用Time() 不用管每个月几天以及闰年问题——直接比较具体，例如:Year(),Month()… 例如： SELECT cust_id , order_num FROM orders WHERE Date(order_date) BETWEEN ‘2005-09-01’ AND ‘2005-09-30’; SELECT cust_id ,order_num FROM orders WHERE YEAR(order_date)=2005 AND MONTH(order_date)=9; 数值处理函数 函数 说明 Abs() 绝对值 Cos() 余弦 Exp() 数的指数值 Mod() 求余数 Pi() 圆周率 Rand() 随机数 Sin() 正弦 Sqrt() 平方根 Tan() 正切 汇总数据聚集函数作用： 确定表中行数. 获得表中行组的和 找出表列的最大/小/平均值 聚集函数(aggregate funtion)运行在行组中,计算和返回单个值的函数.(必须用AS别名) 函数 说明 NULL值 AVG() 某列的平均值 忽略 COUNT() 某列的行数 *不忽略，指定某列则忽略 MAX() 某列的最大值 忽略 MIN() 某列的最小值 忽略 SUM() 某列值之和 忽略 AVG()函数 SELECT AVG(prod_price) AS avg_price FROM products; COUNT()函数 SELECT COUNT(cust_email) AS num_cust FROM customers; MAX()函数 SELECT MAX(prod_price) AS max_price FROM products; 对非数值数据使用MAX()用于文本数据时,MAX()返回最后一行. MIN()函数 SELECT MIN(prod_price) AS min_price FROM products; 对非数值数据使用MIN()用于文本数据时,MIN()返回第一行. SUM()函数 SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num=20005; 在多个列上进行计算像SUM(item_price*quantity)使用算术操作符，所有聚集函数都可用来执行多个列上的计算. 聚集不同值对五个聚集函数: SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id=1003; 对所有的行执行计算,指定ALL参数/不给参数 只包含不同的值,指定DISTINCT参数. 特别注意事项 如果指定列名,则DISTINCT只能用于COUNT(). DISTINCT不能用于COUNT(*)——错误使用COUNT(DISTINCT) DISTINCT必须使用列名,不能用于计算和表达式. 分组数据创建分组(GROUP BY) SELECT vend_id ,COUNT(*) AS num_prods FROM products GROUP BY vend_id; 分组条件(较多)： GROUP BY子句可包含任意数目的列 在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）. GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用了表达式，则必须在GROUP BY子句中指定相同的表达式。 不能使用别名. 除聚集计算语句外，SELECT 语句中的每个列都必须在GROUP BY 子句中给出. 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL,它们将分为一组. GROUP BY子句必须在WHERE子句之后，ORDER BY之前。 过滤分组(HAVING) SELECT cust_id ,COUNT() AS orders FROM orders GROUP BY cust_id HAVING COUNT() &gt;=2; HAVING与WHERE区别 对分组过于采用HAVING子句。 HAVING子句支持所有WHERE的操作。 WHERE在分组之前过滤，而HAVING在分组之后以每组为单位过滤。 分组和排序分组后不会排序，记得用ORDER BY排序. SELECT order_num ,SUM(quantityitem_price) AS ordertotal FROM orderitems GROUP BY order_num HAVING SUM(quantityitem_price) &gt;=50 ORDER BY ordertotal; SELECT子句顺序1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序limit 分页限定 使用子查询子查询查询（query） 任何SQL语句都是查询。但此术语一般指SELECT语句。子查询（subquery） 即嵌套在其他查询中的查询 利用子查询进行过滤(多重查询) SELECT order_num FROM orderitems WHERE prod_id=’TNT2’; SELECT cust_id FROM orders WHERE order_num in (20005,20007); = SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id=’TNT2’); 子查询一般与IN操作符,等于=，不等于&lt;&gt;等.列必须匹配应该保证SELECT语句具有与WHERE子句中相同数目的列。 通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。 子查询和性能子查询太多影响性能. 作为计算字段使用子查询(在SELECT子句嵌套查询) SELECT cust_name,cust_state,(SELECT COUNT(*) FROM orders WHERE orders.cust_id =customers.cust_id) AS orders FROM customers ORDER BY cust_name; 相关子查询(correlated subquery):涉及外部查询的子查询. orders.cust_id =customers.cust_id 通过增加子查询来建立查询用子查询建立(和建立)查询的最可靠的方法是逐渐进行: 首先——建立和测试最内层的查询. 然后——用硬编码数据建立和测试外层查询,并且仅在确认它正常才嵌入子查询. 重复. 联结表联结关系表相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础. 关系表的设计就是要保证把信息分解成多个表,一类数据一个表. 各表通过某些常用的值(即关系设计的关系)互相关联. 可以分为两个表,A个表有主键，B个表的某列作为A个表的外键. 外键(foreign key):外键为某个表中的一列，它包含另一个表的主键值,定义了两个表之间的关系. 使用外键好处: 数据不重复，不浪费时间和空间 如果改数据，只需要改变A表中的数据就行. 处理数据更加简单. 为啥使用联结当数据存储在多个表,怎么用单条SELECT语句检索数据——使用联结. 维护引用完整性: 联结不是物理实体，他在表中是不存在的 仅在关系列插入合法数据:当向B表插入A表不存在的数据，则这些数据是1不可访问,因为它们没有关联到A表的数据.为了防止这样情况发生,可指示MySQL只允许在B表的关系列中只能出现A表的数据.这就是维护引用完整性. 通过在表定义主键和外键是实现维护引用完整性. 创建联结 SELECT * FROM vendors ,products WHERE vendors.vend_id=products.vend_id ORDER BY vend_name , prod_name; 完全限定列名 vendors.vend_id=products.vend_id 防止产生二义性. WHERE子句的重要性 SELECT vend_name ,prod_name ,prod_price FROM vendors ,products ORDER BY vend_name , prod_name; 在联结两个表时，你实际上左的是将第一个表中的每一行与第二表中的每一行配对. WHERE子句作为过滤条件,它只包含那些匹配给定条件的行. 笛卡尔积(叉联结)如果没有WHERE子句，第一个表中的每个行将与第二表中的每个行配对,不在乎逻辑上是否可以配在一起. 内部联结(INNER JOIN ON) SELECT vend_name ,prod_name ,prod_price FROM vendors INNER JOIN products ON vendors.vend_id=products.vend_id ORDER BY vend_name , prod_name; 等值联结(内部联结)基于两个表之间的相等测试. vendors INNER JOIN products ON vendors.vend_id=products.vend_id A表 INNER JOIN B表 ON 条件 联结多个表 SELECT prod_name , vend_name ,prod_price ,quantity FROM orderitems , products , vendors WHERE products.vend_id=vendors.vend_id AND orderitems.prod_id=products.prod_id AND order_num=20005; 基本规则首先列出所有表,然后定义表之间的关系. products.vend_id=vendors.vend_id AND orderitems.prod_id=products.prod_id 联结太多表会性能下降创建高级联结使用表别名(AS) SELECT cust_name, cust_contact FROM customers AS c, orders AS o ,orderitems AS oi WHERE c.cust_id=o.cust_id AND oi.order_num=o.order_num AND prod_id=’TNT2’; 与列别名差不多，这里给表进行别名. customers AS c 表别名好处 缩短SQL语句 允许在单条SELECT语句中多次使用相同的表. 使用不同类型的联结自联结使用表别名在单条SELECT语句中不止引用相同的表. 过程分析WHERE首先联结两个表,然后用其中一个表过滤. 用自联结而不用子查询 效果是一样的 有时候自联结比子查询快 子查询: SELECT prod_id ,prod_nameFROM productsWHERE vend_id=(SELECT vend_id FROM products WHERE prod_id=’DTNTR’); 自查询: SELECT p1.prod_id ,p1.prod_name FROM products AS p1,products AS p2 WHERE p1.vend_id=p2.vend_id AND p2.prod_id=’DTNTR’; 自然联结自然连接排除多次出现的列,使每个列只返回一次. 实现方式:自己手动完成. SELECT c.* ,o.order_num ,o.order_date , oi.prod_id ,oi.quantity ,oi.item_price FROM customers AS c, orders AS o ,orderitems AS oi WHERE c.cust_id=o.cust_id AND oi.order_num =o.order_num AND prod_id=’FB’; 外部联结可能需要使用联结来完成以下工作: 对每个客户下了多少订单进行计数,包括那些至今尚未下订单的客户; 列出所有产品以及订购数量,包括没有人订购的产品; 计算平均销售规模,包括那些至今尚未下订单的客户。 外部联结联结包含了那些在相关表中没有关联行的行. 许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。 内部联结与外部联结内部联结（INNER JOIN … ON ….） SELECT customers.cust_id ,orders.order_num FROM customers INNER JOIN orders ON customers.cust_id=orders.cust_id; 外部联结( LEFT/RIGHT OUTER JOIN … ON …) SELECT * FROM customers LEFT OUTER JOIN orders ON customers.cust_id=orders.cust_id;SELECT * FROM customers RIGHT OUTER JOIN orders ON customers.cust_id=orders.cust_id; LEFT OUTER JOIN是从FROM子句的左边表中选择所有行。 RIGHT OUTER JOIN是从FROM子句的右边表中选择所有行。 使用带聚集函数的联结.可使用聚集函数与联结相互结合. 外部联结 SELECT customers.cust_name ,customers.cust_id , COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id=orders.cust_idGROUP BY customers.cust_id; 内部联结 SELECT customers.cust_name ,customers.cust_id , COUNT(orders.order_num) AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id=orders.cust_idGROUP BY customers.cust_id; 使用联结和联结条件 注意使用的联结类型。内部联结和外部联结。 保证使用正确的联结条件，否则将返回不正确的数据。 应该总是提供联结条件，否则得出笛卡尔积。 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这样做将使故障排除更为简单。 组合查询组合查询(并UNION)执行多个查询(多个SELECT语句),并将结果作为单个查询结果集返回.(复合查询) 使用场景 在单个查询中从不同的表返回类似结构的数据. 对单个表执行多个查询,按单个查询返回数据. 组合查询和多个WHERE条件组合查询和多个WHERE条件两种不同的查询，效果可以一样.这样可以对比它们的性能来选择查询方式. 创建组合查询利用UNION，可给多条SELECT语句，将它们的结果返回单个合成结果集. 使用UNION SELECT vend_id ,prod_id ,prod_priceFROM productsWHERE prod_price &lt;=5; SELECT vend_id , prod_id, prod_priceFROM productsWHERE vend_id IN(1001,1002); = SELECT vend_id ,prod_id ,prod_priceFROM productsWHERE prod_price &lt;=5UNIONSELECT vend_id , prod_id, prod_priceFROM productsWHERE vend_id IN(1001,1002); 注意: 使用UNION可能比使用WHERE复杂 更复杂的过滤条件或者多个表检索数据——用UNION更好 UNION规则 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型例如，不同的数值类型或不同的日期类型）。 包含或取消重复的行 SELECT vend_id ,prod_id ,prod_priceFROM productsWHERE prod_price &lt;=5UNION ALLSELECT vend_id , prod_id, prod_priceFROM productsWHERE vend_id IN(1001,1002); 不同 UNION(默认)——取消重复行 UNION ALL——包含重复行 对组合查询结果排序 SELECT vend_id ,prod_id ,prod_priceFROM productsWHERE prod_price &lt;=5UNIONSELECT vend_id , prod_id, prod_priceFROM productsWHERE vend_id IN(1001,1002)ORDER BY vend_id,prod_price; 规定 用UNION组合查询时,只能有一条ORDER BY子句 只能出现在最后一条SELECT语句之后. 全文本搜索理解全文本搜索LIKE和正则表达式的限制 性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行(而且这些搜索极少使用表索引)。因此,由于被搜索行 数不断增加,这些搜索可能非常耗时。 明确控制——使用通配符和正则表达式匹配,很难(而且并不总 是能)明确地控制匹配什么和不匹配什么。 智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索,但它们都不能提供一种智能化的选择结果的方法。（一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。） 使用全文本搜索支持过程： 为了进行全文本搜索,必须索引被搜索的列,而且要随着数据的改变不断地重新索引。在对表列进行适当设计后,MySQL会自动进行所有的索引和重新索引。 在索引之后,SELECT可与Match()和Against()一起使用以实际执行搜索。 启用全文本搜索支持 CREATE TABLE productnotes(note_id int NOT NULL AUTO_INCREMENT,prod_id char(10) NOT NULL,note_date datetime NOT NULL,note_text text NULL ,PRIMARY KEY(note_id),FULLTEXT(note_text)) ENGINE=MyISAM; 规定 只能用MyISAM引擎.(ENGINE=MyISAM) 一般在创建表的时候启用全文本搜索，在创建表的时候增加 FULLTEXT(列名) 不要在导入数据时使用FULLTEXT更新索引要花时间,虽然 不是很多,但毕竟要花时间。 如果正在导入数据到一个新表, 此时不应该启用FULLTEXT索引。 应该首先导入所有数据,然后再修改表,定义FULLTEXT。 这样有助于更快地导入数据(而且使索引数据的总时间小于在导入每行时分别进行索引所需 的总时间)。 进行全文本搜索 SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘rabbit’); 个函数Match()和Against()执行全文本搜索. Match()指定被搜索的列（必须与FULLTEXT()定义相同，如果多个列，就要相同切顺序相同的列） Against()指定要使用的搜索表达式 特点 文本中词靠前的行的等级值比词靠后的行等级值高.(降序排列) 由于数据是索引,全文本搜索还是很快的. 使用查询拓展 SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘anvils’ WITH QUERY EXPANSION); 查询扩展（WITH QUERY EXPANSION）用来设法放宽所返回的全文本搜索结果的范围。 运行方式:就是首先将根据关键词全文本搜索找出来行，然后再根据返回出来的行，从中选择有用的词，在和关键词一块作为查询条件进行搜索。 行越多越好布尔文本搜索查询方向 要匹配的词 要排斥的词（如果某行包含这个词，则不返回，即使它包含其他指定的词） 排列提示（指定某些词比其他词更重要，更重要的词等级更高） 表达式分组 布尔方式即使没有定义fulltext 索引，也可以使用，但是它是一种非常缓慢的操作（其性能将随着数据i量的增加而降低） 全文本布尔操作符 布尔操作符 说明 + 包含，词必须存在 - 排除，词必须不出现 &gt; 包含，而且增加等级值 &lt; 包含，且减少等级值 () 把词组成子表达式（允许这些字表达是作为一个组被包含、排除、排列等） ~ 取消一个词的排序值 * 词尾的通配符 “” 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） 大量例子为了匹配heavy但不包含任意以rope开始的词的行 SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘heavy -rope*’ IN BOOLEAN MODE); 布尔操作符+，搜索匹配含词rabbit和bait的行。 SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘+rabbit +bait’ IN BOOLEAN MODE); 没有指定操作符，搜索匹配包含rabbit和bait中的至少一个词的行。 SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘rabbit bait’ IN BOOLEAN MODE); 搜索匹配短语rabbit bait而不是匹配两个词rabbit和baitSELECT note_text FROM productnotes WHERE Match(note_text) Against(‘“rabbit bait”‘ IN BOOLEAN MODE); 搜索匹配rabbit和carrot，增加前者的等级，降低后者的等级。SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘&gt;rabbit &lt;bait’ IN BOOLEAN MODE); 搜索匹配词safe和combination，降低后者的等级。SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘+safe +(&lt;combination)’ IN BOOLEAN MODE); 排列而不排序：在布尔方式中，不按等级值降序排列返回的行。 全文本搜索使用说明 在索引全文本数据时,短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词(如果需要,这个数目可以更改)。 MySQL带有一个内建的非用词(stopword)列表,这些词在索引全文本数据总是被忽略。如果需要,可以覆盖这个列表(请参阅MySQL文档以了解如何完成此工作)。 许多词出现的频率很高,搜索它们没有用处(返回太多的结果)。 因此,MySQL规定了一条50%规则,如果一个词出现在50%以上的行中,则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。 如果表中的行数少于3行,则全文本搜索不返回结果(因为每个词或者不出现,或者至少出现在50%的行中)。 忽略词中的单引号。例如,don’t索引为dont。 不具有词分隔符(包括日语和汉语)的语言不能恰当地返回全文本搜索结果。 如前所述,仅在MyISAM数据库引擎中支持全文本搜索。 插入数据数据插入插入及系统安全： 可针对每个表或每个用户，利用MySQL的安全机制禁止使用INSERT语句。 插入完整的行不安全插入： INSERT INTO customers VALUES(NULL,’Pep E. LaPew’,’100 Main Street’,’Los Aangles’,’CA’,’90046’,’USA’,NULL,NULL); INSERT INTO 表 VALUES(全部列的值); 更安全插入： INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contant,cust_email) VALUES(‘Pep E. LaPew’,’100 Main Street’,’Los Aangles’,’CA’,’90046’,’USA’,NULL,NULL); INSERT INTO 表(具体列) VALUES(具体列的值); 总是使用列的列表 一般不要使用没有明确给出列的列表的INSERT语句。 使用列的列表能使SQL代码继续发挥作用，即使表的结构发生了变化。 仔细地给出值不管使用哪种INSERT语法，都必须给出VALUES的正确数目。 省略列如果表的定义允许，则可以在INSERT操作中省略某些列。 该列定义为允许NULL值（无值或空值） 在表定义中给出默认值。这表如果不给出值，将使用默认值。 提高整体性能数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MySQL的任务。 INSERT操作可能很耗时，而且它可能降低等待处理的SELECT语句的性能。 如果数据检索是最重要的（通常是这样），则你可以通过在INSECT和INTO之间添加关键字 LOW_PRIORITY,指示MySQL降低INSERT语句的优先级。UPPDATE和DELETE语句也是如此。 INSERT LOW_PRIORITY INTO 插入多个行高性能插入多行提高INSERT性能的处理方法,两个括号之间用逗号。 INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country) VALUES (‘Pep E. LaPew’,’100 Main Street’,’Los Aangles’,’CA’,’90046’,’USA’,)， (‘M.Martian’,’42 Galaxy Way’,’New York’,’NY’,’11213’,’USA’,); 用单条INSERT语句处理多个插入比使用多条INSERT语句快. 插入检索出的数据INSERT SELECT使用INSERT SELECT 从A表中将所有数据导入B表中。 INSERT INTO customers(cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_county) SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country FROM custnew; 运行方式MySQL甚至不关心SELECT返回的列名。 它使用的是列的位置,因此SELECT中的第一列(不管其列名)将用来填充表列中指定的第一个列,第二列将用来填充表列中指定的第二个列 INSERT SELECT WHEREINSERT SELECT中SELECT语句可以包含WHEREZ子句以过滤数据。 更新和删除数据更新数据两种更新数据 更新表中特定行； 更新表中所有行。 UPDATE customers SET cust_email = ‘elmer@fudd.com‘, cust_name = ‘The Fudds’ WHERE cust_id = 10005; UPDATE 表 SET 列=值 WHERE 过滤 在UPDATE语句中使用子查询UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。 IGNORE关键字一旦发现一个错的，现在的操作会被取消，而且恢复原值. UPDATE IGNORE 表…. 用UPDATE达到删除特定的列为了删除某个值，可设置它为NULL（假如表定义允许NULL值）。 删除数据两种DELETE方式 从表中删除特定的行； 从表中删除所有行。 DELETE FROM customers WHERE cust_id = 10006; DELETE FROM 表 WHERE 过滤条件; DELETE只能删除整个行DELETE不需要列名或通配符。DELETE删除整行而不是整列。为了删除特定的列，请使用UPDATE语句。 删除表的内容而不是表DELETE语句从表中删除行,甚至是删除表中所有行。但是,DELETE不删除表本身。 更快的删除(TRUNCATE TABLE)如果想从表中删除所有行,不要使用DELETE。 可使用TRUNCATE TABLE语句,它完成相同的工作,但速度更快。 (TRUNCATE实际是删除原来的表并重新创建一个表,而不 是逐行删除表中的数据)。 更新和删除的指导原则 除非确实打算更新和删除每一行,否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。 保证每个表都有主键,尽可能像WHERE子句那样使用它(可以指定各主键、多个值或值的范围)。 在对UPDATE或DELETE语句使用WHERE子句前,应该先用SELECT进 行测试,保证它过滤的是正确的记录,以防编写的WHERE子句不正确。 使用强制实施引用完整性的数据库 。 PS:小心使用，MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE。否则你会发现自己更新或删除了错误的数据。 创建和操作表创建表MySQL不仅用于表数据操纵,而且还可以用来执行数据库和表的所有操作,包括表本身的创建和处理。 表创建基础 CREATE TABLE customers ( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(50) NULL, cust_zip char(50) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(50) NULL, PRIMARY KEY (cust_id) )ENGING = InnoDB; CREATE TABLE 表名( 列名 数据类型 NULL/NOT NULL (AUTO_INCREAMENT) (DEFAULT 值) PRIMARY KEY(列) )ENGING= InnoDB; 处理现有的表在创建新表时表名必须不存在。 如果要防止意外覆盖已有表,SQL要求首先手工删除该表,然后再重建它,而不是简单地用创建表语句覆盖它。 (如果你仅想在一个表不存在时创建它,应该在表名后给出IF NOT EXISTS.这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在,并且仅在表名不存在时创建它) 使用NULL值NULL值不是空串. 主键在介绍 CREATE TABLE orderitems ( order_num int NOT NULL, order_item int NOT NULL, prod_id char(10) NOT NULL, quantity int NOT NULL, item_price decimal(8,2) NOT NULL, PRIMARY KEY (order_num,order_item) )ENGING = InnoDB; 主键限制 主键值必须唯一。 如果主键使用单个列,则它的值必须唯一 如果使用多个列,则这些列的组合值必须唯一 使用AUTO_INCREMENT作用值自动增加 限制每个表只允许有一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。 确定AUTO_INCREMENT值用last_insert_id()函数来返回最后一个AUTO_INCREMENT值。 SELECT last_insert_id() 指定默认值 CREATE TABLE orderitems ( order_num int NOT NULL, order_item int NOT NULL, prod_id char(10) NOT NULL, quantity int NOT NULL DEFAULT 1, item_price decimal(8,2) NOT NULL, PRIMARY KEY (order_num,order_item) )ENGING = InnoDB; 方式针对列DEFAULT 值. 不允许函数：与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。 使用默认值而不是NULL值：许多数据库开发人员使用默认值而不是NULL列，特别是对于极端或数据分组的列更是如此。 引擎类型引擎类型(不止) InnoDB 是一个可靠的事务处理引擎 , 它不支持全文本搜索; MEMORY在功能等同于MyISAM,但由于数据存储在内存(不是磁盘) 中,速度很快(特别适合于临时表); MyISAM是一个性能极高的引擎,它支持全文本搜索, 但不支持事务处理。 引擎类型可以混用。外键不能夸引擎混用引擎类型有一个大缺陷。外键(用于 强制实施引用完整性)不能跨引擎. 更新表为更新表定义,可使用ALTER TABLE语句。但是,理想状态下,当表中存储数据以后,该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑,以便后期不对该表进行大的改动。 (表)添加列 ALTER TABLE vendors ADD vend_phone CHAR(20); ALTER TABLE 表 ADD 列 列属性; (表)删除列 ALTER TABLE vendors DROP COLUMN vend_phone; ALTER TABLE 表 DROP 列; 定义外键 ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FORIGN KEY (order_num) REFERENCES orders(order_num); ALTER TABLE 表A ADD CONSTRAINT 外键约束名 FORIGN KEY (列) REFERENCES 表B(列); 复杂表结构快捷手动删除 用新的列布局创建一个新表； 使用 INSERT SELECT从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段； 检查包含所需要数据的新表； 重命名旧表（如果确定，可以删除它）； 根据需要，重新创建触发器、存储过程、索引和外键。 删除表删除表（删除整个表而不是其内容）： DROP TABLE customers2； DROP TABLE 表； 重命名单个表改名 RENAME TABLE 名A TO 名B; 多个表改名(逗号隔开) RENAME TABLE 名A TO 名B， ​ 名C TO 名D， ​ 名E TO 名F； 创建视图视图视图是虚拟的表. 视图只包含使用动态检索数据的查询. 为什么使用视图 重用SQL语句； 简化复杂的SQL操作。在编写查询以后，可以方便地重用它而不必知道他的基本查询细节。 使用表的组成部分而不是整个表； 保护数据。可以给用户授予特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 性能问题：因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需要的任意检索。 如果你用多个联结和过滤创建了复杂的视图或嵌套视图，可能会发现性能下降的很厉害。 因此，在部署使用大量视图的应用前，应该进行测试。 视图的规则和限制 视图名唯一 没有数目限制 可以嵌套视图使用 ORDER BY 可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用. 使用视图使用视图： 创建视图：CREATE VIEW 查看视图：SHOW CREATE VIEW 视图名; 删除视图：DROP VIEW 视图名； 更新视图：**可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW;**（如果要更新的视图不存在，则第二条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有的视图。） 利用视图简化复杂的联结视图最常用的应用之一就是隐藏复杂的SQL。 CREATE VIEW productcustomers AS SELECT cust_name ,cust_contact,prod_id FROM customers ,orders ,orderitems WHERE customers.cust_id =orders.cust_id AND orderitems.order_num=orders.order_num ; CREATE VIEW 视图名 AS SELECT查询语句 创建可重用的视图一种好办法是创建不受特定数据限制的视图是一种好办法. (拓展视图的范围不仅使得它能被重用,而且甚至更加有用.这样做不需要创建和维护多个类似得视图.) 用视图重新格式化检索出的数据 CREATE VIEW vendorlocations AS SELECT Concat(RTrim(vend_name),’(‘ ,RTrim(vend_country),’)’) AS vend_title FROM vendors ORDER BY vend_name; 用视图过滤不想要的数据视图对于应用普通的WHERE子句也很有用. CREATE VIEW customeremaillist AS SELECT cust_id ,cust_name ,cust_email FROM customers WHERE cust_email IS NOT NULL; 使用视图与计算字段视图对于简化计算字段的使用特别有用. CREATE VIEW orderitemsexpanded AS SELECT order_num,prod_id ,quantity ,item_price ,quantity*item_price AS expeanded_price FROM orderitems ; 更新视图视图是可以更新的(可以用INSERT,UPDATE和DELETE). 如果你对视图增加或删除行,实际上对其基表增加或删除行. 限制(可以更新但是有限制) 分组(使用GROUP BY和HAVING) 联结 子查询 并(UNION) 聚集函数(Min(),Count()等) DISTINCT 导出(计算)列 将视图用于检索一般来说，应该把视图用于检索(SELECT语句)而不用于更新(INSERT,UPDATE和DELETE); 使用存储过程","link":"/Liust1918.githud.io/2022/12/04/Mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/Liust1918.githud.io/tags/Hexo/"},{"name":"git","slug":"git","link":"/Liust1918.githud.io/tags/git/"},{"name":"githud","slug":"githud","link":"/Liust1918.githud.io/tags/githud/"},{"name":"java","slug":"java","link":"/Liust1918.githud.io/tags/java/"},{"name":"java8","slug":"java8","link":"/Liust1918.githud.io/tags/java8/"},{"name":"spring","slug":"spring","link":"/Liust1918.githud.io/tags/spring/"},{"name":"技术书","slug":"技术书","link":"/Liust1918.githud.io/tags/%E6%8A%80%E6%9C%AF%E4%B9%A6/"},{"name":"Hibernate","slug":"Hibernate","link":"/Liust1918.githud.io/tags/Hibernate/"},{"name":"springboot2","slug":"springboot2","link":"/Liust1918.githud.io/tags/springboot2/"},{"name":"后端","slug":"后端","link":"/Liust1918.githud.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"C","slug":"C","link":"/Liust1918.githud.io/tags/C/"},{"name":"C++","slug":"C","link":"/Liust1918.githud.io/tags/C/"},{"name":"Android","slug":"Android","link":"/Liust1918.githud.io/tags/Android/"},{"name":"设计模式","slug":"设计模式","link":"/Liust1918.githud.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","link":"/Liust1918.githud.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","link":"/Liust1918.githud.io/tags/LeetCode/"},{"name":"SSM","slug":"SSM","link":"/Liust1918.githud.io/tags/SSM/"},{"name":"mysql","slug":"mysql","link":"/Liust1918.githud.io/tags/mysql/"}],"categories":[{"name":"C语言","slug":"C语言","link":"/Liust1918.githud.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"git","slug":"git","link":"/Liust1918.githud.io/categories/git/"},{"name":"java","slug":"java","link":"/Liust1918.githud.io/categories/java/"},{"name":"Android","slug":"Android","link":"/Liust1918.githud.io/categories/Android/"},{"name":"设计模式","slug":"设计模式","link":"/Liust1918.githud.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"后端","slug":"后端","link":"/Liust1918.githud.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"spring","slug":"后端/spring","link":"/Liust1918.githud.io/categories/%E5%90%8E%E7%AB%AF/spring/"},{"name":"Hexo","slug":"Hexo","link":"/Liust1918.githud.io/categories/Hexo/"},{"name":"LeetCode","slug":"LeetCode","link":"/Liust1918.githud.io/categories/LeetCode/"},{"name":"SSM","slug":"后端/SSM","link":"/Liust1918.githud.io/categories/%E5%90%8E%E7%AB%AF/SSM/"},{"name":"java8","slug":"java/java8","link":"/Liust1918.githud.io/categories/java/java8/"},{"name":"数据库","slug":"后端/数据库","link":"/Liust1918.githud.io/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"后端/数据库/Mysql","link":"/Liust1918.githud.io/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"}],"pages":[]}