{"posts":[{"title":"Hexo常用操作","text":".","link":"/Liust1918.githud.io/2022/12/03/My-New-Post/"},{"title":"sb","text":"C语言入门 第一章软件安装 进入微软官网 下载Visual Studio 1https://visualstudio.microsoft.com/zh-hans/ 下载社区版Community 选择 使用C++的桌面开发 新建项目和项目结构,编译新建项目 选择一个模板(例如:空项目,控制台应用等等) 确定项目 解决方案名称：相当于java的项目名 项目名称:相当于java的包名 对源文件右键新建项 将.cpp 改为 .c 项目结构 .c 为源文件 项目编译过程 源代码: .c 目标代码: .obj 可执行代码: .exe 项目运行和调试运行 main类(入口类，只能有一个) main主方法 点击 调试 设置断点 点击本地Windows调试器 看内存和监视 调试快捷键 功能 快捷键 给改行添加断点(再点一次就取消断点) fn+F9 从main()函数的第一条语句开始执行 fn+F10 执行下一条语句 fn+F10 不进入子函数，但是会将子函数的代码执行完 fn+F10 程序一直执行到断点 fn+F5 退出调试 fn+shift+F5 重新调试代码 fn+ctrl+shift+F5 进入子函数内 fn+F11 退出子函数 fn+shift+F11 第二章命名规范 关键字限制 大小写敏感 字母，数字(不能开头)，下划线为变量名 变量和常量变量a为变量 12int a;a=3; 符号常量 添加 #define 预处理关键字 不可再赋值 常量名全大写 不用加分号 1#define 常量名(全大写) 常量值 1#define PI 3 查看变量的内存(使用VS的监视和内存) 添加断点 在监视的名称中填入 &amp;变量名 获得 监视 中的 值 将 值 拖入到 内存中，显示内存 例： 输入和输出从屏幕输出prinf（标准输出）例: 12345#include &lt;stdio.h&gt;int main(){ int a=3; printf(&quot;%d&quot;,a);} 输出格式化 字符类型 作用 格式控制 %d 带符号整数 负号向右对其 %Ad（A为位数） %f 浮点数 %A.Bf (A整数位数,B为小数位数) %c 字符 %s 一串字符 %u 无符号整数 %x 无符号十六进制，小写字母 从屏幕输入scanf（标准输入） 注意赋值到变量 必须添加**&amp;符号** &amp;变量名 例: 12345#include &lt;stdio.h&gt;int main(){ int b; scanf(&quot;%d&quot;,&amp;b);} 读取标准输入缓冲区问题问题1234567int a;char c;scanf(&quot;%a&quot;,&amp;a);printf(&quot;%a&quot;,a);scanf(&quot;%c&quot;,&amp;c);printf(&quot;%c&quot;,c);//程序会在第一个输入完后，直接跳到最后 原理 每次输入后回车, 缓冲区会有 内容+”\\n” 再次输出后 ，缓冲区有 “\\n” 但是字符类型发现还有内容，所以直接输出,不再暂停 匹配规则 整型，浮点数，字符串 会忽略’\\n’(回车符)，空格符等 字符类型会识别 消除\\n换行符号问题描述123456//前面有输入(输出后会在标准输入缓冲区 有'\\n')scanf(&quot;%d&quot;,&amp;d);...//这里会卡住gets(p); 解决添加,来消除“\\n” 12char c;scanf(&quot;%c&quot;,c); 1234567//前面有输入(输出后会在标准输入缓冲区 有'\\n')scanf(&quot;%d&quot;,&amp;d);char c;scanf(&quot;%c&quot;,c);//这里会卡住gets(p); 错误问题: 由于微软的C语言标准问题，会报错,或者使用其他包 解决方法: 1#define _CRT_SECURE_NO_WARNINGS //解决scanf编译问题 数据类型 数据类型 字节 int 4 float/double 4 char 1 注: 1位 (bit) 存储 0(高电)或1(低电) 1字节（byte）=8位（bit） 1Kb=2^10 byte 1Mb=2^10 Kb 整型进制变换 常用进制 范围 输出字符 十进制 0-9 %d 二进制 1 0 八进制 0-7 %o 十六进制 0-9 a-f %x 高转低进制高除低取余,倒取值,从左到右,高位开始 (在vs中的内存，由于cpu的小端存储，所以是从左到右是低位开始) 赋值 直接十进制 0xXX 十六进制 （例如: 0x7b 输出123） 输出12int a=12;printf(&quot;%d&quot;,a); 浮点型f赋值 类型 案例 小数类型 0.xxxxx 指数类型(不推荐) AeB(B不能位小数) = Ax10^B 12float f=0.123;float f=1.23e3; 输出12float f=0.123;printf(&quot;%f&quot;,f); 字符型常量c赋值 单引号 转译字符 \\n 换行 \\b 退格 \\\\ 反斜杠 1char c='A' 大小写转换 字符 ASCII码 A 65 a 97 注意:相差32 1234char c='a';c=c-32;printf(&quot;%c&quot;,c);//输出 A 输出12char a='a';printf(&quot;%c&quot;,a); 字符串常量（C语言不提供，通过字符数组提供）规定 结尾添加一个字符串结束标记（占x+1字节） 结束符 “\\0” ‘\\0’==0 ==&gt;ture 运算符 运算符 符号 算数 + - * / % 关系 &gt; &lt; == &lt;= &gt;= != 逻辑 ! &amp;&amp; || 赋值 = 位 &lt;&lt; &gt;&gt; ~ | ^ &amp; 条件 ?： 求字节数 sizeof 强制类型转换 (类型) 逗号 ，。 指针 * &amp; 分量 . -&gt; 下标 [] 自增减 – ++ 算数运算符注意 % ： 两边只能整数 优先级:乘除取余 &gt; 加减 关系运算符注意 0 高 false 1 低 ture 一切非0值 ture 浮点数比较是否为某值 IEEE 754会把浮点数近似 别用==比较浮点数 要用距离数轴0.0001的 1234float f=123.45if(f-123.45&gt;-0.0001 &amp;&amp; f-123.45&lt;0.0001){} 逻辑运算符 || 一真则真，全假为假 0 false &amp;&amp; 一假则假，全真为真 1 true ! !0=1 !1=0 !X(非0数)=0 赋值运算符= 位运算符条件运算符求字节数运算符注意 sizeof(变量) 自增减运算符注意 不能用于常量 ```ca=i++;//等于a=i;i++; 1234567891011121314151617#### 逗号运算符##### 注意- 从左向右执行- 用逗号隔开每个表达式- **最后一个表达式为ture，整个判断才为ture**```cif((表达式1),(表达式2),(表达式3)....){} 指针运算符混合运算输出和强制转型12345int i=5;float j= i/2; //输出2float k= (float)i / 2 //输出2.5//两个整数就进行整数运算//其余进行浮点运算 多个输出和输入1234scanf(&quot;%d%f%c&quot;,&amp;a,&amp;b,&amp;c);printf(&quot;%d%f%c&quot;,a,b,c);//一一对应//在cmd输入操作 先输入第一个数，再空格，再输入第二个数.... 混合数据类型读取一个scanf读多种类型的数据 混合输入时每次在%c之前需要加入空格 12345678int main(){ int i; char c; float f; scanf(&quot;%d %c%f&quot;,&amp;i,&amp;c,&amp;f); printf(&quot;i=%i,c=%c,f=%f&quot;,i,c,f); return 0;} 循环读取 while(…){} rewind(stdin) 每次都将标准输入缓冲区清空 i=scanf(“%d”,&amp;a)!=EOF EOF为常量-1，作为错误标识 输入正确时候，i有值，否则为-1 行首按三次ctrl+Z 12345678int main(){ int i,ret; while(rewind(stdin),(ret=scanf(&quot;%d&quot;,&amp;i))!=EOF){ printf(&quot;i=%d\\n&quot;,i); } return 0;} 12345678910111213int main(){ char c; while(scanf(&quot;%c&quot;,&amp;c)!=EOF){ if(c!='\\n'){ printf(&quot;%c&quot;,c-32); } else{ printf(&quot;\\n&quot;); } } return 0;} 第三章简单运算符优先级算术&gt;关系&gt;逻辑或与 选择 if(){} if(){} else{} if(){} else if(){ } else{} 循环 while(){ } for(表达式1；表达式2；表达式3){} 和1java一样 continue; 结束本次循环 break; 结束整个循环 第四章数组一维数组(初试不考)定义123456//类型说明符 数组名[常量表达式];int a[10];//例1int b[10]={1,2,3,4,5,6,7,8,9,10}; 注意 数组大小不能动态定义 一定是常量表达式,不能为变量,不能为0 数组一开始就定义了大小，不能更改 默认值都为0 下标从0开始，小心数组越界 数组在传递时，元素个数传递不过去 12345void print(int a[],int len){//数组不主动定义范围//并且传递一个数组的元素个数值过去} 字符数组定义12345678char a[4];a[0]='a';a[1]='';... char a[4]={'a','b','c','d'};char a[5]=&quot;1234&quot;; 注意 字符数组最后一位会有 ‘\\0’ 作为结束符号 所以最后一位别赋值 或者 定义数组时候（直接范围+1） 否则会出现 ”烫烫“ 0x cc cc cc cc 123char a[10];//可以存9为字符//最后一位(下标9)是'\\0' 输入输出字符串%s使用1234567//1定义字符数组char a[10];//标准输入 scanf(&quot;%s&quot;,字符数组变量);scanf(&quot;%s&quot;,a);//标准输出 printf(&quot;%s&quot;,字符数组变量);printf(&quot;%s&quot;,a); 注意 在使用**%s**的时候 当输入的字符数组存空格符号\\n ，会停止输出 所以引出下面的gets函数 gets函数使用类似scanf 1char *gets(char *str); 函数从STDIN（标准输入）读取字符串 将字符串加载到str 遇到 \\n 或者 EOF 才停止 会存储空格 注意 gets函数会把 字符串中的 ‘\\n’ 转化为 ‘’\\0’ 只能去输入字符串 当一次读取一行时候使用 puts函数使用类型printf 1int puts(char *str); 函数把str 写入 STDOU(标准输出) 成功执行返回 非负值 失败则返回 EOF 会输出空格 注意 会打印出换行符\\n 例子123456void main(){ char c[10]; gets(c); puts(c); //等价于printf(&quot;%s\\n&quot;,c) return 0;} str系列字符串操作函数先引用头文件 1#include &lt;string.h&gt; 注意1const说明必须是常量 strlen统计字符串长度 1size_t strlen(char *str); 区分sizeof() sizeof统计数组声明时候的大小 strlen是数组的实际大小 123char a[10]=&quot;123&quot;sizeof(a);//返回10strlen(a);//返回3 strcpy将某个字符串复制到字符数组中 1char *strcpy(char *to,const char *from); strcmp比较两个字符串的大小 1int strcmp(const char *str1,const char *str2) 注意 比较对应字符位置的ascii码值, 本质上 str1-str2 str1=str2 输出0 str1&lt;str2 输出-1 str1&gt;str2 输出1 strcat将后一个字符串拼接到前一个字符串的后面 1char *strcat(char *str1,const char *str2); 注意 前一个字符数组大小=原本存储字符串大小+后加字符串大小+一位结束符 第五章指针本质——保存地址指针的定义使用1基类型 *指针变量名 123456int a=1;// 变量a地址=变量a的值int *p=&amp;a;// 指针地址=指针变量(保存变量a的地址)int *a,*b,*c; 直接访问和间接访问12345678int main(){ int a=1; int *p=&amp;a; //直接访问 printf(&quot;%d\\n&quot;, a); //间接方法 printf(&quot;%d\\n&quot;, *p);} 注意 什么类型的指针一定要指向对应类型的变量 (IEEE754标准) 变量不包含* 取地址操作符&amp;和取值操作符*使用 &amp; 取地址/引用 * 取值/解引用—-获取地址的值 12345678int main(){ int a=1; int *p=&amp;a; //直接访问 printf(&quot;%d\\n&quot;, a); //间接方法 printf(&quot;%d\\n&quot;, *p);} 注意 **&amp;a=*&amp;a=a* 例如*&amp;a 首先 &amp;a 得到a的地址 再*运算 取地址中的值 得到 a的值 没有意义 指针即可读又可写 12*p=5;int a=*p 指针的使用场景—传递与偏移传递–传递指针使用地址的传递,例如在函数之间传递 1234567891011121314151617181920212223#include &lt;stdio.h&gt;//指针的传递void change1(int* e) { //接收到相同基类型的指针 //对i地址(指针j地址) 进行取值 获得 变量i地址（指针变量） //对变量i地址赋值 =5 *e = 5;}void main() { // 变量i地址=变量值 int i = 10; printf(&quot;使用指针:主函数直接传指针给副函数\\n&quot;); // 指针j地址=变量i地址（指针变量） int* j = &amp;i; printf(&quot; before %d\\n&quot;, i); //将指针j地址传输到副函数 change1(j); printf(&quot;after %d\\n&quot;, i); return 0;} 或者 12345678910111213141516171819#include &lt;stdio.h&gt;void main() { int a = 15; int* b = &amp;a; int* c = b; int d = *c; printf(&quot;%d\\n&quot;, d);//输出 15 int a1 = 15; int* b1 = &amp;a1; int* c1 = b1; *c1 = 20; printf(&quot;%d\\n&quot;, a1);//输出20 return 0;} 注意 传输指针地址 1change1(j); 获取指针的指针变量(获得i的地址 ,并对他赋值) 1*e = 5; 可以达到通过副函数 修改 主函数局部变量的值 偏移——指针加减使用指针通过加减来实现数组的偏移 123456789101112131415#include &lt;stdio.h&gt;void main() { //指针的偏移 int arr[10] = { 1,2,3,4 }; int* p = arr; printf(&quot;指针指向数组的起始地址(数组第一个元素) %d\\n&quot;, *p); p++; printf(&quot;指针+1 %d\\n&quot;, *p);//输出1 p++; printf(&quot;指针+1 %d\\n&quot;, *p);//输出2 return 0;} 注意 指针 数组 例子 *p=arr 指向数组的起始地址(数组的第一个元素,下标为0) 0x000000 p+1 (指针+1) 指针指向地址=数组起始地址+基类型字节数 (数组的 下一个元素) 0x000004 p+1 (指针+1) 0x000008 指针的类型与数组的基类要一致 自增,自减运算符使用指针和自增减运算符 123456789101112131415161718192021#include &lt;stdio.h&gt;void main() { int a[4] = { 3,2,4 }; int* p; int j; p = a; j = *p++; printf(&quot;a[0]=%d,j=%d,*p=%d\\n&quot;, a[0], j, *p);//输出 3 3 2 int a1[4] = { 1,2,3 }; int* p1; int j1; p1 = a1; j1 = (*p1)++;//等价于 j1=a[0]++; 或者 j1=p[0]++; *p1获取 地址中的值 并且改变 printf(&quot;a1[0]=%d,j1=%d,*p1=%d\\n&quot;, a1[0], j1, *p1);//输出 2 1 2 return 0;} 注意1234a=*p++//等于a=p*;p++; 1234567j1=(*p)++;//等于//*p 获取地址的值 //1. j1=*p=1//2. 修改数组的值 a[0]++; 让a[0]=1+1=2//3. 指针没有偏移 一堆数组 函数调用的本质是值传递 在传递值为数组时候，只会传递数组的首地址，不会传数组大小 数组传递的时候 ，弱化为指针 123void change(char *d){}//等价于void change(char d[]){} 数组名作为实参 传递给 子函数时候，弱化为指针 1234567891011121314#include &lt;stdio.h&gt;void change(char* a) { *a = 'j';}void main() { char arr[10] = &quot;hack&quot;; printf(&quot;原来:%s\\n&quot;, arr);//hack change(arr); printf(&quot;变成:%s\\n&quot;, arr);//jack return 0;} 动态内存申请malloc 数组长度固定(一开始就确定了)很不方便,长度是因为变量都在栈空间 如果使用的空间大小不确定，那么就要使用堆空间 使用 确定申请空间大小 int类型 以字节为单位 使用malloc申请内存空间 1void* malloc(i); 返回无类型指针void* 指针指向申请空间的起始地址 申请空间的大小=i个字节 必须进行类型转换 例如void*转char*,那么char*可以存放i个字符(1个字符一个字节), 如果是int就可以存放i/4个数(1个int要4字节) 依次类推 指针主动释放空间free 指针不能产生偏移，否则会报错 或者说指针一定要是原来的malloc返回值要一致 如果一定要用这个指针进行偏移，那么可以新增一个指针 1free(指针); 指针置空—-防止野指针 野指针—当指针指向的空间，不是属于它的空间的时候. 如果不把上诉指针=null,则成为野指针 1指针=NULL; 例子123456789101112131415#include &lt;stdio.h&gt;//动态内存分配void main() { int i = 20; char* p; p = (char*)malloc(i); strcpy(p, &quot;success&quot;); printf(&quot;%s\\n&quot;, p); free(p); p = NULL; return 0;} 栈空间和堆空间 栈空间——随着函数的执行结束而释放 堆空间——不会随着子函数的结束而释放，除非用free释放空间 字符指针与字符数组的初始化使用 都可以初始化一个字符串 1234char *p=&quot;114514&quot;;//把字符串型常量&quot;hello&quot;的首地址赋给pchar c[10]=&quot;114514&quot; //等于strcpy(&quot;hello&quot;) 区别内存有权限–可读/可写 12345//无法运行//在字符串常量区不可以修改p[0]='5';//可以运行c[0]='5'; 12345//字符串123的地址给pp=&quot;123&quot;;//无法运行//地址已经确定，无法改变c=&quot;123&quot;; 二级指针的传递（了解）作用 传递 偏移 服务一级指针的传递与偏移 使用 &amp;指针—-对指针取地址 **基类型——函数接收二级指针 12345678910111213#include &lt;stdio.h&gt;//副函数void change(**int a){ }//主函数void mian(){ ... change(&amp;指针);} 一级指针详细 例子123456789101112131415161718#include &lt;stdio.h&gt;void change(int** ap, int* pb) { *ap = pb;}void main() { int a = 10; int b = 5; int* ap = &amp;a; int* bp = &amp;b; printf(&quot;a=%d,ap=%d,bp=%d\\n&quot;, a, *ap, *bp);// 10 10 5 change(&amp;ap, bp); printf(&quot;a=%d,ap=%d,bp=%d&quot;, a, *ap, *bp);// 10 5 5 return 0;} 第六章函数头文件创建 使用—声明函数(类似java的接口,.c文件是实现类) 声明方法(后续**.c文件实现**) 引用包 123456#include &lt;stdio.h&gt;void getOne();int getInt(int i); .c文件引用头文件 #include “头文件.h” 12//例如头文件为 func.h#include &quot;func.h&quot; 函数声明(定义)和调用 在头文件声明方法 在.c文件引用头文件, 并实现函数 其他.c文件只要引用同样的头文件,就可以使用其他.c文件的实现函数 递归调用递归函数自己调用自己 一般递归套路 确定递归函数 确定结束条件 例子求n的阶乘 123456789101112131415161718192021#include &lt;stdio.h&gt;//求i的阶乘int change(int i) { //i==1 setback if (i == 1) { return 1; } //f(n)=n*f(n-1) return i * change(i - 1);}void main() { int count; count = change(5); printf(&quot;%d\\n&quot;, count); return 0;} 爬楼梯问题(斐波那契数列) 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;//爬楼梯问题//i个阶梯 只能走1或者2步 求多少钟走法//阶梯 1 2 3 4 5//方法数 1 2 3 5 8int ladderFunction(int i) { if (i == 1) { return 1; } if (i == 2) { return 2; } return ladderFunction(i - 1) + ladderFunction(i - 2);}void main() { int count; count = ladderFunction(5); printf(&quot;%d&quot;, count); return 0;} 变量和函数的作用域局部变量 函数内 作用范围:最近的大括号 存储在栈空间 全局变量 函数外 存储在内存空间中的数据区 不推荐使用 优先局部&gt;全局 例子1234567891011#include &lt;stdio.h&gt;int i = 10;void main() { int i = 5; i++; printf(&quot;局部变量%d\\n&quot;, i); return 0;} 中级结构体和结构体指针结构体的定义，引用，初始化定义1234struct 结构体名{ 数据类型 名; 数据类型 名[数组];} 例子123456//结构体定义struct box { int id; int num; char name[20];}; 初始化一般123//结构体的初始化 struct box apple = { 5,100,&quot;苹果&quot; }; 结构体数组12struct box fruit[3] = { 5,100,&quot;苹果&quot;,7,200,&quot;香蕉&quot;,8,300,&quot;橘子&quot; }; 引用123456//方式一printf(&quot;box.id=%d,box.num=%d,box.name=%s\\n&quot;, apple.id, apple.num, apple.name);//方式二printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, fruit[i].id, fruit[i].num, fruit[i].name); 结构体指针初始化一般12//结构体指针struct box* p = &amp;apple; 数组1struct box* p1 = fruit; 使用 指针-&gt;结构体的属性 (*指针).结构体的属性 .的优先级比*要高，会报错 所以一定要加括号 1234567//printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, *p.id, *p.num, *p.name); //.的优先级比*要高，所以不建议 // .选择(对象) // -&gt;选择(指针) printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, (*p).id, (*p).num, (*p).name); printf(&quot;fruit:id=%d num=%d name=%s \\n&quot;, p-&gt;id, p-&gt;num, p-&gt;name); 其他 .和-&gt; 以及 [] （）的优先级是第一 特殊1123num = p1-&gt;id++; //num=p1-&gt;id //p1-&gt;id=p1-&gt;id+1 特殊2123num = p1++-&gt;id; //num=p1-&gt;id //p1=p1+1 12345678910struct box* p1 = fruit; int num; num = p1-&gt;id++; //num=p1-&gt;id //p1-&gt;id=p1-&gt;id+1 printf(&quot;after:num=%d,id=%d \\n&quot;, num, p1-&gt;id); num = p1++-&gt;id; //num=p1-&gt;id //p1=p1+1 printf(&quot;after:num=%d,id=%d \\n&quot;, num, p1-&gt;id); typedef使用作为别名 作结构体/数据类型的别名格式123typedef struct 结构体名{ .....}别名1,*指针别名1; 可以作为结构体的别名 或者做结构体指针的别名 使用1234//方式1别名1 对象名={...}//方式2(指针)指针别名1 指针名=对应指针 例子创建 1234567typedef struct box { int id; char name[20]; int num;}bo, * pbo;typedef int Integer; 使用 1234567891011void main() { bo mybox = { 200,&quot;你是才是&quot;,20 }; printf(&quot;box.id=%d,box.name=%s,box.num=%d\\n&quot;, mybox.id, mybox.name, mybox.num); pbo p = &amp;mybox; printf(&quot;box.id=%d,box.name=%s,box.num=%d\\n&quot;, p-&gt;id, p-&gt;name, p-&gt;num); Integer i = 5; return 0;} C++的引用操作 在函数的形参前添加&amp; 1234567891011//参数void modify_variable(int&amp; a) { a++;}//指针void modify_digital(int*&amp; p) { p = (int*)malloc(20); p[0] = 20;} 作用 可以用来传递变量/指针到其他函数，并且在其他函数操作它们可以和在主函数一样方便 例子12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void modify_variable(int&amp; a) { a++;}void modify_digital(int*&amp; p) { p = (int*)malloc(20); p[0] = 20;}void main() { int a = 10; printf(&quot;before:a=%d\\n&quot;, a);//10 modify_variable(a); printf(&quot;after:a=%d\\n&quot;, a);//11 int* p = NULL; modify_digital(p); printf(&quot;after:p=%d\\n&quot;, *p);//20} 等同C传递变量C++:12345int a;void modify(int&amp; a) { a++;}调用:modify(a); C:12345int a;void modify(int* a) { (*a)++;}调用:modify(&amp;a); 传递指针C++:12345int* p = NULL;void modify(int*&amp; p) { p = q;}调用:modify(p); C:12345int* p = NULL;void modify(int** p) { *p = q;}调用:modify(&amp;p); 逻辑结构和存储结构 时间复杂度和空间复杂度 线性表特性(逻辑结构)定义由n(n&gt;=0)个相同类型的元素组成的有序结合 n为表长**,n=0为空表** ai-1是ai的前驱 ai+1是ai的后继 特定 元素个数有限 元素数据类型相同(所占大小一样) 元素逻辑上顺序性 顺序表(线性表的顺序表示)特点优点 随机存取:根据表头元素地址和元素序号 存取 表中任意一个元素. 存储密度高 缺点 插入和删除要移动大量元素 变化大时,难确定存储空间的容量 存储分配是一整段连续的存储空间,碎片多 构造顺序表静态分配123456#define MaxSize 20 //表长typedef int ElemType;//将数据类型进行别名 方便改typedef struct { ElemType data[MaxSize];//数组存储数据 int length;//数组内存储的实际量}sqList; 动态分配(了解)创建12345678//动态分配#define InitSize 100typedef int ElemType;typedef struct { ElemType* data; int Maxsize, length;}DynamicSqList; 初始化1234//C的初始动态分配 DL.data = (ElemType*)malloc(sizeof(ElemType) * InitSize); //C++的初始动态分配(了解) DL.data = new ElemType[InitSize]; insert思路 元素后移 插入元素 实际容量++ 时间复杂度(移动元素,尾插法) 情况 O(f(n)) 说明 最好 O(1) 最后插入一个 最差 O(n) 第一个插入一个,要全部后移 平均 O(n/2) 取最好和最差的平均值 代码1234567891011121314151617181920//插入bool insertElem(sqList&amp; L, int index, ElemType number) { //查看插入位置是否合法 if (index&lt;1 || index&gt;MaxSize) { return false; } //查看数组是否满了 if (L.length &gt; MaxSize) { return false; } //处理 for (int i = L.length; i &gt;= index; i--) { L.data[i] = L.data[i - 1]; } L.data[index - 1] = number; //增长实际长度 L.length++; return true;} delete思路 元素前移覆盖实现删除 实际容量– 时间复杂度 情况 O(f(n)) 说明 最好 O(1) 删除最后一个 最差 O(n) 删除第一个,要全部前移动 平均 O(n/2) 取最好和最差的平均值((n-1)/2) 代码1234567891011121314151617181920//删除bool deleteElem(sqList&amp; L, int index, ElemType&amp; number) { //检查删除是否合理 if (index &lt; 1 || index&gt;L.length) { return false; } //检查是否为空表 if (L.length == 0) { return false; } //处理 number = L.data[index - 1]; for (int i = index; i &lt; L.length; i++) { L.data[i - 1] = L.data[i]; } //减少实际长度 L.length--; return true;} locate思路暴力寻找 代码123456789//查(返回位置(下标位置+1)，找不到为0)int locateElem(sqList L, ElemType i) { for (int i = 0; i &lt; L.length; i++) { if (L.data[i] == i) { return i + 1; } } return 0;} 链表(线性表的链式表示)单链表特点 数据域 指针 data next 逻辑上相邻的两个元素在物理位置上不相邻 头结点和头指针 头指针：指向第一个结点（保存地址 头结点：链上第一个结点，为了操作方便而设立的 数据域为空/表长 对插入和删除结点的操作实现统一（不用经常重置头指针） 头结点不是必须 优点 插入和删除不用移动元素 无需大量连续存储空间 缺点 附加的指针域，存在浪费存储空间的缺点 查找操作要从头开始，不能随机存取 构造单链表123456//构造链表typedef int ElemType;typedef struct LNode { ElemType data; struct LNode* next;//注意这struct是必须要的，因为编译是从上到下,还不知道别名LNode}LNode, * LinkList; 头插法创建链表思路 记忆:像一个圆 代码1234567891011121314151617181920//头插法创建链表LinkList createLinkListByHead(LinkList&amp; L) { //创建头结点 LNode* p; int x; scanf(&quot;%d&quot;, &amp;x); L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; //循环创建结点 while (x != 9999) { LNode* s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s; scanf(&quot;%d&quot;, &amp;x); } return L;} 尾插法创建链表原理 代码 注意需要一个尾指针来方便操作 123456789101112131415161718192021//尾插法创建链表LinkList createLinkListByRail(LinkList&amp; L) { //创建头结点 L = (LNode*)malloc(sizeof(LNode)); LNode* p, * r = L;//r为临时指针 int x; scanf(&quot;%d&quot;, &amp;x); while (x != 9999) { //创建新结点 p = (LNode*)malloc(sizeof(LNode)); p-&gt;data = x; r-&gt;next = p;//尾插 r = p;//用临时结点保存为尾结点 scanf(&quot;%d&quot;, &amp;x); } //尾结点设置为空 r-&gt;next = NULL; return L;} 查找结点i位置思路 L=L-&gt;next 参数不用引用，只是查，并不用修改. 代码12345678910111213141516//按序号寻找结点LNode* getElem(LinkList L, int i) { if (i == 0) { return L; } if (i &lt; 1) { return NULL; } int j = 1; LNode* p = L-&gt;next; while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } return p;} 查找结点按值思路 L=L-&gt;next p-&gt;data!=值 参数不用引用，只是查，并不用修改. 代码123456789//按结点寻找结点LNode* locateLNode(LinkList L, ElemType i) { LNode* p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != i) { p = p-&gt;next; } return p;} 删除i位置节点思路 先通过getElem()找到删除i位置的前驱结点 临时结点q=前驱-&gt;next p-&gt;next=q-&gt;next 最后 q=NULL free(q) 代码123456789101112131415161718//删除第i个结点bool deleteLNode(LinkList&amp; L, int i) { //找到i位置的前驱 LNode* p = getElem(L, i - 1); if (p == NULL) { return false; } //删除操作 LNode* q = p-&gt;next; if (q==NULL) { return false; } p-&gt;next = q-&gt;next; free(q);//释放i位置结点的空间 q = NULL;//防止野指针} 第i位置插入节点思路 记忆:像一个圆 要先找到i位置的前驱 代码1234567891011121314//向第i个结点插入新结点bool insertLNode(LinkList&amp; L, int i, ElemType num) { //找到插入位置的前驱 LNode* p = getElem(L, i - 1); if (p == NULL) { return false; } //插入操作 LNode* q = (LNode*)malloc(sizeof(LNode)); q-&gt;data = num; q-&gt;next = p-&gt;next; p-&gt;next = q; return true;} 打印单链表注意 注意跳过头结点 L=L-&gt;next 代码1234567891011121314//打印链表数据void printLinkList(LinkList L) { //跳过头节点 L = L-&gt;next; //循环打印 while (L != NULL) { ElemType num = L-&gt;data; printf(&quot;%d &quot;, num); L = L-&gt;next; } printf(&quot;\\n&quot;);} 双链表特点 前指针 数据域 后指针 prior data next 逻辑上相邻的两个元素在物理位置上不相邻 构造双链表1234567typedef int Elemtype;typedef struct DNode { Elemtype data; struct DNode* prior; struct DNode* next;}DNode, * DLinkList; 头插法创建链表思路 记忆:想画一个八 注意: 123if (L-&gt;next != NULL) {//第一步需要这样做，不然会访问空 L-&gt;next-&gt;prior = p; } 代码12345678910111213141516171819202122//头插法void createDLinklist(DLinkList&amp; L, Elemtype elemArray[], int len) { //创建头结点 L = (DLinkList)malloc(sizeof(DNode)); //置空 L-&gt;next = NULL; L-&gt;prior = NULL; for (int i = 0; i &lt; len; i++) { DNode* p = (DNode*)malloc(sizeof(DNode)); //想插入那样 p-&gt;data = elemArray[i]; p-&gt;next = L-&gt;next; if (L-&gt;next != NULL) {//第一步需要这样做，不然会访问空 L-&gt;next-&gt;prior = p; } p-&gt;prior = L; L-&gt;next = p; }} 尾插法创建链表思路 代码 注意需要一个尾指针来方便操作r 尾指针最后==NULL 1r-&gt;next = NULL; 123456789101112131415161718192021222324//尾插法void createDLinkListByTail(DLinkList&amp; L, Elemtype ar[], int len) { L = (DNode*)malloc(sizeof(DNode)); L-&gt;next = NULL; L-&gt;prior = NULL; DNode* r = L;//尾指针 for (int i = 0; i &lt; len; i++) { DNode* p = (DNode*)malloc(sizeof(DNode)); p-&gt;data = ar[i]; //直接在后面插入 //r,p //p-&gt;prior = r; //r-&gt;next = p; r-&gt;next = p; p-&gt;prior = r; r = p; } r-&gt;next = NULL;} 删除i位置节点思路 先通过getElem()找到i位置结点的前驱结点 注意（删除最后结点的情况要考虑） 1234//检查删除结点的后驱是否为空 if (q-&gt;next != NULL) { q-&gt;next-&gt;prior = p; } 代码12345678910111213141516171819202122232425262728//删除i位置的结点bool deleteDNode(DLinkList&amp; L, int i) { //防止越位 if (i &lt; 0) { return false; } //查找i点的前驱 DNode* p = getDNode(L, i - 1); //检查i点是否存在 if ((p-&gt;next) == NULL) { return false; } //保存删除结点指针 DNode* q = p-&gt;next; //p,q p-&gt;next = q-&gt;next; //检查删除结点的后驱是否为空 if (q-&gt;next != NULL) { q-&gt;next-&gt;prior = p; } //释放q空间 free(q); //防止野指针 q = NULL; return true;} 其余的和单链表差不多循环单链表特点 最后的结点的next不是NULL，而是指向头结点L 其他和单链表一样 注意在一些循环操作中，注意结束符号是 r-&gt;next=L while(p-&gt;next!=L) 循环双链表特点 最后的结点next指向头结点L 头节点的prior指向最后结点 其他和单链表一样 注意在一些循环操作中，注意结束符号 静态链表特点用数组来描述链式存储结构 数组地址 数据域 存储地址 代码12345#define Maxsize 20typedef struct SLinkList{ ElemType data; int next;}SLinkList[Maxsize]; 栈Stack特性定义只允许在一段进行插入/删除操作的线性表 特性先进后出(FILO,First In Last Out) 栈顺序用顺序表构建栈 结构123456789//栈数据类型#define MaxSize 5typedef int ElemType;typedef struct { ElemType data[MaxSize]; int top;//数据内容长度(并且是top栈顶元素的数组下标) //从-1到Maxsize-1 //不仅是数组下标而且还是是数组容量}SqStack; 初始化initStack思路 top=-1 代码12345//初始化栈initStackvoid initStack(SqStack&amp; s) { //栈下标为-1 s.top = -1;} 检查栈空isEmpty思路 检查top==-1 代码12345678//检查栈空stackEmptybool stackEmpty(SqStack&amp; s) { if (s.top == -1) { return false; } return true;} 入栈push思路 判定栈是否满 先对top++ 再对对应位置赋值 代码123456789101112//入栈pushbool push(SqStack&amp; s, ElemType num) { //判读栈是否满 if (s.top == MaxSize - 1) { return false; } //++s.top 先将-1加加到0 下标 //然后赋值 s.data[++s.top] = num; return true;} 出栈pop思路 先判断栈是否为空 先获得值 再top– 代码1234567891011//出栈popbool pop(SqStack&amp; s, ElemType&amp; num) { //判断栈是否空 if (stackEmpty(s)) { return false; } //s.top-- 先给他赋值 //在容量-- num = s.data[s.top--]; return true;} 获得栈顶元素getTop思路 检查是否为空 直接用top获得栈顶元素 代码12345678910//获取顶点getTopbool getTop(SqStack s, ElemType&amp; num) { //判断是否为空 if (stackEmpty(s)) { return false; } //获得顶点(top) num = s.data[s.top]; return true;} 栈链式(带头结点)结构 一个是指针 一个节点 1234567//结构#define Maxsize 5typedef int Elemtype;typedef struct LStackNode { Elemtype data; struct LStackNode* next;} *LStack, LStackNode; 初始化initStack思路 生成头结点 头结点设置为栈长==-1 代码12345678//初始化栈initStackvoid initStack(LStack&amp; L) { LStack head = (LStack)malloc(sizeof(LStackNode)); head-&gt;next = NULL; head-&gt;data = -1; L = head;} 检查栈空isEmpty思路 检查头节点的数据是否=-1 代码1234567//检查栈空stackEmptybool stackEmpty(LStack L) { if (L-&gt;data == -1) { return true; } return false;} 入栈push思路 头插法 头结点的长度++ 代码12345678910111213141516//入栈pushbool push(LStack&amp; L, Elemtype num) { if ((L-&gt;data) == (Maxsize - 1)) { //判断栈满 return false; } LStack top; top = (LStack)malloc(sizeof(LStackNode)); top-&gt;next = NULL; top-&gt;data = num; //头插法 top-&gt;next = L-&gt;next; L-&gt;next = top; L-&gt;data++; return true;} 出栈pop思路 删除第一个元素 头结点的长度– 代码1234567891011121314//出栈popbool pop(LStack&amp; L, Elemtype&amp; num) { if (stackEmpty(L)) { return false; } //头删除 LStack top = L-&gt;next; num = top-&gt;data; L-&gt;next = top-&gt;next; free(top); top = NULL; L-&gt;data--; return true;} 获得栈顶元素getTop思路 直接获取第一个元素 代码12345678910//获得栈顶元素getTopbool getTop(LStack L, Elemtype&amp; num) { if (stackEmpty(L)) { return false; } LStack top = L-&gt;next; num = top-&gt;data; return true;} 循环队列队列Queue定义 操作受限的线性表 只允许一端插入（入列） 另一端删除(出列) 特征 先进先出(FLFO,First ln First Out) 要牺牲一个格，来判断队空还是队满 队空 Q.rear==Q.front 队满 Q.rear==(Q.front+1)%Maxsize 顺序表实现队列结构思路 数组放数据 front：队首 rear：队尾 入列——队尾++ 出列——队首++ 像个轮盘 代码123456#define Maxsize 6typedef int Elemtype;typedef struct SqQueue { Elemtype data[Maxsize]; int front, rear;}SqQueue; 初始化队列思路 队首和队尾在一开始 代码12345//初始化队列void initQueue(SqQueue&amp; q) { q.front = 0; q.rear = 0;} 队列是否为空思路 队尾和队首是否相差隔一格(队首在前，队尾向后) 代码1234567//队列是否为空bool isEmpty(SqQueue q) { if (q.front == (q.rear + 1) % Maxsize) { return true; } return false;} 入列思路 检查队列是否满 在rear下标位置插入数据 rear向前一格 代码12345678910//入列bool enQueue(SqQueue&amp; q, Elemtype num) { if (q.front == (q.rear + 1) % Maxsize) { return false; } q.data[q.rear] = num; q.rear = (q.rear + 1) % Maxsize; return true;} 出列思路 判定队列是否为空 拿出数据 队首向前一格 代码12345678910//出列bool deQueue(SqQueue&amp; q, Elemtype&amp; num) { if (q.front == q.rear) { return false; } num = q.data[q.front]; q.front = (q.front + 1) % Maxsize; return true;} 链表实现队列结构思路 一个是链结点 队首指针 队尾指针 代码123456#define Maxsize 5;typedef int Elemtype;typedef struct LinkNode { Elemtype data; struct LinkNode* next;} LinkNode; 12345typedef struct { //固定头结点为fornt作为出列 //尾插元素 实现入列 LinkNode* front, * rear;}LinkQueue; 初始化队列思路 队首生成头结点 代码12345//初始化队列void initQueue(LinkQueue&amp; q) { q.front = q.rear = (LinkNode*)malloc(sizeof(LinkNode)); q.front-&gt;next = NULL;} 队列是否为空思路 队首指针和队尾指针是否指向同一个结点 代码1234567//查看队列空bool isEmpty(LinkQueue q) { if (q.front == q.rear) { return true; } return false;} 入列思路 生成结点 尾插法 队尾指针rear 指向新结点 代码12345678910//入列(尾插)bool enQueue(LinkQueue&amp; q, Elemtype num) { //不用判满 LinkNode* rear = (LinkNode*)malloc(sizeof(LinkNode)); rear-&gt;next = NULL; rear-&gt;data = num; q.rear-&gt;next = rear; q.rear = rear; return true;} 出列思路 检查是否队列为空 拿出数据 头删法 注意：检查队首和队尾指针是否一样 队首赋值给队尾 free和指针设NULL 代码1234567891011121314151617//出列(头删)bool deQueue(LinkQueue&amp; q, Elemtype&amp; num) { if (q.front == q.rear) { return false; } LinkNode* fornt = q.front-&gt;next; num = fornt-&gt;data; //头删除 q.front-&gt;next = fornt-&gt;next; if (q.rear == q.front) {//当只有一个结点要删除 q.rear = q.front; } free(fornt); fornt = NULL;}","link":"/Liust1918.githud.io/2022/12/03/sb/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/Liust1918.githud.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Hexo","slug":"Hexo","link":"/Liust1918.githud.io/tags/Hexo/"}],"categories":[],"pages":[]}